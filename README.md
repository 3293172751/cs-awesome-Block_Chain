# 菜鸟的成长手册[![Awesome](https://cdn.rawgit.com/sindresorhus/awesome/d7305f38d29fed78fa85652e3a63e154dd8e8829/media/badge.svg)](https://github.com/cubxxw/cs-awesome-Block_Chain)

## 🧭 导航

+ 🔍[**快速指南(wike) — 仓库总结**](https://github.com/cubxxw/Block_Chain/wiki)

+ 🔗[**中国大陆加速地址（Gitee平台）**](https://gitee.com/xxw3293172751/Block_Chain)

+ 📵[**不限速在线个人云盘**](https://xxw.nsddd.top/s/wRSz)

  <p align='center'>
  <a href="https://gitee.com/xxw3293172751/Block_Chain"><img src="https://img.shields.io/badge/gitee-%40xxw3293172751-green?logo=gitee" title="国内gitee镜像加速"></a>
  <a href="https://wakatime.com/@c445b3c6-a2bc-43a2-a24a-0828a17244b4" title="项目的进展时长" > <img src="https://wakatime.com/badge/user/c445b3c6-a2bc-43a2-a24a-0828a17244b4.svg"></a>
  <a href="https://github.com/cubxxw/cs-awesome-Block_Chain/stargazers"><img alt="GitHub stars" src="https://img.shields.io/github/stars/3293172751/cs-awesome-Block_Chain?style=plastic"></a>
  <a href="https://xxw.nsddd.top/s/wRSz"><img alt="个人网盘不限速" src="https://img.shields.io/badge/cloud-xiongxinwei-red?logo=iCloud" title="个人网盘不限速下载浏览"></a>
  <a href="https://trackgit.com"><img src="https://us-central1-trackgit-analytics.cloudfunctions.net/token/ping/la3dpo1i7zzecvro53al" alt="trackgit-views" />
  </a>
  </p>

<div align="center">
	<a href = "https://github.com/cubxxw/cs-awesome-Block_Chain">🅱️GitHub</a>
	&emsp;&emsp; | &emsp;&emsp;
	<a href="https://interview.huihut.com">📚DocCub</a>
</div>

<div align="center">
	<a href = "readme_english.md">🔤English</a>
	&emsp;&emsp; | &emsp;&emsp;
	<a href = "README.md">🆑中文CN</a>
</div>
<br>

<details><summary><b>💡 关于</b></summary>

<p><a href='https://www.facebook.com/profile.php?id=100034435372354'>Facebook</a> | <a href='https://telsacoin.io/'>Website</a> | <a href='http://nsddd.top'>Blog</a> | <a href='https://t.me/smile3293172751'>Telegram</a> | <a href='https://twitter.com/xxw3293172751'>Twitter</a> | <a href='https://www.linkedin.cn/injobs/in/xiongxinwei-xiong-7606a0227'>Linkedin</a> | <a href='https://liberapay.com/xiongxinwei/donate'>Donate</a></p>
<p align='center'>
<a href="https://www.linkedin.cn/injobs/in/xiongxinwei-xiong-7606a0227" target="_blank"><img src="https://img.shields.io/badge/linkedin-xiongxinwei-yellowgreen?logo=linkedin&style=flat-square"></a>
<a href="https://twitter.com/xxw3293172751" target="_blank"><img src="https://img.shields.io/badge/twitter-%40xxw3293172751-informational?logo=twitter&style=flat-square"></a>
<a href="https://www.zhihu.com/people/3293172751" target="_blank"><img src="https://img.shields.io/badge/%E7%9F%A5%E4%B9%8E-%E9%93%BE%E5%AD%A6%E8%80%85%E7%A4%BE%E5%8C%BA-blue?logo=zhihu&style=flat-square"></a>
<a href="http://sm.nsddd.top/sm0d220ad72063197b9875379403f6c88.jpg" target="_blank"><img src="https://img.shields.io/badge/%E5%BE%AE%E4%BF%A1-smile-brightgreen?logo=wechat&style=flat-square"></a>
<a href="https://space.bilibili.com/1233089591" target="_blank"><img src="https://img.shields.io/badge/b%E7%AB%99-%E6%97%A0%E4%B8%8E%E4%BC%A6%E6%AF%94%E7%9A%84%E5%BE%97%E5%BE%97-red?logo=bilibili&style=flat-square"></a>
</p>
<p align='center'>
<a href="https://weibo.com/u/6248930985" target="_blank"><img src="https://img.shields.io/badge/%E5%BE%AE%E5%8D%9A-%E6%97%A0%E4%B8%8E%E4%BC%A6%E6%AF%94%E7%9A%84%E5%BE%97%E5%BE%97-critical?style=social&logo=Sina%20Weibo"></a>
<a href="https://github.com/cubxxw" target="_blank"><img src="https://img.shields.io/badge/Github-xiongxinwei-inactive?style=social&logo=github"></a>
<a href="http://nsddd.top" target="_blank"><img src="https://img.shields.io/badge/%E5%8D%9A%E5%AE%A2-%40xiongxinwei-blue?style=social&logo=Octopus%20Deploy"></a>
</p>
</hr>


 ⚠️ 这是一个菜鸟的成长记录，如果你也想成为工程师，想从事后端的相关工作，或者想了解区块链的相关知识，那么它可以帮助到你😎 —>  <b>喜欢请给个⭐收藏~</b>

 🐧 喜欢*Go*语言的朋友欢迎加入*Go*语言自学群（<a target="_blank" href="https://qm.qq.com/cgi-bin/qm/qr?k=ZZnzhuU8uGmIKT5btI9uiCRpasUeD8e2&jump_from=webapi&authKey=x1/NMrS1KpK7N8Rvj4IfLcKYSWnjtElgU6a3ubin1JmtReyuoIlyE/ZJ0VRlK25n"><img border="0" src="./images/group.png" alt="GoLang/Go语言/自学交流" title="GoLang/Go语言/自学交流"></a>*QQ*群号：[141984758](https://qm.qq.com/cgi-bin/qm/qr?k=ZZnzhuU8uGmIKT5btI9uiCRpasUeD8e2&jump_from=webapi&authKey=x1/NMrS1KpK7N8Rvj4IfLcKYSWnjtElgU6a3ubin1JmtReyuoIlyE/ZJ0VRlK25n)）

 ⛓️ <b>区块链技术（也称之为分布式账本技术）</b>，是一种互联网数据库技术，其特点是<font color ="gree">去中心化，公开透明，信息不可篡改性，隐私匿名性🤑</font><a href="https://github.com/C-UB">CUB链学社</a>致力打造<b>区块链自学教育平台。</b>

💡 侧边目录支持方式：[📚 DocCub 文档](https://go.nsddd.top)、🗃️[Github + TOC 导航](http://sm.nsddd.top/sm20221004130721.png?xxw@nsddd.top)， 😍 甚至你可以在这个界面按下`.` ➡️ [进入vscode编译环境](https://nsddd.top/archives/githubdev) 

👣 存在数学公式无法正常显示问题，强烈推荐[:triangular_ruler: MathJax Plugin for Github](https://chrome.google.com/webstore/detail/mathjax-plugin-for-github/ioemnmodlmafdkllaclgeombjnmnbima) 插件使用。

📄 保存为 PDF 方式：使用 Chrome 浏览器打开 <a href="https://go.nsddd.top">📚 DocCub 文档</a> 页面，缩起左侧目录-右键 - 打印 - 选择目标打印机是另存为PDF - 保存  —— [🖨️以Go语言第一节打印效果预览.pdf](./images/copy.pdf)）

🙏 仓库内容如有错误或改进欢迎 [issue](https://github.com/cubxxw/cs-awesome-Block_Chain/issues) 或 pr，[🧷参与贡献](https://nsddd.top/archives/contributors)，建议或讨论可在 [#10](https://github.com/cubxxw/cs-awesome-Block_Chain/issues/10) 提出。由于本人水平有限，仓库中的知识点有来自本人原创、读书笔记、书籍、博文等，非原创均已标明出处，如有遗漏，请 [issue](https://github.com/cubxxw/cs-awesome-Block_Chain/issues/new/choose) 提出。本仓库遵循 [CC BY-NC-SA 4.0（署名 - 非商业性使用 - 相同方式共享）](https://github.com/huihut/interview/blob/master/LICENSE) 协议，转载请注明出处，不得用于商业目的。

</details>

</hr>
<br>

## 🔥 CubDoc推出

🈺 存在`GitHub`上浏览效果不佳，[Cub链学社](https://github.com/C-UB)推出`CubDoc`文档形式，使用`vuejs`渲染 。使用国内的服务器搭建（速度嘎快:bullettrain_front:) 。目前支持以下的项目🗃️：

+ [x] [:speedboat: Go语言基础-进阶](https://go.nsddd.top)

+ [x] [:speedboat: docker & k8s & 云原生](https://docker.nsddd.top)

<br>

## 🗓️ My 博客精选

博客上面发表的文章具有独立性，是我参与开源项目以来，所见所得所学，希望这种模式可以成功并且得以模仿。[👀 我的博客](https://nsddd.top/) 记录着很多优质的内容值得一看，如果希望订阅 SSR ➡️[点这里](https://nsddd.top/rss.xml)

[<img align="left" alt="shenxianpeng | ZhiHu" width="22px" src="https://www.svgrepo.com/show/305628/zhihu.svg" />][zhihu] 

[zhihu]: https://www.zhihu.com/people/3293172751

<a href="https://www.zhihu.com/people/3293172751" target="_blank"><img src="https://img.shields.io/badge/%E7%9F%A5%E4%B9%8E-%E9%93%BE%E5%AD%A6%E8%80%85%E7%A4%BE%E5%8C%BA-blue?logo=zhihu&style=flat-square"></a>
<a href="http://sm.nsddd.top/sm0d220ad72063197b9875379403f6c88.jpg" target="_blank"><img src="https://img.shields.io/badge/%E5%BE%AE%E4%BF%A1-smile-brightgreen?logo=wechat&style=flat-square"></a>

<details><summary><b>📚 我的博客订阅（每周更新❗）</b></summary>
</br>
🔥 知乎专栏<b>每个工作日11：59自动更新一次（actions部署）</b> ，喜欢文章关注点赞👍噢~


<!-- My-Blog:START -->
- [高级的 Githook 设计](https://nsddd.top/archives/githook)
- [速读 sealos 源码 核心思想解析](https://nsddd.top/archives/sealos-source-code)
- [Kubernetes 二次开发 CRD 入门](https://nsddd.top/archives/kubernetes-crd)
- [开源之路：跨越八个阶段，成就行业佼佼者](https://nsddd.top/archives/open-source)
- [CloudNative / Kubernetes 学习资源整理](https://nsddd.top/archives/cloudnativekubernetes)
- [Istio 高级流量管理](https://nsddd.top/archives/istio)
- [Kubernetes 网络](https://nsddd.top/archives/kubernetes-network)
- [Kubernetes 概念以及架构](https://nsddd.top/archives/kubernetes-docker)
- [深挖容器底层技术（全）](https://nsddd.top/archives/dockers)
- [Clash for Linux(CLI)、Windows、Android](https://nsddd.top/archives/clash)
- [golangci-lin: Fast linters Runner for Go](https://nsddd.top/archives/golangci)
- [高质量的Makefile编写](https://nsddd.top/archives/makefile)
- [Gotests Automatically generate Go test](https://nsddd.top/archives/gotests)
- [git-chglog write your CHANGELOG](https://nsddd.top/archives/git-chglog)
- [Project specification and commit message](https://nsddd.top/archives/projectspecificationandcommitmessage)
- [GTD实践](https://nsddd.top/archives/gtd-todo)
- [技术领导力与职业规划: 人生路线图上的必读阅读推荐](https://nsddd.top/archives/career-development)
- [GitHub CLI 命令行工具（gh)](https://nsddd.top/archives/gh)
- [sealos开源社区~第一阶段](https://nsddd.top/archives/sealos-one)
- [在线vscode完成贡献和阅读](https://nsddd.top/archives/githubdev)
<!-- My-Blog:END -->

</details>

</hr>
<br>

## 📖 Go语言

#### 🏷️前言

`Go`语言的学习参考官网文档[go语言官方编程指南](https://golang.org/#)，如何找到合适的Go语言学习路线[Go语言路线](go-advancend/go_route.md)（🎈 含有大量的Go语言项目资源、线上资源收集）。

```mermaid
graph LR
程序员基本素养 ==> Go基础篇 ==>开发必备技术 ==> Go进阶100篇 ==> Go高级篇章 
```

+ 🔱[go语言官方编程指南](https://golang.org/#)  

+ 🚧[Go语言路线和资源征集(update 2023)](go-advancend/go_route.md)



#### 🔖核心

**Go语言的核心编程篇，基础部分30天记录，100篇进阶，高级篇包括Go语言底层的实现，runtime、调度器的原理以及Go语言设计模式~**

⚠️ 目前已全部迁移至 ➡️ [CubDoc🧷](https://go.nsddd.top/)

+ [x] [🖱️GO 基础部分🔥](awesome-golang/README.md)
+ [x] [🖱️Go语言100篇进阶🔥](awesome-golang/Gomd_super/README.md)
+ [x] [🖱️Go 高级篇](awesome-golang/go-advancend/README.md)
+ [ ] [🖱️Mit 6.824 笔记](awesome-golang/mit-6-824/README.md)



#### 📝补充

学习开源项目对于我们的成长非常大，我结合我自己的开源经历写了[这篇🎯开源之路：跨越八个阶段，成就行业佼佼者](https://nsddd.notion.site/f8854a0f60d346d98b9eb2ccb6eaef8f)。同[🧋 学习 Kubernetes 的成长轨迹](https://nsddd.notion.site/CloudNative-Kubernetes-2f278e98ed274999829333272415c72d)一样，这篇文章将会长期更新，也可以参与贡献 ，补全更新~。[k8s-iam](https://github.com/cubxxw/k8s-iam) 项目就是我结合Kubernetes 和 iam 这两个极为优秀的项目联合打造的k8s-iam 项目，对 [企业级 iam 项目](https://github.com/marmotedu/iam/) 进行学习和仿写，以及对开源文档和技术细节的输出。iam 技术栈涵盖了开发环境配置、代码设计、常用包使用、HTTP、客户端CLI、RESTful设计、数据库操作、Swagger文档、Cache机制、业务逻辑处理、开发规范、API调试、部署方式和云原生架构设计等方面。有兴趣的可以一起阅读学习。

🥇 命名规范以及项目目录结构📇的设定对于一名合格的工程师来说也是非常重要的。下面是作为一名合格的开发者🤵，必须要会的基本素养。

+ [🖱️Go语言包管理工具 — mod包](Gomd_super/mod.md)

+ [🖱️Go-air实现热加载编译](Gomd_super/go-air.md)

+ [🖱️命名规则和代码规范](Gomd_super/name.md)

+ 🖱️[Go语言目录结构](Gomd_super/catalogue.md)

+ 🖱️[Go文件以及编码处理](Gomd_super/go_file.md)

+ 🖱️[正则表达式](Gomd_super/zhenze.md)

+ 🖱️[位运算技巧](Gomd_super/bitwise.md)

> Go语言一些其他的网站和博客，值得一看
>
> + [Go语言面试题](https://www.topgoer.cn/docs/gomianshiti/mianshiti)
> + [Go语言中文官方文档](http://word.topgoer.com/)
> + [Go语言专家编程地址](http://wen.topgoer.com/docs/gozhuanjia/gogfjhk)

<br>



##  👀 Cloud Native

💡 这是一个关于云原生领域的仓库，涉及到 docker、Kubernetes、cloud native 知识，包括 docker 架构和底层实现，包括Kubernetes的架构、原理、生态以及源码阅读。还有  Cloud Native 其他领域知识，以及各个 CNCF 开源社区项目学习。

+ [x] [docker](awesome-docker-kubernetes/README.md)
+ [x] [Kubernetes](awesome-docker-kubernetes/Cloud-Native-k8s/README.md) 
+ [x] [CloudNative](awesome-docker-kubernetes/Cloud-Native/README.md)



## 📚 CS系列

CS 系列选自[🎉awesome-cs-course](https://github.com/cubxxw/awesome-cs-course)，内容涵盖 计算机操作系统、csapp系列、算法和数据结构、计算机网络、`linux`、`java`、`python`、`C/C++`、`vuepress`、`gitbook`、`nodejs`、`vuejs`、`halo`、`redis`、`hugo`、`nginx`、`nosql`、`mysql`、`JavaScript`、`git`、`markdown`、`web`前端等笔记，更多移步到[AWESOME系列CS仓库地址](https://github.com/cubxxw/awesome-cs-course/)

+ [x] [Java全册☕](https://github.com/cubxxw/awesome-cs-course/blob/master/java/README.md)

+ [x] [汇编学习🔥](汇编/README.md)

+ [x] [软件工程](./软件工程&系统设计和架构/README.md)

+ [x] [算法与数据结构（LeetCode刷题记录）](https://github.com/cubxxw/LeetCode/)

+ [x] [计算机网络🔥](./web/README.md)

+ [x] [操作系统 — OS🔥](https://github.com/cubxxw/os)

+ [x] [CS必须要会的技术🔥](cs/README.md)

<br>

## 📘 开发必备技术

🧋参与普通程序的开发或者是区块链⛓️开发必须[熟悉Linux指令](https://github.com/cubxxw/awesome-cs-course/blob/master/linux/README.md)，熟悉[git团队开发](https://github.com/cubxxw/awesome-cs-course/blob/master/Git/README.md)，基于[docker容器](docker/README.md)会让我门快速的搭建工具和环境，更好的迁移开发环境和迁移链码（blockcode)，[密码学和信息安全](cryptology/README.md)不仅仅是区块链工程师必须要学习的技术，更是IT从业者未来不可或缺的技术。我们都渴望系统能更加的安全不是吗📵。

⚠️ `Docker` 、`K8s`、`sealos`、`云原生` 已全部迁移至 ➡️ [CubDoc🧷](https://docker.nsddd.top/)

+ [x] 🖱️ [linux从入门到精通🔥](https://github.com/cubxxw/awesome-cs-course/blob/master/linux/README.md)

+ [x] 🖱️ [Git—必备神器🔥](https://github.com/cubxxw/awesome-cs-course/blob/master/Git/README.md)

+ [x] [🖱️ Docker/k8s/云原生🔥](docker/README.md) 

+ [x] [🖱️ 密码学和信息安全🔥](cryptology/README.md)

<br>

## 📔 区块链导航

<font size = 2>我认为世界历史可以用两句话来描述：分久必合，合久必分。区块链将是催化下一个‘合久必分’时代的新技术。区块链的产生铸就了一个新的时代，我们的信念是建筑在一个数学的算法上面，In math we trust。	——张首晟</font>

:spider_web: 这是一个web2的世界，或者很快整个互联网行业都会改革，是的，都会迈入web3的世界

> 🔥 我深以为然：区块链或许不能让这个世界分布化，但是它可以让世界不再有中介。不在会因为你所玩游戏崩溃你就失去了这个游戏~

从事区块链，需要哪些基础知识，看下[区块链开发需要什么](C_Universal_Brockchain\chain.md) ，你需要一份[区块链工程师路线](./blockchain/route.md)，或许你可以在一些区块链项目中找到灵感[🔗区块链公益项目（NFT+私链/联盟链/私链）](blockchain/区块链公益项目/README.md)。区块链的[共识算法](blockchain/README.md)是怎么实现的呢?

+ [x] [🔗区块链工程师路线](./blockchain/route.md)

+ [x] [🔗区块链开发需要什么❓](C_Universal_Brockchain\chain.md)

+ [x] [🔗区块链公益项目（NFT+私链/联盟链/私链）](blockchain/区块链公益项目/README.md)
+ [x] [🔗共识算法——Go语言实现](./blockchain/README.md)

<br>

## :b: 区块链教程

💱 区块链系列包含了区块链教程，主要是`eth`、`btc`还有联盟链`fabric`超级账本组织的教程，基于这些教程扩展新的技术：`git`、`ipfs`、密码学、共识算法。

📮 这个也是我们`C-UB`社区的最终目的，我们要打造出一个不一样的全民学习平台，将会融合一切新型技术（`ipfs`、`git`、`k8s`、`Kafka`)，基于web3的c-ub社区，属于我们每一个人！或许这将会有能力成为下一个时代的先驱，完全改变人类的协同方式。当人与人之间更信任，效率就会更高。

🚸 以及链学项目[C-Universal Blockchain](https://github.com/c-ub)

> 以太坊和比特币一样，底层框架都是区块链协议，区块链本质上是一个应用了密码学技术的分布式数据库系统。建议看一下 **[以太坊白皮书](https://github.com/ethereum/wiki/wiki/%5B%E4%B8%AD%E6%96%87%5D-%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%99%BD%E7%9A%AE%E4%B9%A6)（需要有golang编程基础）**
>
> <div align="center">
> <a href="eth/TOC.md">
> 	<img src="https://sm.nsddd.top//typora/image-20220630192622583.png?mail:3293172751@qq.com" alt="区块链的学习" style="zoom: 20%;" />
> </a></div>

+ [x] [🖱️区块链教程🔥](C_Universal_Brockchain/README.md)

+ [x] [🖱️web3，智能合约](eth/README.md)

+ [x] [🖱️区块链技术指南](chainbrock-learning/SUMMARY.md)

> 企业级[区块链实战教程](https://learnblockchain.cn/books/enterprise/)

<br>



## 🗃️ 项目

为了方便管理，我将所有的知识仓库以及贡献开源项目所克隆的仓库放在了我的个人账户 [cubxxw](https://github.com) 中，将所有的项目和规范有关的仓库都放在了自己创建的社区 [kubecub](https://github.com/kubecub) 中方便所有人加入并且学习，并且将所有自动化相关的账户都使用了 [robot(kubbot)](https://github.com/kubbot) 机器人来进行自动化和控制。 

我参与过很多顶级开源社区，包括 [sealer](https://github.com/sealerio/sealer)、[sealos](https://github.com/labring/sealos)、[Kubernetes](https://github.com/kubernetes/kubernetes/)、[OpenIM](https://github.com/OpenIMSDK)、[K8sgpt](https://github.com/k8sgpt-ai/k8sgpt)、[Horizon](https://github.com/horizoncd/horizon/) 以及 我自己打造的 开源社区 [Kubecub](https://github.com/kubecub)。kubecub 中有很多我沉淀下来的开源规范以及代码、项目规范都总结在各个仓库中。并且，Kubecub 和 OpenIM 使用了我创造的 [🤖 robot(kubbot)](https://github.com/kubbot) 来对 PR 和 Issue 高度自动化。kubecub 宗旨是面向所有的开发者进行学习和创造的，你可以在里面利用我们的自动化工具和模板打造自己的开源项目，并且让更多的人来帮助你协同、review 代码。

在里面积累了很多的开源经验，并且记录在我的 [博客](https://nsddd.top) 中，其中，很多的提案和在贡献的成长笔记，所学习到的知识都在 [CloudNative](https://docker.nsddd.top/Cloud-Native/) 这篇知识库中有所记录。

> <p align = "center" color="red">
> <b> kubecub（kubecub-开源社区）</b>    
> </p>
>
> <div align="center">
> <a href="https://github.com/kubecub">
> 	<img src="http://sm.nsddd.top/sm202305242215086.png"  alt="twitter_header_photo_1" style="zoom: 20%;" />
> </a></div>
>
> 欢迎加入 kubecub 社区一起学习、为开源做贡献 ! 为了方便每一位开源爱好者交流和学习，我们在 slack 中集成了 很多自动化工具以及 AI，欢迎大家 [🔥加入 Slack](https://join.slack.com/t/kubecub/shared_invite/zt-1se0k2bae-lkYzz0_T~BYh3rjkvlcUqQ)。


## ✨ 参与贡献💕

 **[🫵 参与贡献💖❤️‍🩹💓💞](https://nsddd.top/archives/contributors)** 

**[😍 甚至你可以在这个界面按下`.`进入vscode编译环境](https://nsddd.top/archives/githubdev)** 

**要求：**

+ [你需要学会使用markdown🖱️](https://github.com/cubxxw/awesome-cs-course/blob/master/markdown/README.md)
+ [符合Google代码规范](https://zh-google-styleguide.readthedocs.io/en/latest/google-cpp-styleguide/)

<details><summary><b>🫡 克隆此仓库到本地</b></summary>
<pre><code>git clone https://ghproxy.com/https://github.com/cubxxw/Block_Chain.git 菜鸟的成长手册
</code></pre>
<pre><code>wget -c -d -O gitsync.sh https://sm.nsddd.top/uploads/2022/10/27/Y0iHb6ix_gitsync.sh?attname=gitsync.sh && echo "gitsync.sh" >> .gitignore && sh gitsync.sh 这里写提交信息~ && chmod 777 gitsync.sh
</code></pre>


</details>

<br>

<font size = 2>🎯 如果你也想对本项目做出贡献，那么你可以先把该项目进行 [fork](https://github.com/cubxxw/cs-awesome-Block_Chain/fork)或者 `git clone` 到本地（推荐先用 [fock](https://github.com/cubxxw/cs-awesome-Block_Chain/fork)到自己仓库，然后再clone到本地，对本地进行操作，最后从自己仓库贡献，然后自己建立一个分支 `your-branch`，然后上传资料到 对应目录 下，图片信息可以上传到` /images`，然后更新 `README`。 </font>

 

## [![Repography logo](https://images.repography.com/logo.svg)](https://repography.com) / Recent activity [![Time period](https://images.repography.com/26892425/3293172751/Block_Chain/recent-activity/04864df8cf8f1f104b2b9453e0b47498_badge.svg)](https://repography.com)

![Alt](https://repobeats.axiom.co/api/embed/7053fe17b2bd9f88a0015474635e09cff7dc1ee2.svg "Repobeats analytics image")
[![FOSSA Status](https://app.fossa.com/api/projects/git%2Bgithub.com%2F3293172751%2Fcs-awesome-Block_Chain.svg?type=shield)](https://app.fossa.com/projects/git%2Bgithub.com%2F3293172751%2Fcs-awesome-Block_Chain?ref=badge_shield)


[![Timeline graph](https://images.repography.com/26892425/3293172751/Block_Chain/recent-activity/04864df8cf8f1f104b2b9453e0b47498_timeline.svg)](https://github.com/cubxxw/Block_Chain/commits)
[![Issue status graph](https://images.repography.com/26892425/3293172751/Block_Chain/recent-activity/04864df8cf8f1f104b2b9453e0b47498_issues.svg)](https://github.com/cubxxw/Block_Chain/issues)
[![Pull request status graph](https://images.repography.com/26892425/3293172751/Block_Chain/recent-activity/04864df8cf8f1f104b2b9453e0b47498_prs.svg)](https://github.com/cubxxw/Block_Chain/pulls)
![Trending topics](https://images.repography.com/26892425/3293172751/Block_Chain/recent-activity/04864df8cf8f1f104b2b9453e0b47498_words.svg)

<br>

## 💡 版权声明 &copy;

[![GitHub license](https://sm.nsddd.top//typora/cs-awesome-Block_Chain?mail:3293172751@qq.com)](http://zh.wikipedia.org/wiki/Wikipedia:CC-by-sa-3.0协议文本)

***License**:* 本书所有内容遵循[CC-BY-SA 3.0协议（署名-相同方式共享）&copy;](http://zh.wikipedia.org/wiki/Wikipedia:CC-by-sa-3.0协议文本) 

[![FOSSA Status](https://app.fossa.com/api/projects/git%2Bgithub.com%2F3293172751%2Fcs-awesome-Block_Chain.svg?type=large)](https://app.fossa.com/projects/git%2Bgithub.com%2F3293172751%2Fcs-awesome-Block_Chain?ref=badge_large)


## 📖 知乎订阅

🥰 订阅了我的 [知乎账户](https://www.zhihu.com/people/3293172751) 里面的 [云原生精选文章专栏](https://www.zhihu.com/column/c_1496496113348206594)。展开可在 GitHub 中即可阅读全文。

<!-- ZHIHU:START -->
 #### - [go 语言工具包](https://zhuanlan.zhihu.com/p/631662028) 
 <details><summary>توضیحات</summary> <p><img src="https://picx.zhimg.com/v2-4ff73ff11d72de6e14b7a5a79d9d63a5_720w.jpg?source=d16d100b"></p><div><p data-pid="Ahqp4nnO">翻译自(部分）：</p><blockquote data-pid="5v0dfHlA">更全的翻译在（知乎字数多太卡）<a href="https://docker.nsddd.top/Cloud-Native/66.html" target="_blank">第66节 go 语言工具包 | 你好</a></blockquote><a href="https://github.com/avelino/awesome-go" data-draft-node="block" data-draft-type="link-card" target="_blank"><span class="invisible">https://</span><span class="visible">github.com/avelino/awes</span><span class="invisible">ome-go</span><span class="ellipsis"></span></a><h2><b>音频和音乐</b></h2><p data-pid="LJmH-Lta"><i>用于处理音频的库。</i></p><ul><li data-pid="FtHMnAnX"><a href="https://github.com/mewkiz/flac" target="_blank">flac</a> - 支持 FLAC 流的 Native Go FLAC 编码器/解码器.</li><li data-pid="f6HfspDT"><a href="https://github.com/Comcast/gaad" target="_blank">gaad</a> - 本机 Go AAC 比特流解析器。</li><li data-pid="nI9QuG0c"><a href="https://github.com/DylanMeeus/GoAudio" target="_blank">GoAudio</a> - 本机 Go 音频处理库。</li><li data-pid="IbZv3HoQ"><a href="https://github.com/dh1tw/gosamplerate" target="_blank">gosamplerate</a> -go 的 libsamplerate 绑定。</li><li data-pid="3B4Yd2-T"><a href="https://github.com/bogem/id3v2" target="_blank">id3v2</a> - Go 的 ID3 解码和编码库。</li><li data-pid="r06Jjvyb"><a href="https://github.com/gen2brain/malgo" target="_blank">malgo</a> - 迷你音频库。</li><li data-pid="_0pSk1UT"><a href="https://github.com/tosone/minimp3" target="_blank">minimp3</a> - 轻量级 MP3 解码器库。</li><li data-pid="tT0UDWk_"><a href="https://github.com/hajimehoshi/oto" target="_blank">Oto</a> - 一个在多个平台上播放声音的低级库。</li><li data-pid="8ZOO2Opt"><a href="https://github.com/gordonklaus/portaudio" target="_blank">PortAudio</a> - PortAudio 音频 I/O 库的绑定。</li></ul><p data-pid="hLtAHnXH"><b><a href="https://github.com/avelino/awesome-go/blob/main/README.md#contents" target="_blank">⬆回到顶部</a></b></p><h2><b>身份验证和 OAuth</b></h2><p data-pid="WbeOPH7D"><i>用于实现身份验证方案的库。</i></p><ul><li data-pid="Z5LzPIE9"><a href="https://github.com/volatiletech/authboss" target="_blank">authboss</a> - 用于网络的模块化身份验证系统。它尝试尽可能多地删除样板和“困难的东西”，以便每次您在 Go 中启动一个新的 Web 项目时，您都可以插入它、配置它并开始构建您的应用程序，而不必每次都构建一个身份验证系统.</li><li data-pid="ZSRSsuq5"><a href="https://github.com/essentialkaos/branca" target="_blank">branca</a> - Golang 1.15+ 的branca 令牌<a href="https://github.com/tuupola/branca-spec" target="_blank">规范实现。</a></li><li data-pid="fYs-8lFn"><a href="https://github.com/hsluoyz/casbin" target="_blank">casbin</a> - 支持访问控制模型（如 ACL、RBAC 和 ABAC）的授权库。</li><li data-pid="eV8Ibi7h"><a href="https://github.com/mengzhuo/cookiestxt" target="_blank">cookiestxt</a> - 提供 cookies.txt 文件格式的解析器。</li><li data-pid="ju2zKTEk"><a href="https://github.com/shaj13/go-guardian" target="_blank">go-guardian</a> -Go-Guardian 是一个 golang 库，它提供了一种简单、干净和惯用的方式来创建强大的现代 API 和 Web 身份验证，支持 LDAP、Basic、Bearer 令牌和基于证书的身份验证。</li><li data-pid="X2zdthpU"><a href="https://github.com/go-jose/go-jose" target="_blank">go-jose</a> - 相当完整地实现了 JOSE 工作组的 JSON Web 令牌、JSON Web 签名和 JSON Web 加密规范。</li><li data-pid="3o2Qe_35"><a href="https://github.com/dghubble/gologin" target="_blank">gologin</a> - 用于使用 OAuth1 和 OAuth2 身份验证提供程序登录的可链接处理程序。</li><li data-pid="T1kFHl3U"><a href="https://github.com/mikespook/gorbac" target="_blank">gorbac</a> - 在 Golang 中提供轻量级的基于角色的访问控制 (RBAC) 实现。</li><li data-pid="EvjWb4KR"><a href="http://github.com/Kwynto/gosession" target="_blank">gosession</a> - 这是 GoLang 中 net/http 的快速会话。这个包可能是会话机制的最佳实现，或者至少它试图成为一个。</li><li data-pid="l1bz49Co"><a href="https://github.com/markbates/goth" target="_blank">goth</a> - 提供了一种简单、干净、惯用的方式来使用 OAuth 和 OAuth2。开箱即用地处理多个提供商。</li><li data-pid="K5aDOYPC"><a href="https://github.com/abraithwaite/jeff" target="_blank">jeff</a> - 具有可插入后端的简单、灵活、安全和惯用的 Web 会话管理。</li><li data-pid="jz0YlwTs"><a href="https://github.com/pascaldekloe/jwt" target="_blank">jwt</a> - 轻量级 JSON Web 令牌（JWT）库。</li><li data-pid="cvxxOWdt"><a href="https://github.com/cristalhq/jwt" target="_blank">jwt</a> - 用于 Go 的安全、简单和快速的 JSON Web 令牌。</li><li data-pid="IA1arD34"><a href="https://github.com/adam-hanna/jwt-auth" target="_blank">jwt-auth</a> - 用于具有许多配置选项的 Golang http 服务器的 JWT 中间件。</li><li data-pid="CEIx_5zS"><a href="https://github.com/golang-jwt/jwt" target="_blank">jwt-go</a> - JSON Web Tokens (JWT) 的全功能实现。该库支持 JWT 的解析和验证以及生成和签名。</li><li data-pid="yC3QpBUQ"><a href="https://github.com/ory/keto" target="_blank">keto</a> - “Zanzibar：Google 一致的全球授权系统”的开源（Go）实现。提供 gRPC、REST API、newSQL 和一种简单而精细的权限语言。支持ACL、RBAC等访问模型。</li><li data-pid="0B-TvEO5"><a href="https://github.com/tarent/loginsrv" target="_blank">loginsrv</a> - 具有可插入后端的 JWT 登录微服务，例如 OAuth2 (Github)、htpasswd、osiam.</li><li data-pid="TMdL91E9"><a href="https://github.com/golang/oauth2" target="_blank">oauth2</a> - goauth2 的继任者。带有 JWT、Google API、Compute Engine 和 App Engine 支持的通用 OAuth 2.0 包。</li><li data-pid="yL_H6yWz"><a href="https://github.com/openshift/osin" target="_blank">osin</a> -Golang OAuth2 服务器库。</li><li data-pid="_64_6UXZ"><a href="https://github.com/grijul/otpgen" target="_blank">otpgen</a> - 生成 TOTP/HOTP 代码的库。</li><li data-pid="4A_OyZ4q"><a href="https://github.com/jltorresm/otpgo" target="_blank">otpgo</a> -Go 的基于时间的一次性密码（TOTP）和基于 HMAC 的一次性密码（HOTP）库。</li><li data-pid="Cu8G-l3v"><a href="https://github.com/o1egl/paseto" target="_blank">paseto</a> - 与平台无关的安全令牌 (PASETO) 的 Golang 实现。</li><li data-pid="gyZswnaL"><a href="https://github.com/xyproto/permissions2" target="_blank">permissions2</a> - 用于跟踪用户、登录状态和权限的库。使用安全 cookie 和 bcrypt。</li><li data-pid="zq58BFIH"><a href="https://github.com/SonicRoshan/scope" target="_blank">scope</a> - 在 Go 中轻松管理 OAuth2 范围。</li><li data-pid="afoiZnzD"><a href="https://github.com/alexedwards/scs" target="_blank">scs</a> - HTTP 服务器的会话管理器。</li><li data-pid="m76sL9d9"><a href="https://github.com/chmike/securecookie" target="_blank">securecookie</a> - 高效的安全 cookie 编码/解码。</li><li data-pid="HML55SIs"><a href="https://github.com/icza/session" target="_blank">session</a> - 用于 Web 服务器的 Go 会话管理（包括对 Google App Engine - GAE 的支持）。</li><li data-pid="DZXOpMxk"><a href="https://github.com/adam-hanna/sessions" target="_blank">sessions</a> - 用于 go http 服务器的非常简单、高性能、高度可定制的会话服务。</li><li data-pid="jA-SfNEs"><a href="https://github.com/swithek/sessionup" target="_blank">sessionup</a> - 简单但有效的 HTTP 会话管理和识别包。</li><li data-pid="_DLBsZ-T"><a href="https://github.com/brianvoe/sjwt" target="_blank">sjwt</a> - 简单的 jwt 生成器和解析器。</li></ul><p data-pid="S-GmJBaY"><b><a href="https://github.com/avelino/awesome-go/blob/main/README.md#contents" target="_blank">⬆回到顶部</a></b></p><h2><b>区块链</b></h2><p data-pid="auXNacxb"><i>构建区块链的工具。</i></p><ul><li data-pid="9iZeXKrY"><a href="https://github.com/cosmos/cosmos-sdk" target="_blank">cosmos-sdk</a> - 在 Cosmos 生态系统中构建公共区块链的框架。</li><li data-pid="OQbpguUC"><a href="https://github.com/ethereum/go-ethereum" target="_blank">go-ethereum</a> - 以太坊协议的官方 Go 实现。</li><li data-pid="jCouAUPk"><a href="https://github.com/ChainSafe/gossamer" target="_blank">gossamer</a> - Polkadot 主机的 Go 实现。</li><li data-pid="nVh7HmC9"><a href="https://github.com/gagliardetto/solana-go" target="_blank">solana-go</a> - 与 Solana JSON RPC 和 WebSocket 接口交互的 Go 库。</li><li data-pid="CdDO65jD"><a href="https://github.com/tendermint/tendermint" target="_blank">tendermint</a> - 高性能中间件，用于使用 Tendermint 共识和区块链协议将以任何编程语言编写的状态机转换为拜占庭容错复制状态机。</li></ul><p data-pid="M60fL4PE"><b><a href="https://github.com/avelino/awesome-go/blob/main/README.md#contents" target="_blank">⬆回到顶部</a></b></p><h2><b>机器人建筑</b></h2><p data-pid="P-AlSOoE"><i>用于构建和使用机器人的库。</i></p><ul><li data-pid="N9qbArU8"><a href="https://github.com/go-telegram/bot" target="_blank">bot</a> - 具有附加 UI 组件的零依赖性 Telegram Bot 库</li><li data-pid="W71gGXcx"><a href="https://github.com/NicoNex/echotron" target="_blank">echotron</a> -Go 中用于电报机器人的优雅且并发的库。</li><li data-pid="u-D12kUM"><a href="https://github.com/ewohltman/ephemeral-roles" target="_blank">ephemeral-roles</a> - 一个 Discord 机器人，用于根据语音通道成员的存在来管理临时角色。</li><li data-pid="LX-zJCjh"><a href="https://github.com/go-chat-bot/bot" target="_blank">go-chat-bot</a> - 用 Go 编写的 IRC、Slack 和 Telegram 机器人。</li><li data-pid="Phnwzf3o"><a href="https://joe-bot.net/" target="_blank">go-joe</a> - 受 Hubot 启发但用 Go 编写的通用机器人库。</li><li data-pid="4WPGxHA_"><a href="https://github.com/oklahomer/go-sarah" target="_blank">go-sarah</a> - 为所需的聊天服务构建机器人的框架，包括 LINE、Slack、Gitter 等。</li><li data-pid="rY_8wNST"><a href="https://github.com/olebedev/go-tgbot" target="_blank">go-tgbot</a> - 纯 Golang Telegram Bot API 包装器，由 swagger 文件、基于会话的路由器和中间件生成。</li><li data-pid="8ukphcRb"><a href="https://github.com/gempir/go-twitch-irc" target="_blank">go-twitch-irc</a> - 为 twitch.tv 聊天编写机器人的库</li><li data-pid="jifEs9jD"><a href="https://github.com/saniales/golang-crypto-trading-bot" target="_blank">Golang CryptoTrading Bot</a> - 基于控制台的加密货币交易交易机器人的 golang 实现。</li><li data-pid="EEsb2dn8"><a href="https://github.com/nikepan/govkbot" target="_blank">govkbot</a> - 简单的 Go <a href="https://vk.com/" target="_blank">VK</a>机器人库。</li><li data-pid="oV-_FlrR"><a href="https://github.com/sbstjn/hanu" target="_blank">hanu</a> - 编写 Slack 机器人的框架。</li><li data-pid="RJeUvV8y"><a href="https://github.com/stellar/kelp" target="_blank">Kelp - </a><a href="https://www.stellar.org/" target="_blank">Stellar</a> DEX的官方交易和做市机器人。开箱即用，用 Golang 编写，与中心化交易所和自定义交易策略兼容。</li><li data-pid="g8YW8Roo"><a href="https://github.com/ezeoleaf/larry" target="_blank">拉里</a>- 拉里 是一个非常简单的 Twitter 机器人生成器，它可以从 Github 中用 Go 构建的随机存储库中发送推文。</li><li data-pid="5wQ_hbTR"><a href="https://github.com/zhulik/margelet" target="_blank">margelet</a> - 用于构建 Telegram 机器人的框架。</li><li data-pid="MkRmldF3"><a href="https://github.com/onrik/micha" target="_blank">micha</a> - 用于 Telegram bot api 的 Go 库。</li><li data-pid="EovPM8bH"><a href="https://github.com/olivia-ai/olivia" target="_blank">olivia</a> - 使用人工神经网络构建的聊天机器人。</li><li data-pid="acnax6BZ"><a href="https://github.com/innogames/slack-bot" target="_blank">slack-bot</a> - 准备好为懒惰的开发人员使用 Slack Bot：自定义命令，Jenkins，Jira，Bitbucket，Github ...</li><li data-pid="rAmJXDMN"><a href="https://github.com/shomali11/slacker" target="_blank">slacker</a> - 易于使用的框架来创建 Slack 机器人。</li><li data-pid="D3bK8fVI"><a href="https://github.com/alexandre-normand/slackscot" target="_blank">slackscot</a> - 用于构建 Slack 机器人的另一个框架。</li><li data-pid="m0YNEyXF"><a href="https://github.com/yanzay/tbot" target="_blank">tbot</a> - 具有类似于 net/http 的 API 的电报机器人服务器。</li><li data-pid="P7aYd0Kg"><a href="https://github.com/tucnak/telebot" target="_blank">telebot</a> - Telegram 机器人框架是用 Go 编写的。</li><li data-pid="R_gNneQB"><a href="https://github.com/mymmrac/telego" target="_blank">telego</a> - 用于 Golang 的 Telegram Bot API 库，具有完整的一对一 API 实现。</li><li data-pid="Qk2286s-"><a href="https://github.com/Syfaro/telegram-bot-api" target="_blank">telegram-bot-api</a> - 简单干净的 Telegram 机器人客户端。</li><li data-pid="oldWBX6b"><a href="https://github.com/alfiankan/teleterm" target="_blank">teleterm</a> - 电报 Bot Exec 终端命令。</li><li data-pid="hoi1XAkf"><a href="https://github.com/kyleterry/tenyks" target="_blank">Tenyks</a> - 使用 Redis 和 JSON 进行消息传递的面向服务的 IRC 机器人。</li><li data-pid="lYPFpbWd"><a href="https://github.com/wabarc/wayback" target="_blank">wayback</a> - 用于 Telegram、Mastodon、Slack 和其他消息传递平台的机器人存档网页。</li></ul><p data-pid="qLmhetWY"><b><a href="https://github.com/avelino/awesome-go/blob/main/README.md#contents" target="_blank">⬆回到顶部</a></b></p><h2><b>构建自动化</b></h2><p data-pid="j7VduCvO"><i>库和工具有助于构建自动化。</i></p><ul><li data-pid="iqJAvujz"><a href="https://github.com/gopinath-langote/1build" target="_blank">1build</a> - 用于顺畅管理项目特定命令的命令行工具。</li><li data-pid="o9o6Hgkz"><a href="https://github.com/GuilhermeCaruso/anko" target="_blank">anko</a> - 多种编程语言的简单应用程序观察器。</li><li data-pid="Fhopd79b"><a href="https://github.com/maxcnunes/gaper" target="_blank">gaper</a> - 在 Go 项目崩溃或某些监视的文件更改时构建并重新启动它。</li><li data-pid="5TQFNOZX"><a href="https://go-gilbert.github.io/" target="_blank">gilbert</a> - 为 Go 项目构建系统和任务运行器。</li><li data-pid="UVIj7g2l"><a href="https://github.com/goyek/goyek" target="_blank">goyek</a> - 在 Go 中创建构建管道。</li><li data-pid="tHd0zmXP"><a href="https://github.com/magefile/mage" target="_blank">mage</a> -Mage 是一种使用 Go 的类似 make/rake 的构建工具。</li><li data-pid="1Dh8juRM"><a href="https://github.com/tj/mmake" target="_blank">mmake</a> - 现代品牌。</li><li data-pid="6gsoxkpW"><a href="https://github.com/tockins/realize" target="_blank">实现</a>- 去构建一个带有文件观察器的系统并重新加载。使用自定义路径运行、构建和观察文件更改。</li><li data-pid="g8m6kTpT"><a href="https://github.com/go-task/task" target="_blank">任务</a>- 简单的“制作”替代方案。</li><li data-pid="G89zndpc"><a href="https://github.com/taskctl/taskctl" target="_blank">taskctl</a> - 并发任务运行器。</li><li data-pid="yKdz2jK7"><a href="https://github.com/joerdav/xc" target="_blank">xc</a> - 带有 README.md 定义任务的任务运行器，可执行降价。</li></ul><p data-pid="FTZkFkKG"><b><a href="https://github.com/avelino/awesome-go/blob/main/README.md#contents" target="_blank">⬆回到顶部</a></b></p><h2><b>命令行</b></h2><h3><b>高级控制台用户界面</b></h3><p data-pid="alUzT4Ni"><i>用于构建控制台应用程序和控制台用户界面的库。</i></p><ul><li data-pid="JThpG3rl"><a href="https://github.com/guptarohit/asciigraph" target="_blank">asciigraph</a> -Go 包可在命令行应用程序中制作轻量级 ASCII 线图 ╭┈╯，无需其他依赖项。</li><li data-pid="0W4rSNgd"><a href="https://github.com/logrusorgru/aurora" target="_blank">aurora</a> - 支持 fmt.Printf/Sprintf 的 ANSI 终端颜色。</li><li data-pid="CvMTnjmZ"><a href="https://github.com/Delta456/box-cli-maker" target="_blank">box-cli-maker</a> - 为您的 CLI 制作高度定制的盒子。</li><li data-pid="cyXZInqD"><a href="https://github.com/charmbracelet/bubbles" target="_blank">bubbles</a> - bubbletea 的 TUI 组件.</li><li data-pid="uUosOPbc"><a href="https://github.com/charmbracelet/bubbletea" target="_blank">bubbletea</a> - 基于 Elm 架构构建终端应用程序的 Go 框架。</li><li data-pid="tE75jM-j"><a href="https://github.com/mingrammer/cfmt" target="_blank">cfmt</a> - 受引导颜色类启发的上下文 fmt.</li><li data-pid="31dEzdBp"><a href="https://github.com/i582/cfmt" target="_blank">cfmt</a> - 简单方便的格式化程式化输出，与 fmt 库完全兼容。</li><li data-pid="bggTjsbn"><a href="https://github.com/ttacon/chalk" target="_blank">chalk</a> - 用于美化终端/控制台输出的直观包。</li><li data-pid="vlaMlRiT"><a href="https://github.com/TreyBastian/colourize" target="_blank">colourize</a> - 用于终端中 ANSI 颜色文本的 Go 库。</li><li data-pid="7tk-_hMq"><a href="https://github.com/alfiankan/crab-config-files-templating" target="_blank">crab-config-files-templating</a> - 用于 kubernetes 清单或通用配置文件的动态配置文件模板工具。</li><li data-pid="_gPx0wvF"><a href="https://github.com/wzshiming/ctc" target="_blank">ctc</a> - 非侵入式跨平台终端颜色库，无需修改 Print 方法。</li><li data-pid="eNB2cBB-"><a href="https://github.com/workanator/go-ataman" target="_blank">go-ataman</a> - 用于在终端中呈现 ANSI 彩色文本模板的 Go 库。</li><li data-pid="A6OgZIHb"><a href="https://github.com/mattn/go-colorable" target="_blank">go-colorable</a> - 适用于 windows 的着色器。</li><li data-pid="Wg3BCDnf"><a href="https://github.com/daviddengcn/go-colortext" target="_blank">go-colortext</a> - 用于在终端中输出颜色的 Go 库。</li><li data-pid="VfnPo2ty"><a href="https://github.com/mattn/go-isatty" target="_blank">go-isatty</a> -golang 的 isatty。</li><li data-pid="O8Dkqunw"><a href="https://github.com/abusomani/go-palette" target="_blank">go-palette</a> -Go 库，使用 ANSI 颜色提供优雅方便的样式定义。完全兼容并包装<a href="https://pkg.go.dev/fmt" target="_blank">fmt 库</a>以获得漂亮的终端布局。</li><li data-pid="-QysvGjl"><a href="https://github.com/c-bata/go-prompt" target="_blank">go-prompt</a> - 受<a href="https://github.com/jonathanslenders/python-prompt-toolkit" target="_blank">python-prompt-toolkit</a>启发，用于构建强大的交互式提示的库。</li><li data-pid="esUMoB3f"><a href="https://github.com/jroimartin/gocui" target="_blank">gocui</a> - 旨在创建控制台用户界面的极简主义 Go 库。</li><li data-pid="U_dehdCO"><a href="https://github.com/labstack/gommon/tree/master/color" target="_blank">gommon/color</a> - 样式终端文本。</li><li data-pid="B4MHJxFW"><a href="https://github.com/gookit/color" target="_blank">gookit/color</a> - 终端显色工具库，支持16色、256色、RGB显色输出，兼容Windows。</li><li data-pid="fyHYed5z"><a href="https://github.com/charmbracelet/lipgloss" target="_blank">lipgloss</a> - 在终端中以声明方式定义颜色、格式和布局的样式。</li><li data-pid="T1HAEcrS"><a href="https://github.com/cyucelen/marker" target="_blank">marker</a> - 为彩色终端输出匹配和标记字符串的最简单方法。</li><li data-pid="XHN305ko"><a href="https://github.com/vbauerster/mpb" target="_blank">mpb</a> - 终端应用程序的多进度条。</li><li data-pid="x8WxKZ9m"><a href="https://github.com/schollz/progressbar" target="_blank">progressbar</a> - 适用于每个操作系统的基本线程安全进度条。</li><li data-pid="aEUz89gm"><a href="https://github.com/pterm/pterm" target="_blank">pterm</a> - 一个库，用于在具有许多可组合组件的每个平台上美化控制台输出。</li><li data-pid="I12i2sOl"><a href="https://github.com/alexeyco/simpletable" target="_blank">simpletable</a> - 使用 Go 的终端中的简单表格。</li><li data-pid="nMZ_oEGX"><a href="https://github.com/briandowns/spinner" target="_blank">spinner</a> -Go 包可以轻松地为终端微调器提供选项。</li><li data-pid="v1_yHKNg"><a href="https://github.com/cheynewallace/tabby" target="_blank">tabby</a> - 一个用于超级简单 Golang 表的小型库。</li><li data-pid="1MnG4BYT"><a href="https://github.com/tomlazar/table" target="_blank">table</a> - 基于终端颜色的表格的小型库。</li><li data-pid="lEMMsf0r"><a href="https://github.com/InVisionApp/tabular" target="_blank">tabular</a> - 从命令行实用程序打印 ASCII 表，无需将大量数据传递给 API。</li><li data-pid="HknUvPLp"><a href="https://github.com/nsf/termbox-go" target="_blank">termbox-go</a> - Termbox 是一个用于创建基于文本的跨平台界面的库。</li><li data-pid="ACMZCbyy"><a href="https://github.com/mum4k/termdash" target="_blank">termdash</a> - 基于<b>termbox-go</b>并受<a href="https://github.com/gizak/termui" target="_blank">termui</a>启发的 Go 终端仪表板。</li><li data-pid="F_-bTtMU"><a href="https://github.com/muesli/termenv" target="_blank">termenv</a> - 为您的终端应用程序提供高级 ANSI 样式和颜色支持。</li><li data-pid="DdT4Abuz"><a href="https://github.com/gizak/termui" target="_blank">termui</a> - 基于<b>termbox-go</b>并受<a href="https://github.com/yaronn/blessed-contrib" target="_blank">blessed-contrib</a>启发的 Go 终端仪表板。</li><li data-pid="6ml7cll8"><a href="https://github.com/gosuri/uilive" target="_blank">uilive</a> - 用于实时更新终端输出的库。</li><li data-pid="XxDRVY-t"><a href="https://github.com/gosuri/uiprogress" target="_blank">uiprogress</a> - 灵活的库，用于在终端应用程序中呈现进度条。</li><li data-pid="q3NhbtUk"><a href="https://github.com/gosuri/uitable" target="_blank">uitable</a> - 使用表格数据提高终端应用程序可读性的库。</li><li data-pid="uonyVk0f"><a href="https://github.com/theckman/yacspin" target="_blank">yacspin</a> - 另一个 CLi Spinner 包，用于与终端微调器一起工作。</li></ul><p data-pid="n9jEGFZT"><b><a href="https://github.com/avelino/awesome-go/blob/main/README.md#contents" target="_blank">⬆回到顶部</a></b></p><h3><b>标准命令行界面</b></h3><p data-pid="sOodlRrz"><i>用于构建标准或基本命令行应用程序的库。</i></p><ul><li data-pid="_dXVUxrX"><a href="https://github.com/cristalhq/acmd" target="_blank">acmd</a> -Go 中简单、有用且自以为是的 CLI 包。</li><li data-pid="q-Z9GIWY"><a href="https://github.com/akamensky/argparse" target="_blank">argparse</a> - 受 Python 的 argparse 模块启发的命令行参数解析器。</li><li data-pid="DRhgeUr-"><a href="https://github.com/cosiner/argv" target="_blank">argv</a> - Go 库使用 bash 语法将命令行字符串拆分为参数数组。</li><li data-pid="AQ03kAx_"><a href="https://github.com/rsteube/carapace" target="_blank">carapace</a> - spf13/cobra 的命令参数完成生成器。</li><li data-pid="Xrbq35u6"><a href="https://github.com/rsteube/carapace-bin" target="_blank">carapace-bin</a> - 多 shell 多命令参数完成器。</li><li data-pid="mn4Q3akt"><a href="https://github.com/rsteube/carapace-spec" target="_blank">carapace-spec</a> - 使用 spec 文件定义简单的完成。</li><li data-pid="fXJ8DFt-"><a href="https://github.com/mkideal/cli" target="_blank">cli</a> - 基于 golang struct 标签的功能丰富且易于使用的命令行包。</li><li data-pid="-u-08c7W"><a href="https://github.com/teris-io/cli" target="_blank">cli</a> - 用于在 Go 中构建命令行界面的简单而完整的 API。</li><li data-pid="Ii3Fxd6v"><a href="https://github.com/tucnak/climax" target="_blank">climax</a> - 本着 Go 命令的精神，具有“人脸”的替代 CLI。</li><li data-pid="M-G4qge2"><a href="https://github.com/leaanthony/clir" target="_blank">clîr</a> - 一个简单明了的 CLI 库。无依赖性。</li><li data-pid="B7vE1DFz"><a href="https://github.com/posener/cmd" target="_blank">cmd</a> - 以惯用的方式扩展标准<code>flag</code>包以支持子命令等。</li><li data-pid="-73dZlAV"><a href="https://github.com/hedzr/cmdr" target="_blank">cmdr</a> - POSIX/GNU 风格，类似于 getopt 的命令行 UI Go 库。</li><li data-pid="rATMbvHM"><a href="https://github.com/spf13/cobra" target="_blank">cobra</a> - 现代 Go CLI 交互的指挥官。</li><li data-pid="emVw4iGv"><a href="https://github.com/rainu/go-command-chain" target="_blank">command-chain</a> - 用于配置和运行命令链的 go 库 - 例如 unix shell 中的流水线操作。</li><li data-pid="Pqt08B3_"><a href="https://github.com/jaffee/commandeer" target="_blank">commandeer</a> - 开发友好的 CLI 应用程序：根据结构字段和标签设置标志、默认值和用法。</li><li data-pid="TZ1L9fny"><a href="https://github.com/posener/complete" target="_blank">complete</a> - 在 Go + Go 命令 bash 完成中编写 bash 完成。</li><li data-pid="88Dqs212"><a href="https://github.com/dnote/dnote" target="_blank">Dnote</a> - 具有多设备同步功能的简单命令行笔记本。</li><li data-pid="rSS-4F1-"><a href="https://github.com/elves/elvish" target="_blank">elvish</a> - 一种富有表现力的编程语言和多功能的交互式 shell。</li><li data-pid="v3EPykJ3"><a href="https://github.com/codingconcepts/env" target="_blank">env</a> - 结构的基于标签的环境配置。</li><li data-pid="T6cLTHre"><a href="https://github.com/cosiner/flag" target="_blank">flag</a> - 用于 Go 支持子命令的简单但功能强大的命令行选项解析库。</li><li data-pid="zrqvnCLe"><a href="https://github.com/integrii/flaggy" target="_blank">flaggy</a> - 一个强大且惯用的标志包，具有出色的子命令支持。</li><li data-pid="H2s34qOH"><a href="https://github.com/sgreben/flagvar" target="_blank">flagvar</a> - Go 标准包的标志参数类型的集合<code>flag</code>。</li><li data-pid="KhTiyNND"><a href="https://github.com/grijul/go-andotp" target="_blank">go-andotp - 用于加密/解密</a><a href="https://github.com/andOTP/andOTP" target="_blank">和 OTP</a>文件的 CLI 程序。也可以用作图书馆。</li><li data-pid="SkgOEhDH"><a href="https://github.com/alexflint/go-arg" target="_blank">go-arg</a> -Go 中基于结构的参数解析。</li><li data-pid="X1Ovmkm6"><a href="https://github.com/yitsushi/go-commander" target="_blank">go-commander</a> - 用于简化 CLI 工作流程的 Go 库。</li><li data-pid="420RqUxT"><a href="https://github.com/jessevdk/go-flags" target="_blank">go-flags</a> - go 命令行选项解析器。</li><li data-pid="SVpJfUVa"><a href="https://github.com/DavidGamba/go-getoptions" target="_blank">go-getoptions</a> - 受 Perl 的 GetOpt::Long 的灵活性启发的 Go 选项解析器。</li><li data-pid="ul6MF0qA"><a href="https://github.com/devfacet/gocmd" target="_blank">gocmd</a> - 用于构建命令行应用程序的 Go 库。</li><li data-pid="2eTpbkAx"><a href="https://github.com/hidevopsio/hiboot/tree/master/pkg/app/cli" target="_blank">hiboot cli</a> - 具有自动配置和依赖注入的 cli 应用程序框架。</li><li data-pid="NYCZkdd_"><a href="https://github.com/liujianping/job" target="_blank">job</a> - JOB，让你的短期命令成为长期工作。</li><li data-pid="HPAd_IsQ"><a href="https://github.com/alecthomas/kingpin" target="_blank">kingpin</a> - 支持子命令的命令行和标志解析器（被取代<code>kong</code>；见下文）。</li><li data-pid="0jx2y6zo"><a href="https://github.com/peterh/liner" target="_blank">liner</a> - 用于命令行界面的类似于 readline 的库。</li><li data-pid="Gq8CQGl6"><a href="https://github.com/jxskiss/mcli" target="_blank">mcli</a> - 用于 Go 的最小但非常强大的 cli 库。</li><li data-pid="PJe2D2mt"><a href="https://github.com/mitchellh/cli" target="_blank">mitchellh/cli</a> - 用于实现命令行界面的 Go 库。</li><li data-pid="fvGapVqT"><a href="https://github.com/jawher/mow.cli" target="_blank">mow.cli</a> - 用于构建具有复杂标志和参数解析和验证的 CLI 应用程序的 Go 库。</li><li data-pid="Q0mKtv0U"><a href="https://github.com/nanovms/ops" target="_blank">ops</a> - Unikernel Builder/Orchestrator.</li><li data-pid="omFq79TG"><a href="https://github.com/spf13/pflag" target="_blank">pflag</a> - Go 标志包的直接替换，实现了 POSIX/GNU 风格 --flags。</li><li data-pid="57dzh4AJ"><a href="https://github.com/Zaba505/sand" target="_blank">sand</a> - 用于创建解释器等的简单 API。</li><li data-pid="tfi6Lumz"><a href="https://github.com/octago/sflags" target="_blank">sflags</a> - 用于 flag、urfave/cli、pflag、cobra、kingpin 和其他库的基于结构的标志生成器。</li><li data-pid="xVTDfYVs"><a href="https://github.com/antham/strumt" target="_blank">strumt</a> - 创建提示链的库。</li><li data-pid="sRaZGWDj"><a href="https://github.com/bobg/subcmd" target="_blank">subcmd</a> - 另一种解析和运行子命令的方法。与标准<code>flag</code>包一起工作。</li><li data-pid="vIa73IQQ"><a href="https://github.com/go-survey/survey" target="_blank">survey</a> - 构建交互式和可访问的提示，完全支持 Windows 和 posix 终端。</li><li data-pid="3mmtM9sM"><a href="https://github.com/liujianping/ts" target="_blank">ts</a> - 时间戳转换和比较工具。</li><li data-pid="RYW0dE0M"><a href="https://github.com/ukautz/clif" target="_blank">ukautz/clif</a> - 小型命令行界面框架。</li><li data-pid="vcDwaMun"><a href="https://github.com/urfave/cli" target="_blank">urfave/cli</a> - 用于在 Go 中构建命令行应用程序的简单、快速且有趣的包（以前称为 codegangsta/cli）。</li><li data-pid="a0Z323Am"><a href="https://github.com/mszostok/version" target="_blank">version</a> - 以多种格式收集和显示 CLI 版本信息以及升级通知。</li><li data-pid="bGmgkZ1q"><a href="https://github.com/dixonwille/wlog" target="_blank">wlog</a> - 支持跨平台颜色和并发的简单日志记录界面。</li><li data-pid="n4jMnfZv"><a href="https://github.com/dixonwille/wmenu" target="_blank">wmenu</a> - 提示用户做出选择的 cli 应用程序易于使用的菜单结构。</li></ul><p data-pid="LCKS-sHL"><b><a href="https://github.com/avelino/awesome-go/blob/main/README.md#contents" target="_blank">⬆回到顶部</a></b></p><h2><b>配置</b></h2><p data-pid="FQyGdqKO"><i>用于配置解析的库。</i></p><ul><li data-pid="4Z6Iy80f"><a href="https://github.com/cristalhq/aconfig" target="_blank">aconfig</a> - 简单、有用且自以为是的配置加载器。</li><li data-pid="mmKCObEZ"><a href="https://github.com/ilyakaznacheev/cleanenv" target="_blank">cleanenv</a> - 简约的配置阅读器（来自文件、ENV 以及任何你想要的地方）。</li><li data-pid="djz2WJcP"><a href="https://github.com/JeremyLoy/config" target="_blank">config</a> - 云原生应用程序配置。只需两行即可将 ENV 绑定到结构。</li><li data-pid="bk3osFya"><a href="https://github.com/num30/config" target="_blank">配置</a>- 在两行代码中使用文件、环境变量或标志配置您的应用程序</li><li data-pid="-YgBvvYP"><a href="https://github.com/olebedev/config" target="_blank">config</a> - 具有环境变量和标志解析的 JSON 或 YAML 配置包装器。</li><li data-pid="Rh2YGtlB"><a href="https://github.com/BoRuDar/configuration" target="_blank">configuration</a> - 用于从 env 变量、文件、标志和“默认”标签初始化配置结构的库。</li><li data-pid="i_yY2aaF"><a href="https://github.com/paked/configure" target="_blank">configure</a> - 通过多个来源提供配置，包括 JSON、标志和环境变量。</li><li data-pid="YK13JYGW"><a href="https://github.com/sherifabdlnaby/configuro" target="_blank">configuro</a> - 来自 ENV 和 Files 的自以为是的配置加载和验证框架，专注于 12-Factor 兼容应用程序。</li><li data-pid="mdmmsIJs"><a href="https://github.com/heetch/confita" target="_blank">confita</a> - 将配置从多个后端级联加载到一个结构中。</li><li data-pid="zy-5NYjg"><a href="https://github.com/the4thamigo-uk/conflate" target="_blank">conflate</a> - 用于合并来自任意 URL 的多个 JSON/YAML/TOML 文件的库/工具，针对 JSON 模式进行验证，以及模式中定义的默认值的应用。</li><li data-pid="CBbreAso"><a href="https://github.com/caarlos0/env" target="_blank">env</a> - 将环境变量解析为 Go 结构（具有默认值）。</li><li data-pid="PAaT7D2H"><a href="https://github.com/junk1tm/env" target="_blank">env</a> - 用于将环境变量加载到结构中的轻量级包。</li><li data-pid="5-LeS8Th"><a href="https://github.com/tomazk/envcfg" target="_blank">envcfg</a> - 将环境变量取消编组到 Go 结构。</li><li data-pid="-MpVZumV"><a href="https://github.com/ian-kent/envconf" target="_blank">envconf</a> - 来自环境的配置。</li><li data-pid="Z3eJKfYy"><a href="https://github.com/vrischmann/envconfig" target="_blank">envconfig</a> - 从环境变量中读取您的配置。</li><li data-pid="G4lSADUB"><a href="https://github.com/antham/envh" target="_blank">envh</a> - 管理环境变量的助手。</li><li data-pid="1C2ilHbA"><a href="https://github.com/kkyr/fig" target="_blank">fig</a> - 用于从文件和环境变量（具有验证和默认值）读取配置的微型库。</li><li data-pid="qIuueOOi"><a href="https://github.com/go-gcfg/gcfg" target="_blank">gcfg</a> - 将 INI 风格的配置文件读入 Go 结构；支持用户定义的类型和子部分。</li><li data-pid="kF-GjakL"><a href="https://github.com/sakirsensoy/genv" target="_blank">genv</a> - 使用 dotenv 支持轻松读取环境变量.</li><li data-pid="3H2JeObw"><a href="https://github.com/PaddleHQ/go-aws-ssm" target="_blank">go-aws-ssm</a> - 从 AWS System Manager - Parameter Store 获取参数的 Go 包。</li><li data-pid="evyoGSb5"><a href="https://github.com/ThomasObenaus/go-conf" target="_blank">go-conf</a> - 基于注释结构的应用程序配置的简单库。它支持从环境变量、配置文件和命令行参数中读取配置。</li><li data-pid="QKlxrz9h"><a href="https://github.com/subpop/go-ini" target="_blank">go-ini</a> - 编组和解组 INI 文件的 Go 包。</li><li data-pid="CIxj3xSI"><a href="https://github.com/ianlopshire/go-ssm-config" target="_blank">go-ssm-config</a> - 用于从 AWS SSM（参数存储）加载配置参数的 Go 实用程序。</li><li data-pid="uuowCk77"><a href="https://github.com/ufoscout/go-up" target="_blank">go-up</a> - 一个简单的配置库，具有递归占位符解析且没有魔法。</li><li data-pid="bCRLh8ki"><a href="https://github.com/crgimenes/goConfig" target="_blank">goConfig</a> - 将结构解析为输入，并使用来自命令行、环境变量和配置文件的参数填充该结构的字段。</li><li data-pid="9KQfv69n"><a href="https://github.com/joho/godotenv" target="_blank">godotenv</a> -Ruby 的 dotenv 库的 Go 端口（从加载环境变量<code>.env</code>）。</li><li data-pid="NGd99Dyk"><a href="https://github.com/ian-kent/gofigure" target="_blank">gofigure</a> -Go 应用程序配置变得简单。</li><li data-pid="r0BQJNQr"><a href="https://github.com/golobby/config" target="_blank">GoLobby/Config</a> -GoLobby Config 是 Go 编程语言的轻量级但功能强大的配置管理器.</li><li data-pid="lQteZ50z"><a href="https://github.com/One-com/gone/tree/master/jconf" target="_blank">gone/jconf</a> - 模块化 JSON 配置。让您配置结构及其配置的代码，并将解析委托给子模块，而不会牺牲完整的配置序列化。</li><li data-pid="3zgF_jBU"><a href="https://github.com/milad-abbasi/gonfig" target="_blank">gonfig</a> - 基于标签的配置解析器，它将来自不同提供程序的值加载到类型安全结构中。</li><li data-pid="GL8WaZif"><a href="https://github.com/gookit/config" target="_blank">gookit/config</a> - 应用程序配置管理（加载、获取、设置）。支持 JSON、YAML、TOML、INI、HCL。多文件加载，数据覆盖合并。</li><li data-pid="PVJmYuLV"><a href="https://github.com/beatlabs/harvester" target="_blank">harvester</a> - Harvester，一个易于使用的静态和动态配置包，支持播种、env vars 和 Consul 集成。</li><li data-pid="hzgF1f6w"><a href="https://github.com/hjson/hjson-go" target="_blank">hjson</a> - 人类 JSON，人类的配置文件格式。宽松的语法，更少的错误，更多的评论。</li><li data-pid="1-HizlI1"><a href="https://github.com/gurkankaymak/hocon" target="_blank">hocon</a> - 用于使用 HOCON（一种人性化的 JSON 超集）格式的配置库，支持环境变量、引用其他值、注释和多个文件等功能。</li><li data-pid="hMeGoeBb"><a href="https://github.com/schachmat/ingo" target="_blank">ingo</a> - 标志保存在类似 ini 的配置文件中。</li><li data-pid="1JCZUXWB"><a href="https://github.com/go-ini/ini" target="_blank">ini</a> - 用于读取和写入 INI 文件的 Go 包。</li><li data-pid="3wGokei4"><a href="https://github.com/wlevene/ini" target="_blank">ini</a> - INI 解析器和写入库，解组到结构，编组到 Json，写入文件，监视文件。</li><li data-pid="Z2ZO4Bh_"><a href="https://github.com/joshbetz/config" target="_blank">joshbetz/config</a> -Go 的小型配置库，可解析环境变量、JSON 文件并在 SIGHUP 上自动重新加载。</li><li data-pid="RwmwwVOf"><a href="https://github.com/kelseyhightower/envconfig" target="_blank">kelseyhightower/envconfig</a> - 用于管理来自环境变量的配置数据的 Go 库。</li><li data-pid="KtKokNsv"><a href="https://github.com/knadh/koanf" target="_blank">koanf</a> - 轻量级、可扩展的库，用于读取 Go 应用程序中的配置。内置对 JSON、TOML、YAML、env、命令行的支持。</li><li data-pid="B0zoVDhH"><a href="https://github.com/lalamove/konfig" target="_blank">konfig</a> - 适用于分布式处理时代的 Go 的可组合、可观察和高性能配置处理。</li><li data-pid="LaHTq2ws"><a href="https://github.com/alecthomas/kong" target="_blank">kong</a> - 命令行解析器，支持任意复杂的命令行结构和其他配置源，例如 YAML、JSON、TOML 等（继任者<code>kingpin</code>）。</li><li data-pid="Zzlh-Sjt"><a href="https://github.com/sasbury/mini" target="_blank">mini</a> - 用于解析 ini 样式配置文件的 Golang 包。</li><li data-pid="kqj10ihN"><a href="https://github.com/nasermirzaei89/env" target="_blank">nasermirzaei89/env</a> - 用于读取环境变量的简单有用的包。</li><li data-pid="oAEDaMzD"><a href="https://github.com/muir/nfigure" target="_blank">nfigure</a> - 来自命令行的基于每个库结构标签的配置（Posix 和 Go 风格）；环境、JSON、YAML</li><li data-pid="pM9j1ULx"><a href="https://github.com/goraz/onion" target="_blank">onion</a> -Go 的基于层的配置，支持 JSON、TOML、YAML、属性、etcd、env 和使用 PGP 的加密。</li><li data-pid="pOVa5qcg"><a href="https://github.com/Yiling-J/piper" target="_blank">piper</a> - 具有配置继承和密钥生成的 Viper 包装器.</li><li data-pid="v6_N_DhJ"><a href="https://github.com/tucnak/store" target="_blank">store</a> -Go 的轻量级配置管理器。</li><li data-pid="h_C1yyc0"><a href="https://github.com/oblq/swap" target="_blank">swap</a> - 根据构建环境递归地实例化/配置结构。（YAML、TOML、JSON 和环境）。</li><li data-pid="QYUtT-51"><a href="https://github.com/diegomarangoni/typenv" target="_blank">typenv</a> - 简约、零依赖、类型化环境变量库。</li><li data-pid="Xx9-zRIM"><a href="https://github.com/omeid/uconfig" target="_blank">uConfig</a> - 轻量级、零依赖和可扩展的配置管理。</li><li data-pid="aM-NnXas"><a href="https://github.com/spf13/viper" target="_blank">viper</a> - 带有毒牙的 Go 配置。</li><li data-pid="t-6GFyxg"><a href="https://github.com/adrg/xdg" target="_blank">xdg</a> -Go 实现<a href="https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html" target="_blank">XDG 基本目录规范</a>和<a href="https://wiki.archlinux.org/index.php/XDG_user_directories" target="_blank">XDG 用户目录</a>。</li><li data-pid="iT0cbeS5"><a href="https://github.com/OpenPeeDeeP/xdg" target="_blank">xdg</a> - 遵循<a href="https://standards.freedesktop.org/basedir-spec/basedir-spec-latest.html" target="_blank">XDG 标准的</a>跨平台包。</li></ul><p data-pid="DCvBnICE"><b><a href="https://github.com/avelino/awesome-go/blob/main/README.md#contents" target="_blank">⬆回到顶部</a></b></p><h2><b>持续集成</b></h2><p data-pid="LW5RtRfj"><i>帮助持续集成的工具。</i></p><ul><li data-pid="seeWtkYv"><a href="https://github.com/ovh/cds" target="_blank">CDS</a> - 企业级 CI/CD 和 DevOps 自动化开源平台。</li><li data-pid="6ukSy5aK"><a href="https://github.com/drone/drone" target="_blank">drone</a> -Drone 是一个建立在 Docker 上的持续集成平台，用 Go 编写。</li><li data-pid="hePXTjcG"><a href="https://github.com/duck8823/duci" target="_blank">duci</a> - 一个简单的 ci 服务器，不需要特定领域的语言。</li><li data-pid="SuK9Fi9N"><a href="https://github.com/jidicula/go-fuzz-action" target="_blank">go-fuzz-action</a> - 在 GitHub Actions 中使用 Go 1.18 的内置模糊测试。</li><li data-pid="fJIE-7VD"><a href="https://github.com/vladopajic/go-test-coverage" target="_blank">go-test-coverage</a> - 当测试覆盖率低于设定阈值时报告问题的工具和 GitHub 操作。</li><li data-pid="d6tK7mLS"><a href="https://github.com/nikogura/gomason" target="_blank">gomason</a> - 从干净的工作区测试、构建、签名和发布您的 go 二进制文件。</li><li data-pid="l_-ZBTcQ"><a href="https://github.com/GoTestTools/gotestfmt" target="_blank">gotestfmt</a> - 去测试人类的输出。</li><li data-pid="UIThgXGk"><a href="https://github.com/mattn/goveralls" target="_blank">goveralls</a> - 集成 Coveralls.io 连续代码覆盖率跟踪系统。</li><li data-pid="QIc7-Ldh"><a href="https://github.com/go-playground/overalls" target="_blank">overalls</a> - Multi-Package go project coverprofile 用于像 goveralls 这样的工具。</li><li data-pid="mzIa2oCO"><a href="https://github.com/LawrenceWoodman/roveralls" target="_blank">roveralls</a> - 递归覆盖测试工具。</li><li data-pid="_LMwNhhh"><a href="https://github.com/woodpecker-ci/woodpecker" target="_blank">woodpecker</a> -Woodpecker 是 Drone CI 系统的社区分支。</li></ul><p data-pid="AXoud4bC"><b><a href="https://github.com/avelino/awesome-go/blob/main/README.md#contents" target="_blank">⬆回到顶部</a></b></p><h2><b>CSS 预处理器</b></h2><p data-pid="S7iUywec"><i>用于预处理 CSS 文件的库。</i></p><ul><li data-pid="qhbqbFRa"><a href="https://github.com/yosssi/gcss" target="_blank">gcss</a> - 纯 Go CSS 预处理器。</li><li data-pid="ZZ_jc6L6"><a href="https://github.com/wellington/go-libsass" target="_blank">go-libsass</a> - 包装到 100% Sass 兼容的 libsass 项目。</li></ul><p data-pid="pGk2g1Z6"><b><a href="https://github.com/avelino/awesome-go/blob/main/README.md#contents" target="_blank">⬆回到顶部</a></b></p><h2><b>数据结构和算法</b></h2><h3><b>位打包和压缩</b></h3><ul><li data-pid="LmkmZLCi"><a href="https://github.com/iancmcc/bingo" target="_blank">bingo</a> - 将本机类型快速、零分配、保留词典顺序的包装打包为字节。</li><li data-pid="njgGTk5B"><a href="https://github.com/zhuangsirui/binpacker" target="_blank">binpacker</a> - 二进制打包器和解包器帮助用户构建自定义二进制流。</li><li data-pid="3XMB7duO"><a href="https://github.com/yourbasic/bit" target="_blank">bit</a> -Golang 设置数据结构，具有额外的位旋转功能。</li><li data-pid="7Fl5DcGh"><a href="https://github.com/superwhiskers/crunch" target="_blank">crunch</a> -Go 包实现缓冲区以轻松处理各种数据类型。</li><li data-pid="hVtLEfMM"><a href="https://github.com/amallia/go-ef" target="_blank">go-ef</a> - Elias-Fano 编码的 Go 实现。</li><li data-pid="hpL2nU9f"><a href="https://github.com/RoaringBitmap/roaring" target="_blank">roaring</a> - 实现压缩位集的 Go 包。</li></ul><h3><b>位集</b></h3><ul><li data-pid="40NWh4jm"><a href="https://github.com/kelindar/bitmap" target="_blank">bitmap</a> -Go 中密集的、零分配的、支持 SIMD 的位图/位集。</li><li data-pid="Xin4FnQs"><a href="https://github.com/bits-and-blooms/bitset" target="_blank">bitset</a> -Go 包实现 bitsets。</li></ul><h3><b>布隆和布谷鸟过滤器</b></h3><ul><li data-pid="jpVOeQqH"><a href="https://github.com/bits-and-blooms/bloom" target="_blank">bloom</a> - 实现 Bloom 过滤器的 Go 包。</li><li data-pid="4_iU1i3A"><a href="https://github.com/zhenjl/bloom" target="_blank">bloom</a> - 在 Go 中实现的 Bloom 过滤器.</li><li data-pid="dkCK0gQ2"><a href="https://github.com/yourbasic/bloom" target="_blank">bloom</a> -Golang 布隆过滤器实现。</li><li data-pid="whH_3_tY"><a href="https://github.com/OldPanda/bloomfilter" target="_blank">bloomfilter</a> -Go 中的另一个 Bloomfilter 实现，与 Java 的 Guava 库兼容。</li><li data-pid="92ofKrk6"><a href="https://github.com/tylertreat/BoomFilters" target="_blank">boomfilters</a> - 用于处理连续、无界流的概率数据结构。</li><li data-pid="alWlggFy"><a href="https://github.com/linvon/cuckoo-filter" target="_blank">cuckoo-filter</a> - 布谷鸟过滤器：一个综合的布谷鸟过滤器，与其他工具相比，它是可配置的和空间优化的，并且提供了原始论文中提到的所有功能。</li><li data-pid="YgXAR44n"><a href="https://github.com/seiflotfy/cuckoofilter" target="_blank">cuckoofilter</a> - 布谷鸟过滤器：在 Go 中实现的计数布隆过滤器的一个很好的替代品。</li><li data-pid="sLEJGYhj"><a href="https://github.com/TheTannerRyan/ring" target="_blank">ring</a> - 执行高性能、线程安全的布隆过滤器。</li></ul><h3><b>数据结构和算法集合</b></h3><ul><li data-pid="DBMRAube"><a href="https://github.com/shady831213/algorithms" target="_blank">algorithms</a> - 算法和数据结构。CLRS 研究。</li><li data-pid="tFDc270X"><a href="https://github.com/Workiva/go-datastructures" target="_blank">go-datastructures</a> - 有用的、高性能的和线程安全的数据结构的集合。</li><li data-pid="ZFm0Azx0"><a href="https://github.com/emirpasic/gods" target="_blank">gods</a> - 围棋数据结构。容器、集合、列表、堆栈、地图、BidiMaps、树、HashSet 等。</li><li data-pid="y7yT5ic4"><a href="https://github.com/liyue201/gostl" target="_blank">gostl</a> - go 的数据结构和算法库，旨在提供类似于 C++ STL 的功能。</li></ul><h3><b>迭代器</b></h3><ul><li data-pid="UMo-ZrVQ"><a href="https://github.com/yaa110/goterator" target="_blank">goterator</a> - 提供 map 和 reduce 功能的迭代器实现。</li><li data-pid="zTCmPsMw"><a href="https://github.com/disksing/iter" target="_blank">iter</a> - C++ STL 迭代器和算法的 Go 实现。</li></ul><h3><b>地图</b></h3><p data-pid="ZmhtnocI">另请参阅<a href="https://github.com/avelino/awesome-go/blob/main/README.md#database" target="_blank">数据库</a>了解更复杂的键值存储，以及<a href="https://github.com/avelino/awesome-go/blob/main/README.md#trees" target="_blank">树</a>了解其他有序映射实现。</p><ul><li data-pid="lGZqJNBI"><a href="https://github.com/lrita/cmap" target="_blank">cmap</a> - 用于 go 的线程安全并发映射，支持用作<code>interface{}</code>键和自动扩展分片。</li><li data-pid="DQAtBCg8"><a href="https://github.com/srfrog/dict" target="_blank">dict</a> -Go 的类似 Python 的字典（dict）。</li><li data-pid="Mb9VV7kf"><a href="https://github.com/goradd/maps" target="_blank">goradd/maps</a> - 用于地图的 Go 1.18+ 通用地图界面；安全地图；有序地图；有序、安全的地图；ETC。</li></ul><h3><b>杂项数据结构和算法</b></h3><ul><li data-pid="Y1tXLZAn"><a href="https://github.com/free/concurrent-writer" target="_blank">concurrent-writer</a> - 高度并发的<code>bufio.Writer</code>.</li><li data-pid="OEU1qbn8"><a href="https://github.com/InVisionApp/conjungo" target="_blank">conjungo</a> - 一个小巧、强大且灵活的合并库。</li><li data-pid="YH2HHoLz"><a href="https://github.com/seiflotfy/count-min-log" target="_blank">count-min-log</a> - Go 实现 Count-Min-Log 草图：使用近似计数器进行近似计数（类似于 Count-Min 草图，但使用更少的内存）。</li><li data-pid="5QT85j14"><a href="https://github.com/cocoonspace/fsm" target="_blank">fsm</a> - 有限状态机包。</li><li data-pid="ImhNEC6G"><a href="https://github.com/nwillc/genfuncs" target="_blank">genfuncs</a> - 受 Kotlin 的 Sequence 和 Map 启发的 Go 1.18+ 泛型包.</li><li data-pid="fclHjWCX"><a href="https://github.com/bobg/go-generics" target="_blank">go-generics</a> - 通用切片、映射、集合、迭代器和 goroutine 实用程序。</li><li data-pid="la5wvbD7"><a href="https://github.com/hailocab/go-geoindex" target="_blank">go-geoindex</a> - 内存中地理索引。</li><li data-pid="C6QFTjXb"><a href="https://github.com/francesconi/go-rampart" target="_blank">go-rampart</a> - 确定间隔如何相互关联。</li><li data-pid="eyk3sn0A"><a href="https://github.com/aurelien-rainone/go-rquad" target="_blank">go-rquad</a> - 具有高效点定位和邻居查找的区域四叉树。</li><li data-pid="A18jcr0C"><a href="https://github.com/barweiss/go-tuple" target="_blank">go-tuple</a> -Go 1.18+ 的通用元组实现。</li><li data-pid="Qi_W9n9t"><a href="https://github.com/daichi-m/go18ds" target="_blank">go18ds</a> - 使用 Go 1.18 泛型的 Go 数据结构。</li><li data-pid="0vxd7EdW"><a href="https://github.com/xxjwxc/gofal" target="_blank">gofal</a> -Go 的小数 api。</li><li data-pid="yqCiqF9M"><a href="https://github.com/esimov/gogu" target="_blank">gogu</a> - 一个全面、可重用和高效的并发安全泛型实用函数和数据结构库。</li><li data-pid="yKjDCb5A"><a href="https://github.com/kniren/gota" target="_blank">gota</a> - 为 Go 实现数据帧、系列和数据整理方法。</li><li data-pid="O-8ELai7"><a href="https://github.com/emvi/hide" target="_blank">隐藏</a>- ID 类型与编组到/从散列以防止向客户端发送 ID。</li><li data-pid="KTMMBtTa"><a href="https://github.com/google/hilbert" target="_blank">hilbert</a> - 用于将值映射到空间填充曲线（例如 Hilbert 和 Peano 曲线）和从空间填充曲线映射值的 Go 包。</li><li data-pid="3Xkfb4zD"><a href="https://github.com/axiomhq/hyperloglog" target="_blank">hyperloglog</a> - 具有稀疏、LogLog-Beta 偏差校正和 TailCut 空间减少的 HyperLogLog 实现。</li><li data-pid="j5VO4hub"><a href="https://github.com/s0rg/quadtree" target="_blank">四叉树</a>- 通用、零分配、100% 测试覆盖的四叉树。</li><li data-pid="U6DbSL0y"><a href="https://github.com/srfrog/slices" target="_blank">切片</a>- 对切片进行操作的函数；喜欢<code>package strings</code>但适用于切片。</li><li data-pid="m4g2bGqM"><a href="https://github.com/twharmon/slices" target="_blank">slices</a> - 切片的纯通用函数。</li></ul><h3><b>可空类型</b></h3><ul><li data-pid="agjzFvz8"><a href="https://github.com/kak-tus/nan" target="_blank">nan</a> - 一个库中的零分配可空结构，具有方便的转换函数、编组器和解组器。</li><li data-pid="p8bgNpnz"><a href="https://github.com/emvi/null" target="_blank">null</a> - 可以为 JSON 编组/解组的可空 Go 类型。</li><li data-pid="sf938z1S"><a href="https://github.com/gurukami/typ" target="_blank">typ</a> - 空类型、安全原始类型转换和从复杂结构中获取值。</li></ul><h3><b>队列</b></h3><ul><li data-pid="oobiwhe0"><a href="https://github.com/edwingeng/deque" target="_blank">deque</a> - 高度优化的双端队列。</li><li data-pid="CcgY4nrY"><a href="https://github.com/gammazero/deque" target="_blank">deque</a> - 快速环形缓冲区双端队列（双端队列）。</li><li data-pid="Riy6dHTo"><a href="https://github.com/enriquebris/goconcurrentqueue" target="_blank">goconcurrentqueue</a> - 并发 FIFO 队列。</li><li data-pid="tvkGtof3"><a href="https://github.com/embano1/memlog" target="_blank">memlog</a> - 受 Apache Kafka 启发的易于使用、轻量级、线程安全且仅附加的内存数据结构。</li><li data-pid="-hg28Ez5"><a href="https://github.com/adrianbrad/queue" target="_blank">queue</a> -Go 的多线程安全、通用队列实现。</li></ul><h3><b>套</b></h3><ul><li data-pid="29ubEw9o"><a href="https://github.com/ihebu/dsu" target="_blank">dsu</a> -Go 中的不相交集数据结构实现。</li><li data-pid="bulrYd4X"><a href="https://github.com/deckarep/golang-set" target="_blank">golang-set</a> -Go 的线程安全和非线程安全高性能集。</li><li data-pid="Fdw0uDOn"><a href="https://github.com/zoumo/goset" target="_blank">goset</a> - 一个有用的 Go 集合集合实现。</li><li data-pid="EvsryRND"><a href="https://github.com/StudioSol/set" target="_blank">set</a> - 使用 LinkedHashMap 在 Go 中实现简单的集合数据结构。</li></ul><h3><b>文本分析</b></h3><ul><li data-pid="4SZz0Oih"><a href="https://github.com/blevesearch/bleve" target="_blank">bleve</a> - 用于 go 的现代文本索引库。</li><li data-pid="NEgJyS2s"><a href="https://github.com/plar/go-adaptive-radix-tree" target="_blank">go-adaptive-radix-tree</a> - 自适应基数树的 Go 实现。</li><li data-pid="sGKMnt52"><a href="https://github.com/hbollon/go-edlib" target="_blank">go-edlib</a> - 与 Unicode 兼容的 Go 字符串比较和编辑距离算法库（Levenshtein、LCS、Hamming、Damerau levenshtein、Jaro-Winkler 等）。</li><li data-pid="MH-N6nXz"><a href="https://github.com/agext/levenshtein" target="_blank">levenshtein</a> - Levenshtein 距离和相似性度量，具有可自定义的编辑成本和类似 Winkler 的公共前缀奖励.</li><li data-pid="4bTVOkc4"><a href="https://github.com/agnivade/levenshtein" target="_blank">levenshtein</a> - 在 Go 中计算 levenshtein 距离的实现。</li><li data-pid="-NpiGdAL"><a href="https://github.com/BlackRabbitt/mspm" target="_blank">mspm</a> - 用于信息检索的多字符串模式匹配算法。</li><li data-pid="bk9aGH1Y"><a href="https://github.com/MonaxGT/parsefields" target="_blank">parsefields</a> - 用于解析类似 JSON 的日志以收集唯一字段和事件的工具。</li><li data-pid="CA9Tr2X8"><a href="https://github.com/viant/ptrie" target="_blank">ptrie</a> - 前缀树的实现。</li><li data-pid="JuQlYMRJ"><a href="https://github.com/derekparker/trie" target="_blank">trie</a> -Go 中的 Trie 实现。</li></ul><h3><b>树木</b></h3><ul><li data-pid="4wFg2wd2"><a href="http://github.com/bobg/hashsplit" target="_blank">hashsplit</a> - 将字节流拆分成块，并将块排列成树，边界由内容决定，而不是位置。</li><li data-pid="cjiSNc_x"><a href="https://github.com/bobg/merkle" target="_blank">merkle</a> - Merkle 根哈希和包含证明的空间高效计算.</li><li data-pid="mdz6zUaD"><a href="https://github.com/MauriceGit/skiplist" target="_blank">skiplist</a> - 非常快速的 Go Skiplist 实现。</li><li data-pid="5wdPZrNr"><a href="https://github.com/gansidui/skiplist" target="_blank">skiplist</a> -Go 中的 Skiplist 实现。</li><li data-pid="Uksg6g9c"><a href="https://github.com/perdata/treap" target="_blank">treap</a> - 使用树堆的持久、快速有序的地图。</li><li data-pid="W2Zcgaea"><a href="https://github.com/igrmk/treemap" target="_blank">treemap</a> - 使用引擎盖下的红黑树的通用键排序映射。</li></ul><h3><b>管道</b></h3><ul><li data-pid="BrwleDaU"><a href="https://github.com/tejzpr/ordered-concurrently" target="_blank">ordered-concurrently</a> - 并发处理工作并按输入顺序在通道中返回输出的 Go 模块。</li><li data-pid="BACbpnNj"><a href="https://github.com/nazar256/parapipe" target="_blank">parapipe</a> - FIFO 管道，它在每个阶段并行执行，同时保持消息和结果的顺序。</li><li data-pid="IMlshMrg"><a href="https://github.com/hyfather/pipeline" target="_blank">pipeline</a> - 具有扇入和扇出的管道的实现。</li></ul><p data-pid="VZYKZZL2"><b><a href="https://github.com/avelino/awesome-go/blob/main/README.md#contents" target="_blank">⬆回到顶部</a></b></p><h2><b>数据库</b></h2><h3><b>缓存</b></h3><p data-pid="r7RAM9pT"><i>具有过期记录的数据存储、内存分布式数据存储或基于文件的数据库的内存子集。</i></p><ul><li data-pid="vxgeMZMb"><a href="https://github.com/floatdrop/2q" target="_blank">2q</a> - 2Q 内存缓存实现。</li><li data-pid="SPNMxvUu"><a href="https://github.com/iwanbk/bcache" target="_blank">bcache</a> - 最终一致的分布式内存缓存 Go 库。</li><li data-pid="yeH6D166"><a href="https://github.com/allegro/bigcache" target="_blank">BigCache</a> - 千兆字节数据的高效键/值缓存。</li><li data-pid="jR4RGGE-"><a href="https://github.com/akyoto/cache" target="_blank">cache</a> - 内存中的键：具有过期时间的值存储，0 依赖性，&lt;100 LoC，100% 覆盖率。</li><li data-pid="TxfJexim"><a href="https://github.com/muesli/cache2go" target="_blank">cache2go</a> - 内存中的键：值缓存，支持基于超时的自动失效。</li><li data-pid="kZwYLbkh"><a href="https://github.com/faabiosr/cachego" target="_blank">cachego</a> - 用于多个驱动程序的 Golang 缓存组件。</li><li data-pid="uSU1vfLs"><a href="https://github.com/oaStuff/clusteredBigCache" target="_blank">clusteredBigCache</a> - 具有集群支持和单个项目过期的 BigCache。</li><li data-pid="P2dKmt3d"><a href="https://github.com/codingsince1985/couchcache" target="_blank">couchcache</a> - 由 Couchbase 服务器支持的 RESTful 缓存微服务。</li><li data-pid="LB1H1CqE"><a href="https://github.com/VictoriaMetrics/fastcache" target="_blank">fastcache</a> - 用于大量条目的快速线程安全内存缓存。最小化 GC 开销。</li><li data-pid="IZAzOPKY"><a href="https://github.com/bluele/gcache" target="_blank">GCache</a> - 支持过期缓存、LFU、LRU 和 ARC 的缓存库。</li><li data-pid="K66cD1vG"><a href="https://github.com/ulovecode/gdcache" target="_blank">gdcache</a> - 一个由 golang 实现的纯非侵入式缓存库，你可以用它来实现你自己的分布式缓存。</li><li data-pid="WRsrg0DD"><a href="https://github.com/viney-shih/go-cache" target="_blank">go-cache</a> - 一个灵活的多层 Go 缓存库，通过采用 Cache-Aside 模式处理内存和共享缓存。</li><li data-pid="TZszBnOB"><a href="https://github.com/OrlovEvgeny/go-mcache" target="_blank">go-mcache</a> - 快速内存中键：值存储/缓存库。指针缓存。</li><li data-pid="mB98lFSl"><a href="https://github.com/eko/gocache" target="_blank">gocache</a> - 一个完整的 Go 缓存库，具有多个存储（内存、内存缓存、redis 等）、可链接、可加载、指标缓存等。</li><li data-pid="YxC4aKAK"><a href="https://github.com/golang/groupcache" target="_blank">groupcache</a> - Groupcache 是一个缓存和缓存填充库，在许多情况下旨在替代 memcached。</li><li data-pid="WF6YUc0A"><a href="https://github.com/erni27/imcache" target="_blank">imcache</a> - 一个通用的内存缓存 Go 库。它支持过期、滑动过期、最大条目限制、驱逐回调和分片。</li><li data-pid="v5pUBk6K"><a href="https://github.com/no-src/nscache" target="_blank">nscache</a> - 一个支持多数据源驱动的 Go 缓存框架。</li><li data-pid="58eWJE0P"><a href="https://github.com/rocketlaunchr/remember-go" target="_blank">remember-go</a> - 用于缓存慢速数据库查询的通用接口（由 redis、memcached、ristretto 或内存中支持）。</li><li data-pid="CLN6wyFH"><a href="https://github.com/Yiling-J/theine-go" target="_blank">theine</a> - 高性能，接近最佳的内存缓存，具有主动 TTL 到期和泛型。</li><li data-pid="1wuNIPMp"><a href="https://github.com/zekroTJA/timedmap" target="_blank">timedmap</a> - 具有过期键值对的映射。</li><li data-pid="PqbmLjib"><a href="https://github.com/jellydator/ttlcache" target="_blank">ttlcache</a> - 具有项目过期和泛型的内存缓存。</li><li data-pid="K-1jHOYo"><a href="https://github.com/cheshir/ttlcache" target="_blank">ttlcache</a> - 内存中的键值存储，每条记录都有 TTL。</li></ul><h3><b>Go 中实现的数据库</b></h3><ul><li data-pid="8dquD7QC"><a href="https://github.com/dgraph-io/badger" target="_blank">badger</a> -Go 中的快速键值存储。</li><li data-pid="0-3AtpUp"><a href="https://github.com/etcd-io/bbolt" target="_blank">bbolt</a> - Go 的嵌入式键/值数据库。</li><li data-pid="wMXJ-yCR"><a href="https://git.mills.io/prologic/bitcask" target="_blank">Bitcask</a> - Bitcask 是一种可嵌入、持久且快速的键值 (KV) 数据库，采用纯 Go 语言编写，具有可预测的读/写性能、低延迟和高吞吐量，这要归功于 bitcask 磁盘布局 (LSM+WAL)。</li><li data-pid="_9k3ODt-"><a href="https://github.com/tidwall/buntdb" target="_blank">buntdb</a> - 用于 Go 的快速、可嵌入、内存中键/值数据库，具有自定义索引和空间支持。</li><li data-pid="1FDGd1Fc"><a href="https://github.com/ostafen/clover" target="_blank">三叶草</a>- 用纯 Golang 编写的轻量级面向文档的 NoSQL 数据库。</li><li data-pid="1TUnUd7H"><a href="https://github.com/cockroachdb/cockroach" target="_blank">cockroach</a> - 可扩展、地理复制、事务性数据存储。</li><li data-pid="kiJyf17N"><a href="https://github.com/claygod/coffer" target="_blank">Coffer</a> - 支持事务的简单 ACID 键值数据库。</li><li data-pid="8Q2SZl7z"><a href="https://github.com/kelindar/column" target="_blank">column</a> - 具有位图索引和事务的高性能、柱状、可嵌入的内存存储。</li><li data-pid="DoQS1oVs"><a href="https://github.com/CovenantSQL/CovenantSQL" target="_blank">CovenantSQL</a> - CovenantSQL 是区块链上的 SQL 数据库。</li><li data-pid="lck9jPuj"><a href="https://github.com/paranoidguy/databunker" target="_blank">Databunker</a> - 为遵守 GDPR 和 CCPA 而构建的个人身份信息 (PII) 存储服务。</li><li data-pid="1QXfxL4S"><a href="https://github.com/dgraph-io/dgraph" target="_blank">dgraph</a> - 可扩展、分布式、低延迟、高吞吐量图形数据库。</li><li data-pid="8VspfbQJ"><a href="https://github.com/peterbourgon/diskv" target="_blank">diskv</a> - 本地磁盘支持的键值存储。</li><li data-pid="LR3ir_UK"><a href="https://github.com/dolthub/dolt" target="_blank">dolt</a> - Dolt – 它是用于数据的 Git.</li><li data-pid="y8qNdi0n"><a href="https://github.com/dtm-labs/dtf" target="_blank">dtf</a> - 分布式事务管理器。支持 XA、TCC、SAGA、可靠消息。</li><li data-pid="_KqtHSpJ"><a href="https://github.com/krotik/eliasdb" target="_blank">eliasdb</a> - 具有 REST API、短语搜索和类似 SQL 查询语言的无依赖性事务图形数据库。</li><li data-pid="lvWtJWFr"><a href="https://github.com/hdt3213/godis" target="_blank">godis</a> - Golang 实现的高性能 Redis 服务器和集群。</li><li data-pid="WZDlrz_q"><a href="https://github.com/syndtr/goleveldb" target="_blank">goleveldb</a> - 在 Go 中实现<a href="https://github.com/google/leveldb" target="_blank">LevelDB</a>键/值数据库。</li><li data-pid="XUNupG3O"><a href="https://github.com/jameycribbs/hare" target="_blank">hare</a> - 一个简单的数据库管理系统，将每个表存储为以行分隔的 JSON 文本文件。</li><li data-pid="cJ-nFyCg"><a href="https://github.com/codenotary/immudb" target="_blank">immudb</a> - immudb 是一个轻量级、高速的不可变数据库，适用于用 Go 编写的系统和应用程序。</li><li data-pid="EMVg3a5R"><a href="https://github.com/influxdb/influxdb" target="_blank">influxdb</a> - 用于指标、事件和实时分析的可扩展数据存储。</li><li data-pid="jDMKbFr0"><a href="https://github.com/siddontang/ledisdb" target="_blank">ledisdb</a> -Ledisdb 是一种高性能 NoSQL，类似于基于 LevelDB 的 Redis。</li><li data-pid="U0bTnzfI"><a href="https://github.com/jmhodges/levigo" target="_blank">levigo</a> -Levigo 是 LevelDB 的 Go 包装器.</li><li data-pid="U7zlgJTB"><a href="https://github.com/amit-davidson/LibraDB" target="_blank">libradb</a> - LibraDB 是一个简单的数据库，只有不到 1000 行代码供学习。</li><li data-pid="VpQpQAmM"><a href="https://github.com/flower-corp/lotusdb" target="_blank">lotusdb</a> - 与 lsm 和 b+tree 兼容的快速 k/v 数据库。</li><li data-pid="QfXS19Hx"><a href="https://github.com/milvus-io/milvus" target="_blank">Milvus</a> - Milvus 是一个用于嵌入管理、分析和搜索的矢量数据库.</li><li data-pid="84bqhfVu"><a href="https://github.com/couchbase/moss" target="_blank">moss</a> -Moss 是一个简单的 LSM 键值存储引擎，用 100% Go 编写。</li><li data-pid="UBvQmUdg"><a href="https://github.com/xujiajun/nutsdb" target="_blank">nutsdb</a> -Nutsdb 是一个简单、快速、可嵌入、持久的键/值存储，用纯 Go 编写。它支持完全可序列化的事务和许多数据结构，如列表、集合、有序集合。</li><li data-pid="9_lG0hAr"><a href="https://github.com/objectbox/objectbox-go" target="_blank">objectbox-go</a> - 带有 Go API 的高性能嵌入式对象数据库 (NoSQL)。</li><li data-pid="dLRpRUhH"><a href="https://github.com/fern4lvarez/piladb" target="_blank">piladb</a> - 基于堆栈数据结构的轻量级 RESTful 数据库引擎。</li><li data-pid="C549FebZ"><a href="https://github.com/akrylysov/pogreb" target="_blank">pogreb</a> - 用于读取繁重工作负载的嵌入式键值存储。</li><li data-pid="jO6OTR_J"><a href="https://github.com/prometheus/prometheus" target="_blank">prometheus</a> - 监控系统和时间序列数据库。</li><li data-pid="5KVf-wtG"><a href="https://github.com/recoilme/pudge" target="_blank">pudge</a> - 使用 Go 的标准库编写的快速简单的键/值存储。</li><li data-pid="iie3P1Vm"><a href="https://github.com/roseduan/rosedb" target="_blank">rosedb</a> - 基于 LSM+WAL 的嵌入式 kv 数据库，支持 string、list、hash、set、zset。</li><li data-pid="yMeWavZb"><a href="https://github.com/rqlite/rqlite" target="_blank">rqlite</a> - 基于 SQLite 构建的轻量级分布式关系数据库。</li><li data-pid="CaTRNjl8"><a href="https://github.com/rafaeljesus/tempdb" target="_blank">tempdb</a> - 临时项目的键值存储。</li><li data-pid="FoPTxS3Y"><a href="https://github.com/pingcap/tidb" target="_blank">tidb</a> - TiDB 是一个分布式 SQL 数据库。灵感来自 Google F1 的设计。</li><li data-pid="KM01hHvM"><a href="https://github.com/HouzuoGuo/tiedot" target="_blank">tiedot</a> - 由 Golang 提供支持的 NoSQL 数据库。</li><li data-pid="wyGgdDOB"><a href="https://github.com/unit-io/unitdb" target="_blank">unitdb</a> - 用于物联网、实时消息传递应用程序的快速时间序列数据库。使用 github.com/unit-io/unitd 应用程序通过 tcp 或 websocket 通过 pubsub 访问 unitdb。</li><li data-pid="ey9Apm4G"><a href="https://github.com/chrislusf/vasto" target="_blank">Vasto</a> - 分布式高性能键值存储。在磁盘上。最终一致。哈。能够在不中断服务的情况下增长或收缩。</li><li data-pid="C0EHFWNw"><a href="https://github.com/VictoriaMetrics/VictoriaMetrics" target="_blank">VictoriaMetrics</a> - 快速、资源高效且可扩展的开源时间序列数据库。可用作 Prometheus 的长期远程存储。支持 PromQL。</li></ul><h3><b>数据库架构迁移</b></h3><ul><li data-pid="S0UCSAdk"><a href="https://github.com/ariga/atlas" target="_blank">atlas</a> - 数据库工具包。旨在帮助公司更好地处理数据的 CLI。</li><li data-pid="Sb3G3QD6"><a href="https://github.com/khezen/avro" target="_blank">avro</a> - 发现 SQL 模式并将它们转换为 AVRO 模式。将 SQL 记录查询为 AVRO 字节。</li><li data-pid="ZXaeHIXQ"><a href="https://github.com/bytebase/bytebase" target="_blank">bytebase</a> - 用于 DevOps 团队的安全数据库模式更改和版本控制。</li><li data-pid="RXXdbptT"><a href="https://github.com/GuiaBolso/darwin" target="_blank">darwin</a> -Go 的数据库模式演化库。</li><li data-pid="HB-3tAzS"><a href="https://github.com/amacneil/dbmate" target="_blank">dbmate</a> - 轻量级、框架不可知的数据库迁移工具。</li><li data-pid="SHndVslf"><a href="https://github.com/RichardKnop/go-fixtures" target="_blank">go-fixtures</a> - 用于 Golang 出色的内置数据库/sql 库的 Django 风格固定装置。</li><li data-pid="dgQF73wv"><a href="https://github.com/lawzava/go-pg-migrate" target="_blank">go-pg-migrate</a> - 用于 go-pg 迁移管理的 CLI 友好包。</li><li data-pid="zb13NmGw"><a href="https://github.com/robinjoseph08/go-pg-migrations" target="_blank">go-pg-migrations</a> - 一个 Go 包，用于帮助使用 go-pg/pg 编写迁移。</li><li data-pid="dh1SkcI9"><a href="https://github.com/linkedin/goavro" target="_blank">goavro</a> - 一个对 Avro 数据进行编码和解码的 Go 包。</li><li data-pid="fBA8E2P1"><a href="https://github.com/rafaelespinoza/godfish" target="_blank">godfish</a> - 数据库迁移管理器，使用本机查询语言。支持 cassandra、mysql、postgres、sqlite3。</li><li data-pid="3fDvjPx6"><a href="https://github.com/pressly/goose" target="_blank">goose</a> - 数据库迁移工具。您可以通过创建增量 SQL 或 Go 脚本来管理数据库的演变。</li><li data-pid="bnXEMXZC"><a href="https://github.com/Kachit/gorm-seeder" target="_blank">gorm-seeder</a> -Gorm ORM 的简单数据库播种机。</li><li data-pid="Cx2FLoZ8"><a href="https://github.com/go-gormigrate/gormigrate" target="_blank">gormigrate</a> -Gorm ORM 的数据库模式迁移助手。</li><li data-pid="I8mDXnaz"><a href="https://github.com/muir/libschema" target="_blank">libschema</a> - 在每个库中分别定义您的迁移。开源库的迁移。MySQL 和 PostgreSQL。</li><li data-pid="w_rOKBqf"><a href="https://github.com/golang-migrate/migrate" target="_blank">迁移</a>- 数据库迁移。CLI 和 Golang 库。</li><li data-pid="EXBhv9_k"><a href="https://github.com/lopezator/migrator" target="_blank">migrator</a> - 非常简单的 Go 数据库迁移库。</li><li data-pid="L2J3Fj2g"><a href="https://github.com/larapulse/migrator" target="_blank">migrator</a> - MySQL 数据库迁移器，旨在运行迁移到您的功能并使用直观的 go 代码管理数据库模式更新。</li><li data-pid="YQWr6WW2"><a href="https://github.com/adlio/schema" target="_blank">schema</a> - 用于在 Go 二进制文件中嵌入数据库/sql 兼容数据库的模式迁移的库。</li><li data-pid="GkFATwGi"><a href="https://github.com/skeema/skeema" target="_blank">skeema</a> - 用于 MySQL 的纯 SQL 模式管理系统，支持分片和外部在线模式更改工具。</li><li data-pid="cUMz6GPg"><a href="https://github.com/gobuffalo/pop/tree/master/soda" target="_blank">soda</a> - 用于 MySQL、PostgreSQL 和 SQLite 的数据库迁移、创建、ORM 等。</li><li data-pid="Sc9WcM47"><a href="https://github.com/rubenv/sql-migrate" target="_blank">sql-migrate</a> - 数据库迁移工具。允许使用 go-bindata 将迁移嵌入到应用程序中。</li><li data-pid="RNE1GOpn"><a href="https://github.com/sunary/sqlize" target="_blank">sqlize</a> - 数据库迁移生成器。允许通过区分模型和现有 sql 来生成 sql 迁移。</li></ul><h3><b>数据库工具</b></h3><ul><li data-pid="k5Me6B-7"><a href="https://github.com/Vertamedia/chproxy" target="_blank">chproxy</a> - ClickHouse 数据库的 HTTP 代理。</li><li data-pid="VwW1MXlR"><a href="https://github.com/nikepan/clickhouse-bulk" target="_blank">clickhouse-bulk</a> - 收集小插入并将大请求发送到 ClickHouse 服务器。</li><li data-pid="3nDCG7fa"><a href="https://github.com/codingconcepts/datagen" target="_blank">datagen</a> - 一种快速数据生成器，支持多表并支持多行 DML。</li><li data-pid="bd8aWChv"><a href="https://github.com/sj14/dbbench" target="_blank">dbbench</a> - 支持多个数据库和脚本的数据库基准测试工具。</li><li data-pid="LPbnkNX8"><a href="https://github.com/twharmon/dynago" target="_blank">dynago</a> - 简化使用 AWS DynamoDB 的工作。</li><li data-pid="VIsxJypV"><a href="https://github.com/siddontang/go-mysql" target="_blank">go-mysql</a> - 用于处理 MySQL 协议和复制的 Go 工具集。</li><li data-pid="uZFXENQV"><a href="https://github.com/siddontang/go-mysql-elasticsearch" target="_blank">go-mysql-elasticsearch</a> - 自动将您的 MySQL 数据同步到 Elasticsearch。</li><li data-pid="0uHWn9s4"><a href="https://golang.yandex/hasql" target="_blank">hasql</a> - 用于访问多主机 SQL 数据库安装的库。</li><li data-pid="OmmqmKd0"><a href="https://github.com/flike/kingshard" target="_blank">kingshard</a> -kingshard 是由 Golang 提供支持的 MySQL 的高性能代理。</li><li data-pid="OTgRp4Ar"><a href="https://github.com/knocknote/octillery" target="_blank">octillery</a> - 用于分片数据库的 Go 包（支持每个 ORM 或原始 SQL）。</li><li data-pid="-3Vdnsp7"><a href="https://github.com/liweiyi88/onedump" target="_blank">onedump</a> - 使用一个命令和配置将数据库从不同的驱动程序备份到不同的目的地。</li><li data-pid="L3XO_wT1"><a href="https://github.com/github/orchestrator" target="_blank">orchestrator</a> -MySQL 复制拓扑管理器和可视化器。</li><li data-pid="4fhqZKfr"><a href="https://github.com/cybertec-postgresql/pg_timetable" target="_blank">pg_timetable</a> - PostgreSQL 的高级调度。</li><li data-pid="5dz1NAqi"><a href="https://github.com/sosedoff/pgweb" target="_blank">pgweb</a> - 基于 Web 的 PostgreSQL 数据库浏览器。</li><li data-pid="8I1r_8Iv"><a href="https://github.com/hexdigest/prep" target="_blank">prep</a> - 在不更改代码的情况下使用准备好的 SQL 语句。</li><li data-pid="_6oNKhAy"><a href="https://github.com/prest/prest" target="_blank">perst</a> - 简化和加速开发，⚡在任何现有或新的 Postgres 应用程序上即时、实时、高性能。</li><li data-pid="kZRT_ZuB"><a href="https://github.com/HDT3213/rdb" target="_blank">rdb</a> - 用于二次开发和内存分析的 Redis RDB 文件解析器。</li><li data-pid="r72_06-D"><a href="https://github.com/andizzle/rwdb" target="_blank">rwdb</a> - rwdb 为多个数据库服务器设置提供只读副本功能。</li><li data-pid="qYReeHpU"><a href="https://github.com/youtube/vitess" target="_blank">vitess</a> - vitess 提供服务器和工具，有助于为大规模 Web 服务扩展 MySQL 数据库。</li></ul><h3><b>SQL 查询生成器</b></h3><p data-pid="cTsqap4p"><i>用于构建和使用 SQL 的库。</i></p><ul><li data-pid="bPBbwlqL"><a href="https://github.com/nullism/bqb" target="_blank">bqb</a> - 轻量级且易于学习的查询构建器。</li><li data-pid="-vDW8RP_"><a href="https://github.com/arthurkushman/buildsqlx" target="_blank">buildsqlx</a> - 用于 PostgreSQL 的 Go 数据库查询构建器库。</li><li data-pid="bwa7S4YG"><a href="https://github.com/cristalhq/builq" target="_blank">builq</a> - 在 Go 中轻松构建 SQL 查询。</li><li data-pid="kD9prBXl"><a href="https://github.com/rocketlaunchr/dbq" target="_blank">dbq</a> - Go 的零样板数据库操作。</li><li data-pid="W2ZJe8z4"><a href="https://github.com/gchaincl/dotsql" target="_blank">Dotsql</a> - 帮助您将 sql 文件保存在一个地方并轻松使用它们的 Go 库。</li><li data-pid="T4EWxNxz"><a href="https://github.com/didi/gendry" target="_blank">gendry</a> - 非侵入式 SQL 构建器和强大的数据绑定器。</li><li data-pid="ndzQ8GU_"><a href="https://github.com/xujiajun/godbal" target="_blank">godbal</a> - 用于 go 的数据库抽象层 (dbal)。支持 SQL 生成器并轻松获得结果。</li><li data-pid="0XC7QUrU"><a href="https://github.com/doug-martin/goqu" target="_blank">goqu</a> - 惯用的 SQL 构建器和查询库。</li><li data-pid="GUUX1IHd"><a href="https://github.com/twharmon/gosql" target="_blank">gosql</a> - 具有更好的空值支持的 SQL 查询构建器。</li><li data-pid="JNnSKpzO"><a href="https://github.com/galeone/igor" target="_blank">igor</a> - PostgreSQL 的抽象层，支持高级功能并使用类似 gorm 的语法。</li><li data-pid="JvBXMpYc"><a href="https://github.com/go-jet/jet" target="_blank">jet</a> - 在 Go 中编写类型安全的 SQL 查询的框架，能够轻松地将数据库查询结果转换为所需的任意对象结构。</li><li data-pid="SsgS22JQ"><a href="https://github.com/pupizoid/ormlite" target="_blank">ormlite</a> - 轻量级包，包含一些类似 ORM 的功能和 sqlite 数据库的帮助程序。</li><li data-pid="-AvViR1c"><a href="https://github.com/go-ozzo/ozzo-dbx" target="_blank">ozzo-dbx</a> - 强大的数据检索方法以及与数据库无关的查询构建功能。</li><li data-pid="DbdrcOxl"><a href="https://github.com/HnH/qry" target="_blank">qry</a> - 使用原始 SQL 查询从文件生成常量的工具。</li><li data-pid="w3-HgZL1"><a href="https://github.com/go-the-way/sg" target="_blank">sg</a> - 用于生成用 Go 编写的标准 SQL（支持：CRUD）的 SQL Gen。</li><li data-pid="7DSgNltB"><a href="https://github.com/bokwoon95/go-structured-query" target="_blank">sq</a> -Go 的类型安全 SQL 构建器和结构映射器。</li><li data-pid="vNCNX2Yi"><a href="https://github.com/kyleconroy/sqlc" target="_blank">sqlc</a> - 从 SQL 生成类型安全的代码。</li><li data-pid="FfLbfnQ-"><a href="https://github.com/leporo/sqlf" target="_blank">sqlf</a> - 快速 SQL 查询生成器。</li><li data-pid="-dO0EzyW"><a href="https://github.com/lqs/sqlingo" target="_blank">sqlingo</a> - 用于在 Go 中构建 SQL 的轻量级 DSL。</li><li data-pid="nY7nqnXG"><a href="https://github.com/elgris/sqrl" target="_blank">sqrl</a> - SQL 查询生成器，具有改进性能的 Squirrel 的分支。</li><li data-pid="E3nSAbk2"><a href="https://gitlab.com/qosenergy/squalus" target="_blank">Squalus</a> - Go SQL 包上的薄层，可以更轻松地执行查询。</li><li data-pid="WW9Q3C04"><a href="https://github.com/Masterminds/squirrel" target="_blank">Squirrel</a> - 帮助您构建 SQL 查询的 Go 库。</li><li data-pid="BgRCWFBz"><a href="https://github.com/knq/xo" target="_blank">xo</a> - 根据现有模式定义或支持 PostgreSQL、MySQL、SQLite、Oracle 和 Microsoft SQL Server 的自定义查询为数据库生成惯用的 Go 代码。</li></ul><p data-pid="SB-pbFxt"><b><a href="https://github.com/avelino/awesome-go/blob/main/README.md#contents" target="_blank">⬆回到顶部</a></b></p><h2><b>数据库驱动程序</b></h2><h3><b>多个后端的接口</b></h3><ul><li data-pid="YINFi9MB"><a href="https://github.com/google/cayley" target="_blank">cayley</a> - 支持多个后端的图形数据库。</li><li data-pid="M2jSliZE"><a href="https://github.com/viant/dsc" target="_blank">dsc</a> - SQL、NoSQL、结构化文件的数据存储连接。</li><li data-pid="w5_3XZHH"><a href="https://github.com/avito-tech/go-transaction-manager" target="_blank">go-transaction-manager</a> - 具有多个适配器（sql、sqlx、gorm、mongo 等）的事务管理器控制事务边界。</li><li data-pid="7WqESkGk"><a href="https://github.com/philippgille/gokv" target="_blank">gokv</a> - Go 的简单键值存储抽象和实现（Redis、Consul、etcd、bbolt、BadgerDB、LevelDB、Memcached、DynamoDB、S3、PostgreSQL、MongoDB、CockroachDB 等等）。</li></ul><h3><b>关系数据库驱动程序</b></h3><ul><li data-pid="n8DlK6Qt"><a href="https://github.com/apache/calcite-avatica-go" target="_blank">avatica</a> - 用于数据库/sql 的 Apache Avatica/Phoenix SQL 驱动程序。</li><li data-pid="1BfTbPG-"><a href="https://github.com/viant/bgc" target="_blank">bgc</a> - 用于 BigQuery 的数据存储区连接。</li><li data-pid="Gib7WkKl"><a href="https://github.com/nakagami/firebirdsql" target="_blank">firebirdsql</a> - 用于 Go 的 Firebird RDBMS SQL 驱动程序。</li><li data-pid="rmV27T2G"><a href="https://github.com/mattn/go-adodb" target="_blank">go-adodb</a> - 用于使用数据库/sql 的 go 的 Microsoft ActiveX 对象数据库驱动程序。</li><li data-pid="ODIyIARH"><a href="https://github.com/denisenkom/go-mssqldb" target="_blank">go-mssqldb</a> - 用于 Go 的 Microsoft MSSQL 驱动程序。</li><li data-pid="xqS-uv56"><a href="https://github.com/mattn/go-oci8" target="_blank">go-oci8</a> - 使用数据库/sql 的 go Oracle 驱动程序。</li><li data-pid="oQe2Nv5s"><a href="https://github.com/go-sql-driver/mysql" target="_blank">go-sql-driver/mysql</a> - Go 的 MySQL 驱动程序。</li><li data-pid="vOmemWoB"><a href="https://github.com/mattn/go-sqlite3" target="_blank">go-sqlite3</a> - 使用数据库/sql 的 SQLite3 驱动程序。</li><li data-pid="fcksvZA8"><a href="https://github.com/godror/godror" target="_blank">godror</a> -Go 的 Oracle 驱动程序，使用 ODPI-C 驱动程序。</li><li data-pid="YuxA6vwX"><a href="https://github.com/minus5/gofreetds" target="_blank">gofreetds</a> - 微软 MSSQL 驱动程序。<a href="https://www.freetds.org/" target="_blank">对FreeTDS</a>进行包装。</li><li data-pid="2IWUOZA2"><a href="https://github.com/VinGarcia/ksql" target="_blank">KSQL</a> - 一个简单而强大的 Golang SQL 库</li><li data-pid="g8Hrzmv3"><a href="https://github.com/jackc/pgx" target="_blank">pgx</a> - PostgreSQL 驱动程序支持的功能超出了数据库/sql 公开的功能。</li><li data-pid="NNbQucJp"><a href="https://github.com/alexeyco/pig" target="_blank">pig</a> - 简单的<a href="https://github.com/jackc/pgx" target="_blank">pgx</a>包装器，可以轻松执行和<a href="https://github.com/georgysavva/scany" target="_blank">扫描</a>查询结果。</li><li data-pid="cnwZtacW"><a href="https://github.com/lib/pq" target="_blank">pq</a> - 用于数据库/sql 的纯 Go Postgres 驱动程序。</li><li data-pid="LeQ3OtSv"><a href="https://github.com/cvilsmeier/sqinn-go" target="_blank">Sqinn-Go</a> - 带有纯 Go 的 SQLite.</li><li data-pid="TEdqHIN1"><a href="https://github.com/qustavo/sqlhooks" target="_blank">sqlhooks</a> - 将挂钩附加到任何数据库/sql 驱动程序。</li><li data-pid="5nw5v8t5"><a href="https://github.com/ydb-platform/ydb-go-sdk" target="_blank">ydb-go-sdk</a> - 本机和数据库/sql 驱动程序 YDB（Yandex 数据库）</li></ul><h3><b>NoSQL 数据库驱动程序</b></h3><ul><li data-pid="dai2tE2h"><a href="https://github.com/aerospike/aerospike-client-go" target="_blank">aerospike-client-go</a> -Go 语言的 Aerospike 客户端。</li><li data-pid="A0466L_I"><a href="https://github.com/solher/arangolite" target="_blank">arangolite</a> - 用于 ArangoDB 的轻量级 golang 驱动程序。</li><li data-pid="ZY4F8Fj0"><a href="https://github.com/viant/asc" target="_blank">asc</a> - 用于 Aerospike for go 的数据存储连接.</li><li data-pid="dB1mRiTy"><a href="https://github.com/couchbase/goforestdb" target="_blank">forestdb</a> - ForestDB 的 Go 绑定。</li><li data-pid="0VUthjn4"><a href="https://github.com/couchbase/go-couchbase" target="_blank">go-couchbase</a> -Go 中的 Couchbase 客户端。</li><li data-pid="p--Dkb-c"><a href="https://github.com/pilosa/go-pilosa" target="_blank">go-pilosa</a> - Pilosa 的 Go 客户端库。</li><li data-pid="PzhLvUx9"><a href="https://github.com/nitishm/go-rejson" target="_blank">go-rejson</a> - 使用 Redigo golang 客户端的 redislabs ReJSON 模块的 Golang 客户端。在 Redis 中将结构作为 JSON 对象轻松存储和操作。</li><li data-pid="KXAlzZIt"><a href="https://github.com/couchbase/gocb" target="_blank">gocb</a> - 官方 Couchbase Go SDK.</li><li data-pid="YZiVEhDH"><a href="https://github.com/btnguyen2k/gocosmos" target="_blank">gocosmos</a><code>database/sql</code> - Azure Cosmos DB 的REST 客户端和标准驱动程序。</li><li data-pid="p5HP4yY7"><a href="https://gocql.github.io/" target="_blank">gocql</a> -Apache Cassandra 的 Go 语言驱动程序。</li><li data-pid="WiNZDdpN"><a href="https://github.com/piaohao/godis" target="_blank">godis</a> - 受绝地武士启发，由 golang 实现的 redis 客户端。</li><li data-pid="YCqkq0Kw"><a href="https://github.com/defcronyke/godscache" target="_blank">godscache</a> - Google Cloud Platform Go Datastore 包的包装器，使用 memcached 添加缓存。</li><li data-pid="w9sj07aF"><a href="https://github.com/bradfitz/gomemcache/" target="_blank">gomemcache</a> - Go 编程语言的内存缓存客户端库。</li><li data-pid="IbNNQqCl"><a href="https://github.com/dancannon/gorethink" target="_blank">gorethink</a> -RethinkDB 的 Go 语言驱动程序。</li><li data-pid="oz9e9In2"><a href="https://github.com/zegl/goriak" target="_blank">goriak</a> -Riak KV 的 Go 语言驱动程序。</li><li data-pid="fLKikI6O"><a href="https://github.com/go-kivik/kivik" target="_blank">Kivik</a> -Kivik 为 CouchDB、PouchDB 和类似数据库提供了一个通用的 Go 和 GopherJS 客户端库。</li><li data-pid="2rmSXUXP"><a href="https://github.com/kamva/mgm" target="_blank">mgm</a> - 用于 Go 的基于 MongoDB 模型的 ODM（基于官方 MongoDB 驱动程序）。</li><li data-pid="RIW1g_3O"><a href="https://github.com/globalsign/mgo" target="_blank">mgo</a> -（未维护）用于 Go 语言的 MongoDB 驱动程序，它在遵循标准 Go 习语的非常简单的 API 下实现了丰富且经过良好测试的功能选择。</li><li data-pid="-3p6dX8t"><a href="https://github.com/mongodb/mongo-go-driver" target="_blank">mongo-go-driver</a> -Go 语言的官方 MongoDB 驱动程序。</li><li data-pid="GiVIsHRc"><a href="https://github.com/cihangir/neo4j" target="_blank">neo4j</a> - Golang 的 Neo4j Rest API 绑定.</li><li data-pid="Z0B02QKX"><a href="https://github.com/davemeehan/Neo4j-GO" target="_blank">Neo4j-GO</a> -golang 中的 Neo4j REST 客户端.</li><li data-pid="7ZuH2-iy"><a href="https://github.com/jmcvetta/neoism" target="_blank">neoism</a> -Golang 的 Neo4j 客户端.</li><li data-pid="oNWwy2Ku"><a href="https://github.com/qiniu/qmgo" target="_blank">qmgo</a> - 用于 Go 的 MongoDB 驱动程序。它基于官方 MongoDB 驱动程序，但更易于使用，如 Mgo。</li><li data-pid="YOdPO2N0"><a href="https://github.com/bsm/redeo" target="_blank">redeo</a> -Redis 协议兼容的 TCP 服务器/服务。</li><li data-pid="ek8BwVNW"><a href="https://github.com/gomodule/redigo" target="_blank">redigo</a> - Redigo 是 Redis 数据库的 Go 客户端。</li><li data-pid="wZ77NQB0"><a href="https://github.com/redis/go-redis" target="_blank">redis</a> -Golang 的 Redis 客户端。</li><li data-pid="_B-7kOQ5"><a href="http://github.com/rueian/rueidis" target="_blank">rueidis</a> - 具有自动流水线和服务器辅助客户端缓存的快速 Redis RESP3 客户端。</li><li data-pid="3t1ucran"><a href="https://github.com/shomali11/xredis" target="_blank">xredis</a> - 类型安全、可定制、干净且易于使用的 Redis 客户端。</li></ul><h3><b>搜索和分析数据库</b></h3><ul><li data-pid="jHC1FsBR"><a href="https://github.com/olivere/elastic" target="_blank">elastic</a> -Go 的 Elasticsearch 客户端。</li><li data-pid="8xUBitD5"><a href="https://github.com/cch123/elasticsql" target="_blank">elasticsql</a> - 在 Go 中将 sql 转换为 elasticsearch dsl.</li><li data-pid="3rtYsyWZ"><a href="https://github.com/mattbaird/elastigo" target="_blank">elastigo</a> - Elasticsearch 客户端库。</li><li data-pid="pQfElDOh"><a href="https://github.com/elastic/go-elasticsearch" target="_blank">go-elasticsearch</a> -Go 的官方 Elasticsearch 客户端。</li><li data-pid="MdRS_cJf"><a href="https://github.com/OwnLocal/goes" target="_blank">goes</a> - 与 Elasticsearch 交互的库。</li><li data-pid="VyB-qMGZ"><a href="https://github.com/seiflotfy/skizze" target="_blank">skizze</a> - 概率数据结构服务和存储。</li></ul><p data-pid="WxppieT8"><b><a href="https://github.com/avelino/awesome-go/blob/main/README.md#contents" target="_blank">⬆回到顶部</a></b></p><h2><b>日期和时间</b></h2><p data-pid="af95Ztk4"><i>用于处理日期和时间的库。</i></p><ul><li data-pid="ACcv4-X9"><a href="https://github.com/golang-module/carbon" target="_blank">carbon</a> - 用于日期时间的简单、语义化且对开发人员友好的 golang 包。</li><li data-pid="KsuVjJGo"><a href="https://github.com/uniplaces/carbon" target="_blank">carbon</a> - 带有很多实用方法的简单时间扩展，从 PHP Carbon 库移植而来。</li><li data-pid="HlqMsLFS"><a href="https://github.com/1set/cronrange" target="_blank">cronrange</a> - 解析 Cron 风格的时间范围表达式，检查给定时间是否在任何范围内。</li><li data-pid="qIwmuqcO"><a href="https://github.com/rickb777/date" target="_blank">date</a> - 用于处理日期、日期范围、时间跨度、期间和一天中的时间的 Augments Time。</li><li data-pid="3ScenlyN"><a href="https://github.com/araddon/dateparse" target="_blank">dateparse</a> - 在事先不知道格式的情况下解析日期。</li><li data-pid="SX-hni4i"><a href="https://github.com/hako/durafmt" target="_blank">durafmt</a> -Go 的持续时间格式化库。</li><li data-pid="hucJorh7"><a href="https://github.com/wlbr/feiertage" target="_blank">feiertage</a> - 一组用于计算德国公共假期的函数，包括。专门研究德国各州 (Bundesländer)。像复活节、五旬节、感恩节...</li><li data-pid="iEvZmukm"><a href="https://github.com/ijt/go-anytime" target="_blank">go-anytime</a> - 在事先不知道格式的情况下解析日期/时间，如“下一个 12 月 22 日下午 3 点”，范围如“从今天到下星期四”。</li><li data-pid="6XuxqSax"><a href="https://github.com/yaa110/go-persian-calendar" target="_blank">go-persian-calendar</a> - Go (golang) 中波斯语（Solar Hijri）日历的实现。</li><li data-pid="DQ2lTRIC"><a href="https://github.com/xhit/go-str2duration" target="_blank">go-str2duration</a> - 将字符串转换为持续时间。支持 time.Duration 返回字符串等。</li><li data-pid="gxiKRjbS"><a href="https://github.com/nathan-osman/go-sunrise" target="_blank">go-sunrise</a> - 计算给定位置的日出和日落时间。</li><li data-pid="s_89gq5R"><a href="https://github.com/stoewer/go-week" target="_blank">go-week</a> - 使用 ISO8601 周日期的高效软件包。</li><li data-pid="vKkWrZn3"><a href="https://github.com/bykof/gostradamus" target="_blank">gostradamus</a> - 用于处理日期的 Go 包。</li><li data-pid="WJMO9V6G"><a href="https://github.com/relvacode/iso8601" target="_blank">iso8601</a> - 无需正则表达式即可有效解析 ISO8601 日期时间.</li><li data-pid="Kr0bvpL3"><a href="https://github.com/GuilhermeCaruso/kair" target="_blank">kair</a> - 日期和时间 - Golang 格式化库。</li><li data-pid="cvSjAiRQ"><a href="https://github.com/jinzhu/now" target="_blank">now</a> -Now 是 golang 的时间工具包。</li><li data-pid="XC3wrbQu"><a href="https://github.com/kirillDanshin/nulltime" target="_blank">NullTime</a> - 可为空<code>time.Time</code>。</li><li data-pid="ssj6glNi"><a href="https://github.com/awoodbeck/strftime" target="_blank">strftime</a> - C99 兼容的 strftime 格式化程序。</li><li data-pid="RijeeeTL"><a href="https://github.com/SaidinWoT/timespan" target="_blank">timespan</a> - 用于与时间间隔交互，定义为开始时间和持续时间。</li><li data-pid="jMIVb7So"><a href="https://github.com/leekchan/timeutil" target="_blank">timeutil</a> - golang 时间包的有用扩展（Timedelta、Strftime 等）。</li><li data-pid="7kIDH9Cm"><a href="https://github.com/osteele/tuesday" target="_blank">tuesday</a> -Ruby 兼容的 Strftime 函数.</li></ul><p data-pid="e4RZ23n7"><b><a href="https://github.com/avelino/awesome-go/blob/main/README.md#contents" target="_blank">⬆回到顶部</a></b></p><h2><b>分布式系统</b></h2><p data-pid="qKqQlyi3"><i>帮助构建分布式系统的包。</i></p><ul><li data-pid="lbjrcub1"><a href="https://github.com/lesismal/arpc" target="_blank">arpc</a> - 更有效的网络通信，支持双向调用、通知、广播。</li><li data-pid="zWhOiGLS"><a href="https://github.com/svcavallar/celeriac.v1" target="_blank">celeriac</a> - 用于添加对在 Go 中交互和监控 Celery 工作人员、任务和事件的支持的库。</li><li data-pid="N2UuvMvA"><a href="https://github.com/buraksezer/consistent" target="_blank">consistent</a> - 具有有限负载的一致散列。</li><li data-pid="nw0I9O-5"><a href="https://github.com/mbrostami/consistenthash" target="_blank">consistenthash</a> - 具有可配置副本的一致哈希。</li><li data-pid="mCWppSf7"><a href="https://github.com/anacrolix/dht" target="_blank">dht</a> - BitTorrent Kademlia DHT 实现.</li><li data-pid="psfN2QVG"><a href="https://github.com/digota/digota" target="_blank">digota</a> -grpc 电子商务微服务。</li><li data-pid="-WgpD4T_"><a href="https://github.com/dotchain/dot/" target="_blank">dot</a> - 使用操作转换/OT 的分布式同步。</li><li data-pid="7VInwBe6"><a href="https://github.com/edwingeng/doublejump" target="_blank">doublejump</a> - 改进后的 Google 跳跃一致性哈希。</li><li data-pid="BCBRhFW6"><a href="https://github.com/lni/dragonboat" target="_blank">dragonboat</a> - Go 中功能完整且高性能的多组 Raft 库。</li><li data-pid="lWLqdwb-"><a href="https://github.com/dragonflyoss/Dragonfly2" target="_blank">Dragonfly</a> - 基于p2p技术提供高效、稳定、安全的文件分发和图片加速，成为云原生架构的最佳实践和标准方案。</li><li data-pid="TToea1Hz"><a href="https://github.com/dgruber/drmaa" target="_blank">drmaa</a> - 基于 DRMAA 标准的集群调度程序的作业提交库。</li><li data-pid="pHH834QC"><a href="https://cirello.io/dynamolock" target="_blank">dynamolock</a> - DynamoDB 支持的分布式锁定实现。</li><li data-pid="sLgUX6wO"><a href="https://github.com/tylfin/dynatomic" target="_blank">dynatomic</a> - 将 DynamoDB 用作原子计数器的库。</li><li data-pid="EHao80Lo"><a href="https://github.com/emitter-io/emitter" target="_blank">emitter-io</a> - 使用 MQTT、Websockets 和 love 构建的高性能、分布式、安全和低延迟的发布-订阅平台。</li><li data-pid="hFmTC3hU"><a href="https://github.com/andy2046/failured" target="_blank">failed</a> - 分布式系统的自适应应计故障检测器。</li><li data-pid="KGedvOJ4"><a href="https://github.com/vectaport/flowgraph" target="_blank">flowgraph</a> - 基于流的编程包。</li><li data-pid="2K7R2k05"><a href="https://github.com/chrislusf/gleam" target="_blank">gleam</a> - 用纯 Go 和 Luajit 编写的快速且可扩展的分布式 map/reduce 系统，结合了 Go 的高并发性和 Luajit 的高性能，独立运行或分布式运行。</li><li data-pid="VuUGh2IH"><a href="https://github.com/chrislusf/glow" target="_blank">glow</a> - 易于使用的可扩展分布式大数据处理、Map-Reduce、DAG 执行，全部采用纯 Go 语言。</li><li data-pid="uNeeaiJw"><a href="https://github.com/gmsec/micro" target="_blank">gmsec</a> - Go 分布式系统开发框架。</li><li data-pid="aEj4lQEn"><a href="https://github.com/unionj-cloud/go-doudou" target="_blank">go-doudou</a> - 基于八卦协议和 OpenAPI 3.0 规范的去中心化微服务框架。专注于低代码和快速开发的内置 go-doudou cli 可以提高您的工作效率。</li><li data-pid="wZcLNIvI"><a href="https://github.com/InVisionApp/go-health" target="_blank">go-health</a> - 用于在您的服务中启用异步依赖项健康检查的库。</li><li data-pid="RAmWhcMK"><a href="https://github.com/dgryski/go-jump" target="_blank">go-jump</a> - Google 的“Jump”一致性哈希函数的端口。</li><li data-pid="E0teEYtp"><a href="https://github.com/go-kit/kit" target="_blank">go-kit</a> - 支持服务发现、负载均衡、可插拔传输、请求跟踪等的微服务工具包。</li><li data-pid="E_SRkVzN"><a href="https://github.com/micro/go-micro" target="_blank">go-micro</a> - 分布式系统开发框架。</li><li data-pid="yF3IAZoz"><a href="https://github.com/sanketplus/go-mysql-lock" target="_blank">go-mysql-lock</a> - 基于 MySQL 的分布式锁。</li><li data-pid="haMAdiDc"><a href="https://github.com/pdupub/go-pdu" target="_blank">go-pdu</a> - 一个分散的基于身份的社交网络。</li><li data-pid="NEDeJKKV"><a href="https://github.com/AppsFlyer/go-sundheit" target="_blank">go-sundheit</a> - 一个为 golang 服务定义异步服务健康检查提供支持的库。</li><li data-pid="BYPiFXLM"><a href="https://github.com/tal-tech/go-zero" target="_blank">go-zero</a> - 一个 web 和 rpc 框架。它的诞生是为了以弹性设计确保繁忙站点的稳定性。内置 goctl 大大提高了开发效率。</li><li data-pid="Xs9rhCUH"><a href="https://github.com/valyala/gorpc" target="_blank">gorpc</a> - 用于高负载的简单、快速和可扩展的 RPC 库。</li><li data-pid="RPjd-XZP"><a href="https://github.com/grpc/grpc-go" target="_blank">grpc-go</a> - gRPC 的 Go 语言实现。基于 HTTP/2 的 RPC。</li><li data-pid="v8kwSDvQ"><a href="https://github.com/hprose/hprose-golang" target="_blank">hprose</a> - 非常新的 RPC 库，现在支持 25 种以上的语言。</li><li data-pid="UCIhGTue"><a href="https://github.com/osamingo/jsonrpc" target="_blank">jsonrpc</a> - jsonrpc 包有助于实现 JSON-RPC 2.0.</li><li data-pid="sRaPyByJ"><a href="https://github.com/ybbus/jsonrpc" target="_blank">jsonrpc</a> -JSON-RPC 2.0 HTTP 客户端实现。</li><li data-pid="VzVgyp96"><a href="https://github.com/cloudwego/kitex" target="_blank">Kitex</a> - 一个高性能和强扩展性的 Golang RPC 框架，帮助开发者构建微服务。如果您在开发微服务时主要关注性能和可扩展性，那么 Kitex 是一个不错的选择。</li><li data-pid="Pw8I_uhJ"><a href="https://github.com/go-kratos/kratos" target="_blank">Kratos</a> - Go 中模块化设计且易于使用的微服务框架。</li><li data-pid="11BWOGEe"><a href="https://github.com/liftbridge-io/liftbridge" target="_blank">liftbridge</a> - 用于 NATS 的轻量级、容错消息流。</li><li data-pid="dr3Lyc0X"><a href="https://github.com/luraproject/lura" target="_blank">lura</a> - 带有中间件的超高性能 API 网关框架。</li><li data-pid="Vj-j63w6"><a href="https://github.com/micro/micro" target="_blank">micro</a> - 用于云及其他领域的分布式系统运行时。</li><li data-pid="C3sT9eWl"><a href="https://github.com/nats-io/gnatsd" target="_blank">NATS</a> - 用于微服务、物联网和云原生系统的轻量级、高性能消息传递系统。</li><li data-pid="RuNBl-ww"><a href="https://github.com/italolelis/outboxer" target="_blank">outboxer</a> - Outboxer 是一个实现发件箱模式的 go 库。</li><li data-pid="CWsOgzR4"><a href="https://cirello.io/pglock" target="_blank">pglock</a> - PostgreSQL 支持的分布式锁定实现。</li><li data-pid="0JQaVbNd"><a href="https://gitlab.com/pjrpc/pjrpc" target="_blank">pjrpc</a> - 具有 Protobuf 规范的 Golang JSON-RPC 服务器客户端。</li><li data-pid="6d4HZ1Dz"><a href="https://github.com/hashicorp/raft" target="_blank">raft</a> - Raft 共识协议的 Golang 实现，由 HashiCorp 提供。</li><li data-pid="28FwQrpM"><a href="https://github.com/etcd-io/raft" target="_blank">raft</a> - 由 CoreOS 执行 Raft 共识协议。</li><li data-pid="M0Wsinsd"><a href="https://github.com/cenkalti/rain" target="_blank">rain</a> - BitTorrent 客户端和库。</li><li data-pid="vwu9Mv0S"><a href="https://github.com/bsm/redislock" target="_blank">redis-lock</a> - 使用 Redis 的简化分布式锁定实现。</li><li data-pid="7k7u9TPu"><a href="https://resgate.io/" target="_blank">resgate</a> - 用于构建 REST、实时和 RPC API 的实时 API 网关，所有客户端都在其中无缝同步。</li><li data-pid="N-IjDc-U"><a href="https://github.com/uber/ringpop-go" target="_blank">ringpop-go</a> - 用于 Go 应用程序的可扩展、容错的应用程序层分片。</li><li data-pid="anhHrW9o"><a href="https://github.com/smallnest/rpcx" target="_blank">rpcx</a> - 类似阿里巴巴 Dubbo 的分布式可插拔 RPC 服务框架。</li><li data-pid="bxe3Ho1N"><a href="https://github.com/jexia/semaphore" target="_blank">信号量</a>- 一个简单的（微）服务编排器。</li><li data-pid="6ia6aCQz"><a href="https://github.com/ursiform/sleuth" target="_blank">sleuth</a> - 用于 HTTP 服务之间的无主 p2p 自动发现和 RPC 的库（使用<a href="https://github.com/zeromq/libzmq" target="_blank">ZeroMQ</a>）。</li><li data-pid="5N1q904F"><a href="https://github.com/anacrolix/torrent" target="_blank">torrent</a> - BitTorrent 客户端包。</li></ul><p data-pid="EkKEdwm_"><b><a href="https://github.com/avelino/awesome-go/blob/main/README.md#contents" target="_blank">⬆回到顶部</a></b></p><h2><b>动态域名系统</b></h2><p data-pid="r4Ckxhkc"><i>更新动态 DNS 记录的工具。</i></p><ul><li data-pid="u97A0yzi"><a href="https://github.com/skibish/ddns" target="_blank">DDNS</a> - 以数字海洋网络 DNS 作为后端的个人 DDNS 客户端。</li><li data-pid="LJM2m0UE"><a href="https://gitlab.com/alcastle/dyndns" target="_blank">dyndns</a> - 后台程序定期自动检查您的 IP 地址，并在您的地址发生变化时更新（一个或多个）Google 域的动态 DNS 记录。</li><li data-pid="kP8c3K9k"><a href="https://github.com/timothyye/godns" target="_blank">GoDNS</a> - 动态 DNS 客户端工具，支持 DNSPod 和 HE.net，用 Go 编写。</li></ul><p data-pid="7u5y83Oe"><b><a href="https://github.com/avelino/awesome-go/blob/main/README.md#contents" target="_blank">⬆回到顶部</a></b></p><h2><b>电子邮件</b></h2><p data-pid="JIKxCHCQ"><i>实现电子邮件创建和发送的库和工具。</i></p><ul><li data-pid="5hpGSbR9"><a href="https://blitiri.com.ar/p/chasquid" target="_blank">chasquid</a> - 用 Go 编写的 SMTP 服务器。</li><li data-pid="GbCozn3u"><a href="https://github.com/aymerick/douceur" target="_blank">douceur</a> - 用于 HTML 电子邮件的 CSS 内联器。</li><li data-pid="KXKKzYHa"><a href="https://github.com/jordan-wright/email" target="_blank">email</a> - 一个强大而灵活的 Go 电子邮件库。</li><li data-pid="J-QphY8e"><a href="https://github.com/AfterShip/email-verifier" target="_blank">email-verifier</a> - 用于电子邮件验证的 Go 库，无需发送任何电子邮件。</li><li data-pid="fTDeTv-x"><a href="https://github.com/toorop/go-dkim" target="_blank">go-dkim</a> - DKIM 库，用于签署和验证电子邮件。</li><li data-pid="LIoTkyJG"><a href="https://github.com/dimuska139/go-email-normalizer" target="_blank">go-email-normalizer</a> - 用于提供电子邮件地址规范表示的 Golang 库。</li><li data-pid="UC3SxuYU"><a href="https://github.com/go-email-validator/go-email-validator" target="_blank">go-email-validator</a> - 用于语法、一次性、smtp 等...检查的模块化电子邮件验证器。</li><li data-pid="A5KjPj2u"><a href="https://github.com/emersion/go-imap" target="_blank">go-imap</a> - 用于客户端和服务器的 IMAP 库。</li><li data-pid="xK35ErsF"><a href="https://github.com/wneessen/go-mail" target="_blank">go-mail</a> - 一个简单的 Go 库，用于在 Go 中发送邮件。</li><li data-pid="7eUt3Dmi"><a href="https://github.com/emersion/go-message" target="_blank">go-message</a> - 用于 Internet 消息格式和邮件消息的流媒体库。</li><li data-pid="eBqMH1_S"><a href="https://github.com/vanng822/go-premailer" target="_blank">go-premailer</a> -Go 中 HTML 邮件的内联样式。</li><li data-pid="G2AsmwCB"><a href="https://github.com/xhit/go-simple-mail" target="_blank">go-simple-mail</a> - 非常简单的包，用于发送带有 SMTP Keep Alive 和两个超时的电子邮件：连接和发送。</li><li data-pid="ItVkYTkl"><a href="https://github.com/hectane/hectane" target="_blank">Hectane</a> - 提供 HTTP API 的轻量级 SMTP 客户端.</li><li data-pid="GTQ21gRc"><a href="https://github.com/matcornic/hermes" target="_blank">hermes</a> - 生成干净、响应迅速的 HTML 电子邮件的 Golang 包。</li><li data-pid="eFyY-3Rf"><a href="https://github.com/mailchain/mailchain" target="_blank">mailchain</a> - 将加密的电子邮件发送到用 Go 编写的区块链地址。</li><li data-pid="KeYQItwM"><a href="https://github.com/mailgun/mailgun-go" target="_blank">mailgun-go</a> - 用于使用 Mailgun API 发送邮件的 Go 库。</li><li data-pid="lc2a4gAA"><a href="https://github.com/mailhog/MailHog" target="_blank">MailHog</a> - 使用 Web 和 API 接口进行电子邮件和 SMTP 测试。</li><li data-pid="35MvwkKz"><a href="https://github.com/axllent/mailpit" target="_blank">Mailpit</a> - 面向开发人员的电子邮件和 SMTP 测试工具。</li><li data-pid="wihzENZ-"><a href="https://github.com/valord577/mailx" target="_blank">mailx</a> - Mailx 是一个库，可以更轻松地通过 SMTP 发送电子邮件. 它是 golang 标准库的增强版<code>net/smtp</code>。</li><li data-pid="jBCE2gbE"><a href="https://github.com/sendgrid/sendgrid-go" target="_blank">SendGrid</a> -SendGrid 用于发送电子邮件的 Go 库。</li><li data-pid="a4sJwyfS"><a href="https://github.com/mailhog/smtp" target="_blank">smtp</a> - SMTP 服务器协议状态机。</li><li data-pid="q8MwJio1"><a href="https://github.com/mocktools/go-smtp-mock" target="_blank">smtpmock</a> - 轻量级可配置多线程假 SMTP 服务器。为您的测试环境模仿任何 SMTP 行为。</li><li data-pid="Imfvtv38"><a href="https://github.com/truemail-rb/truemail-go" target="_blank">truemail-go</a> - 可配置的 Golang 电子邮件验证器/验证器。通过 Regex、DNS、SMTP 等验证电子邮件。</li></ul><p data-pid="uRQTbiWQ"><b><a href="https://github.com/avelino/awesome-go/blob/main/README.md#contents" target="_blank">⬆回到顶部</a></b></p><h2><b>嵌入式脚本语言</b></h2><p data-pid="Vhifi3wg"><i>在你的代码中嵌入其他语言。</i></p><ul><li data-pid="a87aoAsP"><a href="https://github.com/mattn/anko" target="_blank">anko</a> - 用 Go 编写的脚本解释器。</li><li data-pid="V9fzV6YB"><a href="https://github.com/alexeyco/binder" target="_blank">binder</a> - 转到基于<a href="https://github.com/yuin/gopher-lua" target="_blank">gopher-lua</a>的 Lua 绑定库。</li><li data-pid="Ncbyn7uW"><a href="https://github.com/google/cel-go" target="_blank">cel-go</a> - 快速、便携、非图灵完整的表达式评估，逐步打字。</li><li data-pid="_whUC6vb"><a href="https://github.com/krotik/ecal" target="_blank">ecal</a> - 一种支持并发事件处理的简单可嵌入脚本语言。</li><li data-pid="Y3eeX_wy"><a href="https://github.com/antonmedv/expr" target="_blank">expr</a> -Go 的表达式评估引擎：快速、非图灵完备、动态类型、静态类型。</li><li data-pid="dLyDYGTV"><a href="https://github.com/gentee/gentee" target="_blank">gentee</a> - 可嵌入的脚本编程语言。</li><li data-pid="jC1qZFxn"><a href="https://github.com/jcla1/gisp" target="_blank">gisp</a> -Go 中的简单 LISP.</li><li data-pid="sjTCZ5gf"><a href="https://github.com/olebedev/go-duktape" target="_blank">go-duktape</a> -Go 的 Duktape JavaScript 引擎绑定.</li><li data-pid="XVx_eZGD"><a href="https://github.com/Shopify/go-lua" target="_blank">go-lua</a> - 将 Lua 5.2 VM 移植到纯 Go。</li><li data-pid="Ua8qAz5p"><a href="https://github.com/deuill/go-php" target="_blank">go-php</a> -Go 的 PHP 绑定。</li><li data-pid="TLjNdJmH"><a href="https://github.com/sbinet/go-python" target="_blank">go-python</a> - 天真的去绑定到 CPython C-API。</li><li data-pid="O_eho_VF"><a href="https://github.com/dop251/goja" target="_blank">goja</a> -Go 中的 ECMAScript 5.1(+) 实现.</li><li data-pid="morp-s72"><a href="https://github.com/aarzilli/golua" target="_blank">golua</a> - Lua C API 的 Go 绑定。</li><li data-pid="NkKhP1Jy"><a href="https://github.com/yuin/gopher-lua" target="_blank">gopher-lua</a> - 用 Go 编写的 Lua 5.1 VM 和编译器。</li><li data-pid="LWBCn6Ea"><a href="https://github.com/PaesslerAG/gval" target="_blank">gval</a> - 用 Go 编写的高度可定制的表达式语言。</li><li data-pid="qB9jH2-4"><a href="https://github.com/metacall/core" target="_blank">metacall</a> - 支持 NodeJS、JavaScript、TypeScript、Python、Ruby、C#、WebAssembly、Java、Cobol 等的跨平台多语言运行时。</li><li data-pid="b3nfe-K8"><a href="https://github.com/db47h/ngaro" target="_blank">ngaro</a> - 可嵌入的 Ngaro VM 实现在 Retro 中启用脚本。</li><li data-pid="yo0kXJ6d"><a href="https://github.com/ichiban/prolog" target="_blank">prolog</a> - 可嵌入的 Prolog。</li><li data-pid="2vIzjd7h"><a href="https://github.com/ian-kent/purl" target="_blank">purl</a> -Go 中嵌入的 Perl 5.18.2.</li><li data-pid="_HMeuotX"><a href="https://github.com/google/starlark-go" target="_blank">starlark-go</a> - Starlark 的 Go 实现：具有确定性评估和密封执行的类 Python 语言。</li><li data-pid="-rfwQNaf"><a href="https://github.com/d5/tengo" target="_blank">tengo</a> - 用于 Go 的字节码编译脚本语言。</li></ul><p data-pid="CYouMf-0"><b><a href="https://github.com/avelino/awesome-go/blob/main/README.md#contents" target="_blank">⬆回到顶部</a></b></p><h2><b>错误处理</b></h2><p data-pid="yXvk2rEK"><i>用于处理错误的库。</i></p><ul><li data-pid="-ZA7wxWC"><a href="https://github.com/emperror/emperror" target="_blank">emperror</a> - Go 库和应用程序的错误处理工具和最佳实践。</li><li data-pid="xhsujOAR"><a href="https://github.com/rotisserie/eris" target="_blank">eris</a> - 在 Go 中处理、跟踪和记录错误的更好方法。与标准错误库和 github.com/pkg/errors 兼容。</li><li data-pid="CW1NOV3u"><a href="https://github.com/snwfdhmp/errlog" target="_blank">errlog</a> - 可破解的包，用于确定错误的源代码（以及其他一些快速调试功能）。可就地插入任何记录器。</li><li data-pid="KblSpDoD"><a href="https://github.com/emperror/errors" target="_blank">errors</a> - 标准库错误包和 github.com/pkg/errors 的直接替换。提供各种错误处理原语。</li><li data-pid="_lTMn2Fr"><a href="https://github.com/pkg/errors" target="_blank">errors</a> - 提供简单错误处理原语的包。</li><li data-pid="KaUAi-92"><a href="https://github.com/neuronlabs/errors" target="_blank">errors</a> - 使用分类原语进行简单的 golang 错误处理。</li><li data-pid="5MFM0okk"><a href="https://github.com/PumpkinSeed/errors" target="_blank">errors</a> - 最简单的错误包装器，具有出色的性能和最小的内存开销。</li><li data-pid="IFF3e5yS"><a href="https://github.com/bnkamalesh/errors" target="_blank">errors</a> - 内置 Go 错误的直接替换。这是一个最小的错误处理包，具有自定义错误类型、用户友好消息、Unwrap &amp; Is。具有非常易于使用和直接的辅助功能。</li><li data-pid="Da_WRxWB"><a href="https://github.com/cockroachdb/errors" target="_blank">errors</a> - 通过网络进行错误移植的 Go 错误库。</li><li data-pid="Qd54BAMY"><a href="https://github.com/joomcode/errorx" target="_blank">errorx</a> - 一个功能丰富的错误包，包含堆栈跟踪、错误组合等。</li><li data-pid="2HFDAH9A"><a href="https://github.com/rbrahul/exception" target="_blank">exception</a> - 一个简单的实用程序包，用于在 Golang 中使用 try-catch 进行异常处理。</li><li data-pid="4XlhMK5C"><a href="https://github.com/SonicRoshan/falcon" target="_blank">Falcon</a> - 一个简单但功能强大的错误处理包。</li><li data-pid="XcpEx6pa"><a href="https://github.com/Southclaws/fault" target="_blank">Fault</a> - 一种用于包装错误的符合人体工程学的机制，以促进错误值的结构化元数据和上下文。</li><li data-pid="SxVXaflz"><a href="https://github.com/hashicorp/go-multierror" target="_blank">go-multierror</a> - Go (golang) 包，用于将错误列表表示为单个错误。</li><li data-pid="z9H-G8P3"><a href="https://github.com/ztrue/tracerr" target="_blank">tracerr</a> - 堆栈跟踪和源代码片段的 Golang 错误。</li></ul><p data-pid="QP8OavkI"><b><a href="https://github.com/avelino/awesome-go/blob/main/README.md#contents" target="_blank">⬆回到顶部</a></b></p><h2><b>文件处理</b></h2><p data-pid="zY_mFJ0W"><i>用于处理文件和文件系统的库。</i></p><ul><li data-pid="ZwBvzykS"><a href="https://github.com/spf13/afero" target="_blank">afero</a> -Go 的文件系统抽象系统。</li><li data-pid="_fnIGRTm"><a href="https://github.com/viant/afs" target="_blank">afs</a> -Go 的抽象文件存储（mem、scp、zip、tar、cloud：s3、gs）。</li><li data-pid="IIZbaNZp"><a href="https://github.com/xis/baraka" target="_blank">baraka</a> - 一个轻松处理 http 文件上传的库。</li><li data-pid="zL_OY5xq"><a href="https://github.com/bigfile/bigfile" target="_blank">bigfile</a> - 文件传输系统，支持使用 http api、rpc 调用和 ftp 客户端管理文件。</li><li data-pid="1ZCvG3gG"><a href="https://github.com/codingsince1985/checksum" target="_blank">校验和</a>- 为大文件计算消息摘要，如 MD5、SHA256、SHA1、CRC 或 BLAKE2s。</li><li data-pid="5LjpuXQV"><a href="https://github.com/otiai10/copy" target="_blank">copy</a> - 递归复制目录。</li><li data-pid="wikCsNSm"><a href="https://github.com/homedepot/flop" target="_blank">flop</a> - 旨在与<a href="https://www.gnu.org/software/coreutils/manual/html_node/cp-invocation.html" target="_blank">GNU cp</a>镜像功能奇偶校验的文件操作库。</li><li data-pid="cHBZiQY-"><a href="https://github.com/dundee/gdu" target="_blank">gdu</a> - 带有控制台界面的磁盘使用分析器。</li><li data-pid="BXGkkOGj"><a href="https://github.com/artonge/go-csv-tag" target="_blank">go-csv-tag</a> - 使用标签加载 csv 文件。</li><li data-pid="79hjW2ay"><a href="https://github.com/hugocarreira/go-decent-copy" target="_blank">go-decent-copy</a> - 为人类复制文件。</li><li data-pid="SIHEQBkP"><a href="https://github.com/barasher/go-exiftool" target="_blank">go-exiftool</a> - ExifTool 的 Go 绑定，这是一个著名的库，用于从文件（图片、PDF、office 等）中提取尽可能多的元数据（EXIF、IPTC 等）。</li><li data-pid="7dCUZOFa"><a href="https://github.com/artonge/go-gtfs" target="_blank">go-gtfs</a> - 在 go 中加载 gtfs 文件。</li><li data-pid="VkNU5kG0"><a href="https://github.com/no-src/gofs" target="_blank">gofs</a> - 开箱即用的文件同步工具。</li><li data-pid="6ARVHqB3"><a href="https://github.com/1set/gut" target="_blank">gut/yos</a> - 简单可靠的文件操作包，如文件、目录和符号链接上的复制/移动/差异/列表。</li><li data-pid="CzF_02HH"><a href="https://github.com/dastoori/higgs" target="_blank">higgs</a> - 一个小型的跨平台 Go 库，用于隐藏/取消隐藏文件和目录。</li><li data-pid="AR8YiXPe"><a href="https://github.com/rjeczalik/notify" target="_blank">notify</a> - 具有简单 API 的文件系统事件通知库，类似于 os/signal。</li><li data-pid="tnd5VdNK"><a href="https://github.com/qmuntal/opc" target="_blank">opc</a> - 为 Go 加载开放打包约定 (OPC) 文件。</li><li data-pid="Vu8VUdGi"><a href="https://github.com/parsyl/parquet" target="_blank">parquet</a> - 读写<a href="https://parquet.apache.org/" target="_blank">parquet</a>文件。</li><li data-pid="1uidv81T"><a href="https://github.com/jonchun/pathtype" target="_blank">pathtype</a> - 将路径视为它们自己的类型而不是使用字符串。</li><li data-pid="9NC5RF0D"><a href="https://github.com/pdfcpu/pdfcpu" target="_blank">pdfcpu</a> -PDF 处理器。</li><li data-pid="qKG5NnmJ"><a href="https://github.com/dixonwille/skywalker" target="_blank">skywalker</a> - 允许一个人轻松地同时通过文件系统的软件包。</li><li data-pid="Gfe59FAp"><a href="https://gitlab.com/russoj88/stl" target="_blank">stl</a> - 用于读取和写入 STL（立体光刻）文件的模块。读取并发算法。</li><li data-pid="O0dRrFVz"><a href="https://github.com/posener/tarfs" target="_blank">tarfs</a> - tar 文件<code><a href="h&lt;/code&gt;ttps://godoc.org/github.com/kr/fs#FileSystem">FileSystem接口</a>的实现。</code></li><li data-pid="NGpnhxQx"><a href="https://github.com/1set/todotxt" target="_blank">todotxt</a> - Gina Trapani 的<i><a href="http://todotxt.org/" target="_blank">todo.txt</a></i>文件的 Go 库，支持解析和操作<i><a href="&lt;/i">"https://github.com/todotxt/todo.txt"&gt;todo.txt格式</a>的任务列表。</i></li><li data-pid="Vu3mKUlC"><a href="https://github.com/C2FO/vfs" target="_blank">vfs</a> - 适用于 Go 的一组可插入、可扩展和固定的文件系统功能，适用于多种文件系统类型，例如 os、S3 和 GCS。</li></ul><p data-pid="4fzu2CM9"><b><a href="https://github.com/avelino/awesome-go/blob/main/README.md#contents" target="_blank">⬆回到顶部</a></b></p><h2><b>金融的</b></h2><p data-pid="1quZz411"><i>会计和财务软件包。</i></p><ul><li data-pid="M8Fsa18Y"><a href="https://github.com/leekchan/accounting" target="_blank">accounting</a> - golang 的货币和货币格式。</li><li data-pid="pIv6uefP"><a href="https://github.com/moov-io/ach" target="_blank">ach</a> - 自动清算所 (ACH) 文件的读取器、写入器和验证器。</li><li data-pid="Vbroe1Ia"><a href="https://github.com/c9s/bbgo" target="_blank">bbgo</a> - 用 Go 编写的加密货币交易机器人框架。包括常见的加密货币交易所 API、标准指标、回溯测试和许多内置策略。</li><li data-pid="7ti2wdnG"><a href="https://github.com/bojanz/currency" target="_blank">currency</a> - 处理货币金额，提供货币信息和格式。</li><li data-pid="0S-nDMyM"><a href="https://github.com/bnkamalesh/currency" target="_blank">currency</a> - 高性能和准确的货币计算包。</li><li data-pid="Xjbwzc_A"><a href="https://github.com/shopspring/decimal" target="_blank">decimal</a> - 任意精度定点十进制数。</li><li data-pid="bbwHs5xt"><a href="https://github.com/nikolaydubina/fpdecimal" target="_blank">fpdecimal</a> - 小定点小数的快速和精确的序列化和算术</li><li data-pid="CjCdOkS3"><a href="https://github.com/nikolaydubina/fpmoney" target="_blank">fpmoney</a> - 快速简单的 ISO4217 定点十进制货币。</li><li data-pid="20-I-ewN"><a href="https://github.com/alpeb/go-finance" target="_blank">go-finance</a> - 货币时间价值（年金）、现金流、利率转换、债券和折旧计算的金融函数库。</li><li data-pid="KQwnADtR"><a href="https://github.com/pieterclaerhout/go-finance" target="_blank">go-finance</a> - 用于获取汇率、通过 VIES 检查增值税号和检查 IBAN 银行帐号的模块。</li><li data-pid="mCwHC4d1"><a href="https://github.com/m1/go-finnhub" target="_blank">go-finnhub</a> - 来自 finnhub.io 的股票市场、外汇和加密数据的客户端。从 60 多家证券交易所、10 家外汇经纪商和 15 多家加密货币交易所访问实时金融市场数据。</li><li data-pid="504i9DSu"><a href="https://github.com/rhymond/go-money" target="_blank">go-money</a> - 福勒货币模式的实施。</li><li data-pid="iy01zYvu"><a href="https://github.com/aclindsa/ofxgo" target="_blank">ofxgo</a> - 查询 OFX 服务器和/或解析响应（使用示例命令行客户端）。</li><li data-pid="PZeVmG2H"><a href="https://github.com/i25959341/orderbook" target="_blank">orderbook</a> -Golang 中的限价订单簿匹配引擎。</li><li data-pid="UZshzyQf"><a href="https://github.com/jovandeginste/payme" target="_blank">payme</a> - 用于 SEPA 付款的 QR 码生成器（ASCII 和 PNG）。</li><li data-pid="oKMCbUXa"><a href="https://github.com/BoltApp/sleet" target="_blank">sleet</a> - 多个支付服务提供商 (PsP) 处理在线支付的统一界面。</li><li data-pid="PrGbMRJb"><a href="https://github.com/sdcoffey/techan" target="_blank">techan</a> - 具有高级市场分析和交易策略的技术分析库。</li><li data-pid="xWj6isry"><a href="https://github.com/achannarasappa/ticker" target="_blank">ticker</a> - 终端股票观察者和股票头寸跟踪器。</li><li data-pid="8F8md9Nw"><a href="https://github.com/claygod/transaction" target="_blank">transaction</a> - 嵌入式账户交易数据库，以多线程模式运行。</li><li data-pid="1qlj8B42"><a href="https://github.com/dannyvankooten/vat" target="_blank">增值税</a>- 增值税号验证和欧盟增值税税率。</li></ul><p data-pid="VYLS34XM"><b><a href="https://github.com/avelino/awesome-go/blob/main/README.md#contents" target="_blank">⬆回到顶部</a></b></p><h2><b>形式</b></h2><p data-pid="sM0RvyV2"><i>用于处理表单的库。</i></p><ul><li data-pid="Sxu3ITSG"><a href="https://github.com/robfig/bind" target="_blank">bind</a> - 将表单数据绑定到任何 Go 值。</li><li data-pid="4IrGiWld"><a href="https://github.com/mholt/binding" target="_blank">绑定</a>- 将来自 net/http 请求的表单和 JSON 数据绑定到结构。</li><li data-pid="vc7qbg13"><a href="https://github.com/leebenson/conform" target="_blank">conform</a> - 检查用户输入。根据结构标签修剪、清理和清理数据。</li><li data-pid="AM0766SA"><a href="https://github.com/go-playground/form" target="_blank">form</a> - 将 url.Values 解码为 Go 值并将 Go 值编码为 url.Values。双阵列和全地图支持。</li><li data-pid="6nBkMGpU"><a href="https://github.com/monoculum/formam" target="_blank">formam</a> - 将表单的值解码为结构。</li><li data-pid="ylUg8C-_"><a href="https://github.com/albrow/forms" target="_blank">forms</a> - 与框架无关的库，用于解析和验证支持多部分表单和文件的表单/JSON 数据。</li><li data-pid="g7c1NbJc"><a href="https://github.com/bdjimmy/gbind" target="_blank">gbind</a> - 将数据绑定到任何 Go 值。可以使用内置和自定义表达式绑定功能；支持数据校验</li><li data-pid="7h3xGEnx"><a href="https://github.com/gorilla/csrf" target="_blank">gorilla/csrf</a> -Go web 应用程序和服务的 CSRF 保护。</li><li data-pid="YhLRig-u"><a href="https://github.com/ggicci/httpin" target="_blank">httpin</a> - 将 HTTP 请求解码为自定义结构，包括查询字符串、表单、HTTP 标头等。</li><li data-pid="XPnmZZlp"><a href="https://github.com/justinas/nosurf" target="_blank">nosurf</a> -Go 的 CSRF 保护中间件。</li><li data-pid="EKXDRAPT"><a href="https://github.com/sonh/qs" target="_blank">qs</a> - 用于将结构编码为 URL 查询参数的 Go 模块。</li><li data-pid="Z7CryLFY"><a href="https://github.com/tomwright/queryparam" target="_blank">queryparam</a> - 解码<code>url.Values</code>为标准或自定义类型的可用结构值。</li></ul><p data-pid="Wa6WuD_s"><b><a href="https://github.com/avelino/awesome-go/blob/main/README.md#contents" target="_blank">⬆回到顶部</a></b></p><h2><b>功能性</b></h2><p data-pid="qxhjV40q"><i>支持 Go 中函数式编程的包。</i></p><ul><li data-pid="cz__YkeX"><a href="https://github.com/repeale/fp-go" target="_blank">fp-go</a> - 由 Golang 1.18+ 泛型提供支持的函数式编程助手集合。</li><li data-pid="aBlqRQ_r"><a href="https://github.com/TeaEntityLab/fpGo" target="_blank">fpGo</a> - Monad，Golang 的函数式编程功能。</li><li data-pid="Or2a76WY"><a href="https://github.com/seborama/fuego" target="_blank">fuego</a> -Go 中的功能实验。</li><li data-pid="L1QHsCm9"><a href="https://github.com/tobyhede/go-underscore" target="_blank">go-underscore</a> - 有用的 Go 集合实用程序的有用集合。</li><li data-pid="XCl98Lh5"><a href="https://github.com/rbrahul/gofp" target="_blank">gofp</a> - 类似 lodash 的强大 Golang 实用程序库。</li><li data-pid="mEfq5se-"><a href="https://github.com/samber/mo" target="_blank">mo</a> - Monads 和流行的 FP 抽象，基于 Go 1.18+ Generics（Option，Result，Either ...）。</li><li data-pid="or30UC0j"><a href="https://github.com/rjNemo/underscore" target="_blank">underscore</a> -Go 1.18 及更高版本的函数式编程助手。</li><li data-pid="BVpY11KW"><a href="https://github.com/phelmkamp/valor" target="_blank">valor</a> - 可选地包含值的通用选项和结果类型。</li></ul><p data-pid="SbfIreLH"><b><a href="https://github.com/avelino/awesome-go/blob/main/README.md#contents" target="_blank">⬆回到顶部</a></b></p><h2><b>游戏开发</b></h2><p data-pid="4NmTd8mK"><i>很棒的游戏开发库。</i></p><ul><li data-pid="-1HFbwIR"><a href="https://github.com/azul3d/engine" target="_blank">Azul3D</a> - 用 Go 编写的 3D 游戏引擎。</li><li data-pid="_WCUS6VV"><a href="https://github.com/hajimehoshi/ebiten" target="_blank">Ebitengine</a> - Go 中非常简单的 2D 游戏引擎。</li><li data-pid="HtwZoSxF"><a href="https://github.com/EngoEngine/engo" target="_blank">engo</a> - Engo 是一个用 Go 编写的开源 2D 游戏引擎。它遵循实体-组件-系统范式。</li><li data-pid="cfP53MYA"><a href="https://github.com/s0rg/fantasyname" target="_blank">fantasyname</a> - 幻想名称生成器。</li><li data-pid="EIZJ4jtV"><a href="https://github.com/g3n/engine" target="_blank">g3n</a> - Go 3D 游戏引擎。</li><li data-pid="HMkyPKzr"><a href="https://github.com/beefsack/go-astar" target="_blank">go-astar</a> -A * 路径查找算法的 Go 实现。</li><li data-pid="1tTcamAs"><a href="https://github.com/veandco/go-sdl2" target="_blank">go-sdl2</a> -<a href="https://www.libsdl.org/" target="_blank">简单 DirectMedia 层</a>的 Go 绑定。</li><li data-pid="loqB7ku-"><a href="https://github.com/ungerik/go3d" target="_blank">go3d</a> - 用于 Go 的面向性能的 2D/3D 数学包。</li><li data-pid="YfdBm4Yu"><a href="https://github.com/xtaci/gonet" target="_blank">gonet</a> - 使用 golang 实现的游戏服务器框架。</li><li data-pid="LZnCWeQv"><a href="https://github.com/xiaonanln/goworld" target="_blank">goworld</a> - 可扩展的游戏服务器引擎，具有空间实体框架和热插拔。</li><li data-pid="3jBhhXXS"><a href="https://github.com/harfang3d/harfang3d" target="_blank">Harfang3D</a> - Go 语言的 3D 引擎，适用于 Windows 和 Linux（<a href="https://github.com/harfang3d/harfang-go" target="_blank">Go.dev 上的 Harfang</a>）。</li><li data-pid="54OR94j3"><a href="https://github.com/name5566/leaf" target="_blank">Leaf</a> - 轻量级游戏服务器框架。</li><li data-pid="ayjlLjMg"><a href="https://github.com/lonng/nano" target="_blank">nano</a> - 轻量级、设施化、高性能的基于 golang 的游戏服务器框架。</li><li data-pid="JKpDPGJJ"><a href="https://github.com/oakmound/oak" target="_blank">Oak</a> - 纯围棋游戏引擎。</li><li data-pid="eQ03vrhT"><a href="https://github.com/topfreegames/pitaya" target="_blank">Pitaya</a> - 可扩展的游戏服务器框架，通过 C SDK 为 iOS、Android、Unity 等提供集群支持和客户端库。</li><li data-pid="6u7RqQhT"><a href="https://github.com/faiface/pixel" target="_blank">Pixel</a> -Go 中手工制作的 2D 游戏库.</li><li data-pid="LH-0zlR8"><a href="https://github.com/gonutz/prototype" target="_blank">prototype</a> - 跨平台（Windows/Linux/Mac）库，用于使用最少的 API 创建桌面游戏。</li><li data-pid="U94h3nbb"><a href="https://github.com/gen2brain/raylib-go" target="_blank">raylib-go - </a><a href="https://www.raylib.com/" target="_blank">raylib</a>的 Go 绑定，这是一个简单易用的库，用于学习视频游戏编程。</li><li data-pid="xW6nxzV0"><a href="https://github.com/JoelOtter/termloop" target="_blank">termloop</a> - 基于终端的围棋游戏引擎，建立在 Termbox 之上。</li><li data-pid="EpfY-dw8"><a href="https://github.com/kelindar/tile" target="_blank">tile</a> - 面向数据且缓存友好的 2D 网格库 (TileMap)，包括寻路、观察者和导入/导出。</li></ul><p data-pid="CHtL_hhF"><b><a href="https://github.com/avelino/awesome-go/blob/main/README.md#contents" target="_blank">⬆回到顶部</a></b></p><h2><b>发电机</b></h2><p data-pid="ADw-LvQH"><i>生成 Go 代码的工具。</i></p><ul><li data-pid="-_focyaQ"><a href="https://github.com/reedom/convergen" target="_blank">convergen</a> - 功能丰富的类型到类型的复制代码生成器。</li><li data-pid="q8B1Jxiz"><a href="https://github.com/switchupcb/copygen" target="_blank">copygen</a> - 无需反射即可生成类型到类型和基于类型的代码。</li><li data-pid="97lmug2p"><a href="https://github.com/senselogic/GENERIS" target="_blank">generis</a> - 提供泛型、自由格式宏、条件编译和 HTML 模板的代码生成工具。</li><li data-pid="CzM5Rf7B"><a href="https://github.com/abice/go-enum" target="_blank">go-enum</a> - 从代码注释中为枚举生成代码。</li><li data-pid="YECdTcO1"><a href="https://github.com/ahmetalpbalkan/go-linq" target="_blank">go-linq</a> - 用于 Go 的类似于 .NET LINQ 的查询方法。</li><li data-pid="-MViIDrf"><a href="https://github.com/awalterschulze/goderive" target="_blank">goderive</a> - 从输入类型派生函数。</li><li data-pid="UtARMZfM"><a href="https://github.com/wzshiming/gotype" target="_blank">gotype</a> - Golang 源代码解析，用法类似于 reflect 包。</li><li data-pid="woUwqUP7"><a href="https://github.com/jmattheis/goverter" target="_blank">goverter</a> - 通过定义接口生成转换器。</li><li data-pid="zrnVFdFT"><a href="https://github.com/hexdigest/gowrap" target="_blank">GoWrap</a> - 使用简单模板为 Go 接口生成装饰器。</li><li data-pid="NpfASYGL"><a href="https://github.com/rjeczalik/interfaces" target="_blank">interfaces</a> - 用于生成接口定义的命令行工具。</li><li data-pid="ny3BMWhF"><a href="https://github.com/dave/jennifer" target="_blank">jennifer</a> - 生成没有模板的任意 Go 代码。</li><li data-pid="lwaLr07e"><a href="https://github.com/xiaoxin01/typeregistry" target="_blank">typeregistry</a> - 动态创建类型的库。</li></ul><p data-pid="IwG5zFx_"><b><a href="https://github.com/avelino/awesome-go/blob/main/README.md#contents" target="_blank">⬆回到顶部</a></b></p><h2><b>地理的</b></h2><p data-pid="yUTjlYaN"><i>地理工具和服务器</i></p><ul><li data-pid="wOewxON_"><a href="https://github.com/hishamkaram/geoserver" target="_blank">geoserver</a> -geoserver 是一个用于通过 GeoServer REST API 操作 GeoServer 实例的 Go 包。</li><li data-pid="HTGu8lr9"><a href="https://github.com/hishamkaram/gismanager" target="_blank">gismanager</a> - 将您的 GIS 数据（矢量数据）发布到 PostGIS 和 Geoserver。</li><li data-pid="TMxB-XSC"><a href="https://github.com/airbusgeo/godal" target="_blank">godal</a> -GDAL 的包装器。</li><li data-pid="U5v9lvoY"><a href="https://github.com/uber/h3-go" target="_blank">H3</a> - 用于 H3 的 Go 绑定，H3 是一个分层的六边形地理空间索引系统。</li><li data-pid="-JdzEGiY"><a href="https://github.com/mmadfox/go-geojson2h3" target="_blank">H3 GeoJSON</a> - H3 索引和 GeoJSON 之间的转换实用程序。</li><li data-pid="oJnCmboh"><a href="https://github.com/mmadfox/go-h3geo-dist" target="_blank">H3GeoDist</a> - 按虚拟节点分布 Uber H3geo 单元。</li><li data-pid="qnDsy-_k"><a href="https://github.com/consbio/mbtileserver" target="_blank">mbtileserver</a> - 一个简单的基于 Go 的服务器，用于以 mbtiles 格式存储的地图图块。</li><li data-pid="wQ02rlgM"><a href="https://github.com/paulmach/osm" target="_blank">osm</a> - 用于读取、写入和使用 OpenStreetMap 数据和 API 的库。</li><li data-pid="eenn0fWJ"><a href="https://github.com/maguro/pbf" target="_blank">pbf</a> -OpenStreetMap PBF golang 编码器/解码器。</li><li data-pid="ljT-2TIJ"><a href="https://github.com/pantrif/s2-geojson" target="_blank">S2 geojson</a> - 将 geojson 转换为 s2 单元格并在地图上演示一些 S2 几何特征。</li><li data-pid="rY0efXuo"><a href="https://github.com/golang/geo" target="_blank">S2 geometry</a> -Go 中的 S2 几何库.</li><li data-pid="ZaNee2T0"><a href="https://github.com/peterstace/simplefeatures" target="_blank">simplefeatures</a> - simplesfeatures 是一个 2D 几何库，它提供了对几何建模的 Go 类型，以及对它们进行操作的算法。</li><li data-pid="ic5sNMaP"><a href="https://github.com/tidwall/tile38" target="_blank">Tile38</a> - 具有空间索引和实时地理围栏的地理定位数据库。</li><li data-pid="-jq5oeKg"><a href="https://github.com/jorelosorio/web-mercator-projection" target="_blank">Web-Mercator-Projection</a>一个使用 Web Mercator Projection 在地图中轻松使用和转换 LonLat、Point 和 Tile 以显示信息、标记等的项目。</li><li data-pid="e_pI1K_0"><a href="https://github.com/wroge/wgs84" target="_blank">WGS84</a> - 坐标转换和转换库（ETRS89、OSGB36、NAD83、RGF93、Web Mercator、UTM）。</li></ul><p data-pid="wRMiZZ5I"><b><a href="https://github.com/avelino/awesome-go/blob/main/README.md#contents" target="_blank">⬆回到顶部</a></b></p><h2><b>编译器</b></h2><p data-pid="mj9bs_VK"><i>将 Go 编译为其他语言的工具。</i></p><ul><li data-pid="0lNKTUjE"><a href="https://github.com/goplus/c2go" target="_blank">c2go</a> - 将 C 代码转换为 Go 代码。</li><li data-pid="UQp-ehxn"><a href="https://github.com/Konstantin8105/c4go" target="_blank">c4go</a> - 将 C 代码转换为 Go 代码。</li><li data-pid="kw6tmAvV"><a href="https://github.com/andygeiss/esp32-transpiler" target="_blank">esp32</a> - Transpile 进入 Arduino 代码。</li><li data-pid="WNDz8NCv"><a href="https://github.com/Konstantin8105/f4go" target="_blank">f4go</a> - 将 FORTRAN 77 代码转换为 Go 代码。</li><li data-pid="iJYaWl17"><a href="https://github.com/gopherjs/gopherjs" target="_blank">gopherjs</a> - 从 Go 到 JavaScript 的编译器。</li><li data-pid="MX2wNFU6"><a href="https://github.com/tardisgo/tardisgo" target="_blank">tardisgo</a> -Golang 到 Haxe 到 CPP/CSharp/Java/JavaScript 转译器。</li></ul><p data-pid="ZZ1MtKUz"><b><a href="https://github.com/avelino/awesome-go/blob/main/README.md#contents" target="_blank">⬆回到顶部</a></b></p><h2><b>协程</b></h2><p data-pid="EvY-BHm3"><i>用于管理和使用 Goroutines 的工具。</i></p><ul><li data-pid="WT-BbehF"><a href="https://github.com/panjf2000/ants" target="_blank">ants</a> - Go 中的高性能和低成本 goroutine 池。</li><li data-pid="-9ffh3P4"><a href="https://github.com/borderstech/artifex" target="_blank">artifex</a> - 使用基于工作人员的调度的 Golang 简单内存作业队列。</li><li data-pid="r3CHQNhg"><a href="https://github.com/reugn/async" target="_blank">async</a> -Go 的替代同步库（Future、Promise、Locks）。</li><li data-pid="0cZbZVW1"><a href="https://github.com/studiosol/async" target="_blank">async</a> - 一种安全的异步执行函数的方法，在出现 panic 时恢复它们。</li><li data-pid="3LTuhsZJ"><a href="https://github.com/lab210-dev/async-job" target="_blank">async-job</a> -AsyncJob 是一个异步队列作业管理器，代码轻，清晰，速度快。</li><li data-pid="COCz_Hka"><a href="https://github.com/kamilsk/breaker" target="_blank">breaker</a> - 使执行流程可中断的灵活机制。</li><li data-pid="VCj5qj1J"><a href="https://github.com/ddelizia/channelify" target="_blank">channelify</a> - 将您的函数转换为返回通道以实现简单而强大的并行处理。</li><li data-pid="5jdOVgp0"><a href="https://github.com/sourcegraph/conc" target="_blank">conc</a> -<code>conc</code>是您在 go 中进行结构化并发的工具带，使常见任务更容易、更安全。</li><li data-pid="v1El4xIX"><a href="https://github.com/vivek-ng/concurrency-limiter" target="_blank">concurrency-limiter</a> - 并发限制器，支持 goroutine 的超时、动态优先级和上下文取消。</li><li data-pid="prgBRp7-"><a href="https://github.com/ITcathyh/conexec" target="_blank">conexec</a> - 一个并发工具包，可帮助以高效和安全的方式并发执行函数。支持指定整体超时时间避免阻塞，使用goroutine pool提高效率。</li><li data-pid="1vsOiQia"><a href="https://github.com/marusama/cyclicbarrier" target="_blank">cyclicbarrier</a> -golang 的 CyclicBarrier.</li><li data-pid="IJTvkGPT"><a href="https://github.com/hexdigest/execpool" target="_blank">execpool</a> - 一个围绕 exec.Cmd 构建的池，它预先启动给定数量的进程，并在需要时将 stdin 和 stdout 附加到它们。与 FastCGI 或 Apache Prefork MPM 非常相似，但适用于任何命令。</li><li data-pid="q2KmMQpN"><a href="https://github.com/vladopajic/go-actor" target="_blank">go-actor</a> - 一个使用 actor 模型编写并发程序的小型库。</li><li data-pid="hN1VqIBa"><a href="https://github.com/workanator/go-floc" target="_blank">go-floc</a> - 轻松编排 goroutines。</li><li data-pid="OkFFfRDa"><a href="https://github.com/kamildrazkiewicz/go-flow" target="_blank">go-flow</a> - 控制 goroutines 执行顺序。</li><li data-pid="uUx2-3cV"><a href="https://github.com/nikhilsaraf/go-tools" target="_blank">go-tools/multithreading</a> - 使用这个带有简单 API 的轻量级库来管理 goroutines 池。</li><li data-pid="mQG_V3wq"><a href="https://github.com/subchen/go-trylock" target="_blank">go-trylock</a> - 对 Golang 的读写锁的 TryLock 支持。</li><li data-pid="UTyowvAB"><a href="https://github.com/pieterclaerhout/go-waitgroup" target="_blank">go-waitgroup</a> - 类似于<code>sync.WaitGroup</code>错误处理和并发控制。</li><li data-pid="hFStFDjm"><a href="https://github.com/zenthangplus/go-workerpool" target="_blank">go-workerpool</a> - 受 Java 线程池的启发，Go WorkerPool 旨在控制繁重的 Go Routines。</li><li data-pid="NYJqPWqF"><a href="https://github.com/catmullet/go-workers" target="_blank">go-workers</a> - 轻松安全地为大型数据处理管道运行工作人员。</li><li data-pid="uKNcxhQU"><a href="https://github.com/zenthangplus/goccm" target="_blank">goccm</a> - Go 并发管理器包限制允许并发运行的 goroutines 的数量。</li><li data-pid="EBWTXS07"><a href="https://github.com/loveleshsharma/gohive" target="_blank">gohive</a> - 用于 Go 的高性能且易于使用的 Goroutine 池。</li><li data-pid="O1N4lEDg"><a href="https://github.com/vardius/gollback" target="_blank">gollback</a> - 异步简单函数实用程序，用于管理闭包和回调的执行。</li><li data-pid="yENrWwUM"><a href="https://github.com/hamed-yousefi/gowl" target="_blank">gowl</a> - Gowl 是一个流程管理和流程监控工具。无限工作池使您能够控制池和进程并监视它们的状态。</li><li data-pid="GR2w5eC0"><a href="https://github.com/benmanns/goworker" target="_blank">goworker</a> -goworker 是一个基于 Go 的后台工作者。</li><li data-pid="ZejzXQFq"><a href="https://github.com/xxjwxc/gowp" target="_blank">gowp</a> - gowp 是并发限制 goroutine 池。</li><li data-pid="4NBXN5qB"><a href="https://github.com/Sherifabdlnaby/gpool" target="_blank">gpool</a> - 管理一个可调整大小的上下文感知 goroutines 池以绑定并发性。</li><li data-pid="vUHpI5Mx"><a href="https://github.com/ivpusic/grpool" target="_blank">grpool</a> - 轻量级 Goroutine 池。</li><li data-pid="0hBACmYy"><a href="https://github.com/duanckham/hands" target="_blank">hands</a> - 一个进程控制器，用于控制多个 goroutine 的执行和返回策略。</li><li data-pid="o5erxUW6"><a href="https://github.com/AaronJan/Hunch" target="_blank">Hunch</a><code>All</code> - Hunch 提供了、<code>First</code>、等功能，使异步流控制更加直观<code>Retry</code>。<code>Waterfall</code></li><li data-pid="eBqrbNCF"><a href="https://github.com/dirkaholic/kyoo" target="_blank">kyoo</a> - 提供无限的作业队列和并发工作池。</li><li data-pid="SexRulPo"><a href="https://github.com/neilotoole/errgroup" target="_blank">neilotoole/errgroup</a> - 的替代品<code>sync/errgroup</code>，仅限于 N 个 worker goroutines 池。</li><li data-pid="p5RAYPXd"><a href="https://github.com/arunsworld/nursery" target="_blank">nursery</a> -Go 中的结构化并发。</li><li data-pid="klGsT2nv"><a href="https://cirello.io/oversight" target="_blank">监督</a>- 监督是 Erlang 监督树的完整实现。</li><li data-pid="30gx5s48"><a href="https://github.com/rafaeljesus/parallel-fn" target="_blank">parallel-fn</a> - 并行运行函数。</li><li data-pid="TzlfuBVF"><a href="https://github.com/alitto/pond" target="_blank">pond</a> - 用 Go 编写的简约和高性能 goroutine 工作池。</li><li data-pid="Qs70bxkX"><a href="https://github.com/go-playground/pool" target="_blank">pool</a> - 有限的消费者 goroutine 或无限的 goroutine 池，以便于 goroutine 处理和取消。</li><li data-pid="YLU4ZfD7"><a href="https://github.com/AnikHasibul/queue" target="_blank">队列</a>- 为您提供<code>sync.WaitGroup</code>类似队列组的可访问性。帮助您节制和限制 goroutines，等待所有 goroutines 结束等等。</li><li data-pid="DSKrzT_t"><a href="https://github.com/timandy/routine" target="_blank">routine</a> -<code>routine</code>是一个<code>ThreadLocal</code>用于 go 的库。它封装并提供了一些易用、无竞争、高性能的<code>goroutine</code>上下文访问接口，可以帮助你更优雅地访问协程上下文信息。</li><li data-pid="XakBHpBk"><a href="https://github.com/x-mod/routine" target="_blank">例程</a>- 使用上下文进行例程控制，支持：Main、Go、Pool 和一些有用的执行器。</li><li data-pid="T0SdO51o"><a href="https://github.com/kamilsk/semaphore" target="_blank">semaphore</a> - 基于通道和上下文的锁定/解锁操作超时的信号量模式实现。</li><li data-pid="745B1v2S"><a href="https://github.com/marusama/semaphore" target="_blank">semaphore</a> - 基于 CAS 的快速可调整大小的信号量实现（比基于通道的信号量实现更快）。</li><li data-pid="DSIEMBWK"><a href="https://github.com/ssgreg/stl" target="_blank">stl</a> - 基于软件事务内存 (STM) 并发控制机制的软件事务锁。</li><li data-pid="DW8WSf7m"><a href="https://github.com/shettyh/threadpool" target="_blank">threadpool</a> -Golang 线程池实现。</li><li data-pid="vRXXWw9-"><a href="https://github.com/Jeffail/tunny" target="_blank">tunny</a> -golang 的 Goroutine 池。</li><li data-pid="D5wHArtr"><a href="https://github.com/vardius/worker-pool" target="_blank">worker-pool</a> -goworker 是一个简单的 Go 异步工作池。</li><li data-pid="kBal2DFa"><a href="https://github.com/gammazero/workerpool" target="_blank">workerpool</a> - Goroutine 池，它限制任务执行的并发性，而不是排队的任务数。</li></ul><p data-pid="kVARkoR9"><b><a href="https://github.com/avelino/awesome-go/blob/main/README.md#contents" target="_blank">⬆回到顶部</a></b></p><h2><b>图形用户界面</b></h2><p data-pid="dadXVNcx"><i>用于构建 GUI 应用程序的库。</i></p><p data-pid="T4PLEjxY"><i>工具包</i></p><ul><li data-pid="Fz0l9XCt"><a href="https://github.com/murlokswarm/app" target="_blank">app</a> - 使用 GO、HTML 和 CSS 创建应用程序的包。支持：MacOS，正在进行中的 Windows。</li><li data-pid="S4EP1PI8"><a href="https://github.com/fyne-io/fyne" target="_blank">fyne</a> - 基于 Material Design 为 Go 设计的跨平台原生 GUI。支持：Linux、macOS、Windows、BSD、iOS 和 Android。</li><li data-pid="uhq3q0Py"><a href="https://gioui.org/" target="_blank">gio</a> -Gio 是一个用于在 Go 中编写跨平台即时模式 GUI-s 的库。Gio 支持所有主要平台：Linux、macOS、Windows、Android、iOS、FreeBSD、OpenBSD 和 WebAssembly。</li><li data-pid="T8-eGzP2"><a href="https://github.com/asticode/go-astilectron" target="_blank">go-astilectron</a> - 使用 GO 和 HTML/JS/CSS（由 Electron 提供支持）构建跨平台 GUI 应用程序。</li><li data-pid="_rhKHqT5"><a href="https://mattn.github.io/go-gtk/" target="_blank">go-gtk</a> - GTK 的 Go 绑定。</li><li data-pid="l9RD9vb-"><a href="https://github.com/sciter-sdk/go-sciter" target="_blank">go-sciter -Sciter</a>的 Go 绑定：用于现代桌面 UI 开发的可嵌入 HTML/CSS/脚本引擎。跨平台。</li><li data-pid="Jre2_9_f"><a href="https://github.com/goradd/html5tag" target="_blank">goradd/html5tag</a> - 用于输出 HTML5 标签的库。</li><li data-pid="vGvtscxz"><a href="https://github.com/gotk3/gotk3" target="_blank">gotk3</a> - GTK3 的 Go 绑定。</li><li data-pid="6RFrcUuP"><a href="https://github.com/dtylman/gowd" target="_blank">gowd</a> - 使用 GO、HTML、CSS 和 NW.js 进行快速简单的桌面 UI 开发。跨平台。</li><li data-pid="N_ccFcH0"><a href="https://github.com/therecipe/qt" target="_blank">qt</a> -Go 的 Qt 绑定（支持 Windows / macOS / Linux / Android / iOS / Sailfish OS / Raspberry Pi）。</li><li data-pid="G1wdvqXN"><a href="https://github.com/andlabs/ui" target="_blank">ui</a> -Go 的平台原生 GUI 库。跨平台。</li><li data-pid="QfCIm5QY"><a href="https://wails.io/" target="_blank">Wails</a> - Mac、Windows、Linux 桌面应用程序，带有使用内置操作系统 HTML 渲染器的 HTML UI。</li><li data-pid="HFZg519s"><a href="https://github.com/lxn/walk" target="_blank">walk</a> -Go 的 Windows 应用程序库工具包。</li><li data-pid="sFfg2-v2"><a href="https://github.com/zserge/webview" target="_blank">webview</a> - 具有简单的双向 JavaScript 绑定（Windows / macOS / Linux）的跨平台 webview 窗口。</li></ul><p data-pid="USrDu4jz"><i>相互作用</i></p><ul><li data-pid="yKuuLCPa"><a href="https://github.com/gopherlibs/appindicator" target="_blank">AppIndicator Go</a> - libappindicator3 C 库的 Go 绑定。</li><li data-pid="mOe1k9T7"><a href="https://github.com/deckarep/gosx-notifier" target="_blank">gosx-notifier</a> -Go 的 OSX 桌面通知库。</li><li data-pid="GrcDsITR"><a href="https://github.com/prashantgupta24/activity-tracker" target="_blank">mac-activity-tracker</a> - OSX 库，用于通知您机器上的任何（可插入）活动。</li><li data-pid="P1yRp3gJ"><a href="https://github.com/prashantgupta24/mac-sleep-notifier" target="_blank">mac-sleep-notifier</a> -golang 中的 OSX 睡眠/唤醒通知.</li><li data-pid="Jn4XvI4k"><a href="https://github.com/go-vgo/robotgo" target="_blank">robotgo</a> - Go Native 跨平台 GUI 系统自动化。控制鼠标、键盘等。</li><li data-pid="thDBxj_Y"><a href="https://github.com/getlantern/systray" target="_blank">systray</a> - 跨平台 Go 库，用于在通知区域放置图标和菜单。</li><li data-pid="ewV5FzpA"><a href="https://github.com/shurcooL/trayhost" target="_blank">trayhost</a> - 跨平台 Go 库，用于在主机操作系统的任务栏中放置一个图标。</li><li data-pid="BeiterrE"><a href="https://github.com/ncruces/zenity" target="_blank">zenity</a> - 跨平台 Go 库和 CLI，用于创建与用户进行图形交互的简单对话框。</li></ul><p data-pid="7zSBSJrr"><b><a href="https://github.com/avelino/awesome-go/blob/main/README.md#contents" target="_blank">⬆回到顶部</a></b></p><h2><b>硬件</b></h2><p data-pid="m-PhI4wq"><i>用于与硬件交互的库、工具和教程。</i></p><ul><li data-pid="_mWWhXil"><a href="https://github.com/arduino/arduino-cli" target="_blank">arduino-cli</a> - 官方 Arduino CLI 和库。可以独立运行，也可以合并到更大的 Go 项目中。</li><li data-pid="mCwsMni8"><a href="https://github.com/ziutek/emgo" target="_blank">emgo</a> - 用于编程嵌入式系统（例如 STM32 MCU）的类 Go 语言。</li><li data-pid="wSzkapsA"><a href="https://github.com/jaypipes/ghw" target="_blank">ghw</a> -Golang 硬件发现/检查库。</li><li data-pid="Ns6iXxiV"><a href="https://github.com/hypebeast/go-osc" target="_blank">go-osc -Go</a>的开放声音控制（OSC）绑定。</li><li data-pid="0XJd4AIV"><a href="https://github.com/stianeikeland/go-rpio" target="_blank">go-rpio</a> -Go 的 GPIO，不需要 cgo。</li><li data-pid="E_wut1ZR"><a href="https://github.com/aler9/goroslib" target="_blank">goroslib</a> -Go 的机器人操作系统 (ROS) 库。</li><li data-pid="JYoWiDMX"><a href="https://github.com/0xcafed00d/joystick" target="_blank">joystick</a> - 一个轮询 API，用于读取连接的操纵杆的状态。</li><li data-pid="vUhkRqUB"><a href="https://github.com/zcalusic/sysinfo" target="_blank">sysinfo</a> - 提供 Linux 操作系统/内核/硬件系统信息的纯 Go 库。</li></ul><p data-pid="6x9KZ5O0"><b><a href="https://github.com/avelino/awesome-go/blob/main/README.md#contents" target="_blank">⬆回到顶部</a></b></p><h2><b>图片</b></h2><p data-pid="l3exOTcm"><i>用于处理图像的库。</i></p><ul><li data-pid="h0wiUGTJ"><a href="https://github.com/anthonynsimon/bild" target="_blank">bild</a> - 纯 Go 中的图像处理算法集合。</li><li data-pid="VMNJCxc-"><a href="https://github.com/h2non/bimg" target="_blank">bimg</a> - 使用 libvips 进行快速高效图像处理的小包。</li><li data-pid="KeHTipor"><a href="https://github.com/aofei/cameron" target="_blank">cameron</a> -Go 的头像生成器。</li><li data-pid="QPnHd8HB"><a href="https://github.com/tdewolff/canvas" target="_blank">canvas</a> - 矢量图形到 PDF、SVG 或光栅化图像。</li><li data-pid="aUpHlkve"><a href="https://github.com/marekm4/color-extractor" target="_blank">color-extractor</a> - 没有外部依赖性的主要颜色提取器。</li><li data-pid="f9V9lLqV"><a href="https://github.com/gojek/darkroom" target="_blank">darkroom</a> - 具有可变存储后端和图像处理引擎的图像代理，专注于速度和弹性。</li><li data-pid="1WUMJAK8"><a href="https://github.com/lucasepe/draft" target="_blank">draft</a> - 使用简单的 YAML 语法为 GraphViz 生成高级微服务架构图。</li><li data-pid="rBWuZit1"><a href="https://github.com/pravj/geopattern" target="_blank">geopattern</a> - 从字符串创建漂亮的生成图像模式。</li><li data-pid="vTlsVRMJ"><a href="https://github.com/fogleman/gg" target="_blank">gg</a> - 纯 Go 中的 2D 渲染。</li><li data-pid="v-2eMNi0"><a href="https://github.com/disintegration/gift" target="_blank">gift</a> - 图像处理过滤器包。</li><li data-pid="NRMNwpF1"><a href="https://github.com/qmuntal/gltf" target="_blank">gltf</a> - 高效且强大的 glTF 2.0 阅读器、编写器和验证器。</li><li data-pid="flv1SFJG"><a href="https://github.com/ungerik/go-cairo" target="_blank">go-cairo</a> - 去绑定 cairo 图形库。</li><li data-pid="Mhv3LXpQ"><a href="https://github.com/bolknote/go-gd" target="_blank">go-gd</a> - 绑定 GD 库。</li><li data-pid="85ZJr0-P"><a href="https://github.com/koyachi/go-nude" target="_blank">go-nude</a> - 使用 Go 进行裸体检测。</li><li data-pid="pWIrTAp3"><a href="https://github.com/jyotiska/go-webcolors" target="_blank">go-webcolors</a> - 从 Python 到 Go 的 webcolors 库的端口。</li><li data-pid="6lGjFkyx"><a href="https://github.com/kolesa-team/go-webp" target="_blank">go-webp</a> - 使用 libwebp 编码和解码 webp 图片的库。</li><li data-pid="bg1Zhbe9"><a href="https://github.com/hybridgroup/gocv" target="_blank">gocv</a> - 使用 OpenCV 3.3+ 的计算机视觉 Go 包。</li><li data-pid="vnQcwBlm"><a href="https://github.com/corona10/goimagehash" target="_blank">goimagehash</a> - Go 感知图像哈希包。</li><li data-pid="7zxeRAGU"><a href="https://github.com/corona10/goimghdr" target="_blank">goimghdr</a> - imghdr 模块确定 Go 文件中包含的图像类型。</li><li data-pid="Jalxot9I"><a href="https://github.com/o1egl/govatar" target="_blank">govatar</a> - 用于生成有趣头像的库和 CMD 工具。</li><li data-pid="iuvcsBzK"><a href="https://github.com/davidbyttow/govips" target="_blank">govips</a> - Go 的闪电般快速图像处理和大小调整库。</li><li data-pid="NhaC1E_0"><a href="https://github.com/sensepost/gowitness" target="_blank">gowitness</a> - 在命令行上使用 go 和 headless chrome 截取网页。</li><li data-pid="YbhBNT5n"><a href="https://github.com/shomali11/gridder" target="_blank">gridder</a> - 基于网格的 2D 图形库。</li><li data-pid="OhV3Lmmi"><a href="https://github.com/qeesung/image2ascii" target="_blank">image2ascii</a> - 将图像转换为 ASCII。</li><li data-pid="tkyh6Pz7"><a href="https://github.com/gographics/imagick" target="_blank">imagick</a> - 绑定到 ImageMagick 的 MagickWand C API。</li><li data-pid="n0Y0trYH"><a href="https://github.com/h2non/imaginary" target="_blank">imaginary</a> - 用于图像大小调整的快速简单的 HTTP 微服务。</li><li data-pid="4QH0Leam"><a href="https://github.com/disintegration/imaging" target="_blank">imaging</a> - 简单的 Go 图像处理包。</li><li data-pid="MpWtQH-A"><a href="https://github.com/hawx/img" target="_blank">img</a> - 图像处理工具的选择。</li><li data-pid="clBcZyv4"><a href="https://github.com/fogleman/ln" target="_blank">ln</a> -Go 中的 3D 线条艺术渲染.</li><li data-pid="VX9kqXcw"><a href="https://github.com/noelyahan/mergi" target="_blank">mergi</a> - 用于图像处理（合并、裁剪、调整大小、水印、动画）的 Tool &amp; Go 库。</li><li data-pid="FnFMrVAG"><a href="https://github.com/aldor007/mort" target="_blank">mort</a> - 用 Go 编写的存储和图像处理服务器。</li><li data-pid="vAw1-YI0"><a href="https://github.com/donatj/mpo" target="_blank">mpo</a> - MPO 3D 照片的解码器和转换工具。</li><li data-pid="giGKcLoW"><a href="https://github.com/thoas/picfit" target="_blank">picfit</a> - 用 Go 编写的图像大小调整服务器。</li><li data-pid="u7dsp5YN"><a href="https://github.com/fogleman/pt" target="_blank">pt</a> - 用 Go 编写的路径跟踪引擎。</li><li data-pid="NwEz2fx2"><a href="https://github.com/nfnt/resize" target="_blank">resize</a> - 使用常见的插值方法调整 Go 的图像大小。</li><li data-pid="qnLSltd4"><a href="https://github.com/bamiaux/rez" target="_blank">rez</a> - 在纯 Go 和 SIMD 中调整图像大小。</li><li data-pid="Wc5s62o-"><a href="https://github.com/jonoton/scout" target="_blank">scout</a> -Scout 是用于 DIY 视频安全的独立开源软件解决方案。</li><li data-pid="YWefvfXx"><a href="https://github.com/muesli/smartcrop" target="_blank">smartcrop</a> - 为任意图像和裁剪尺寸找到好的裁剪。</li><li data-pid="bmQy6fbG"><a href="https://github.com/auyer/steganography" target="_blank">隐写术</a>- 用于 LSB 隐写术的 Pure Go 库。</li><li data-pid="IIRb6KLv"><a href="https://github.com/DimitarPetrov/stegify" target="_blank">stegify</a> - 用于 LSB 隐写术的 Go 工具，能够隐藏图像中的任何文件。</li><li data-pid="cOQV1CBv"><a href="https://github.com/ajstarks/svgo" target="_blank">svgo</a> - 用于生成 SVG 的 Go 语言库。</li><li data-pid="ELLe3gVi"><a href="https://github.com/ftrvxmtrx/tga" target="_blank">tga</a> - 包 tga 是 TARGA 图像格式解码器/编码器.</li><li data-pid="h70iJXQV"><a href="https://github.com/mehdipourfar/webp-server" target="_blank">webp-server</a> - 简单且最小的图像服务器，能够存储、调整大小、转换和缓存图像。</li></ul><p data-pid="zrH3ZyBF"><b><a href="https://github.com/avelino/awesome-go/blob/main/README.md#contents" target="_blank">⬆回到顶部</a></b></p></div> </details> 
 <hr /> 

 #### - [K8s 深入理解 Operator-client 详解](https://zhuanlan.zhihu.com/p/629622839) 
 <details><summary>توضیحات</summary> <p><img src="https://picx.zhimg.com/v2-d12ae74deeea18ad5c95787a23571678_720w.jpg?source=d16d100b"></p><div><h2><b>前言</b></h2><p data-pid="SRtkXteN">在上一个对于 client-go 学习中，通过 sample-controller 的项目了解到 Kubernetes 的 部分 client-go 的学习。继续深入学习 client-go</p><p class="ztext-empty-paragraph"><br></p><h3><b>Client-go</b></h3><p data-pid="Wug3JoyS">kubectl 并不适合 Kubernetes 的二次开发者来和 k8s 打交道，Go语言提供了一个专门和 Kubernetes API 交互的 库 Client-go。</p><p data-pid="O386CRjt">Kubernetes 也提供了一个编写控制器<a href="https://github.com/kubernetes/sample-controller/" target="_blank">的小案例</a>，可以作为 client-go 的入门</p><p data-pid="j4E32IYw">Client-go是一个用于与 Kubernetes API 交互的Go库。它提供了广泛的功能，用于与Kubernetes API交互，包括强类型 API、资源客户端、Watch API 和动态客户端。使用 client-go，开发人员可以轻松地在 Kubernetes 中创建、读取、更新和删除资源对象。</p><blockquote data-pid="clmRJjhz">从这个<code>package</code>的名称来看，这应该是跟<code>k8s</code>打交道的客户端<code>client</code>的<code>go</code>实现，这一点没错，它定义了诸多资源的客户端<code>client</code>。</blockquote><ul><li data-pid="eLU_LM_8"><a href="https://github.com/kubernetes/client-go" target="_blank">Client-go GitHub Address</a></li><li data-pid="QjVZ9qiu"><a href="https://github.com/cubxxw/client-go" target="_blank"><span class="invisible">https://</span><span class="visible">github.com/cubxxw/clien</span><span class="invisible">t-go</span><span class="ellipsis"></span></a></li></ul><p data-pid="zwh2UImq">上面是 client-go 的 GitHub 仓库，不过这个库是 actions 以每天一次的频率从 Kubernetes/Kubernetes 主仓库中自动同步过来的。所以如果我们想贡献的话找好位置去 Kubernetes 贡献（kubernetes/stagin/src/<a href="http://k8s.io" target="_blank"><span class="invisible">http://</span><span class="visible">k8s.io</span><span class="invisible"></span></a>）。</p><p class="ztext-empty-paragraph"><br></p><h3><b>Client-go目录结构</b></h3><div class="highlight"><pre><code class="language-bash"> ├── discovery   <span class="c1"># DsicoveryClient客户端,用于发现k8s所支持GVR。</span>
 ├── dynamic     <span class="c1"># DynamicClient客户端, 用于访问k8s Resources，也可以访问CRD。</span>
 ├── informers   <span class="c1"># k8s中各种Resources的Informer机制的实现。</span>
 ├── kubernetes  <span class="c1"># 对RestClient进行了封装，定义多种Client的客户端集合，俗称clientset。</span>
 ├── listers     <span class="c1"># 提供对Resources的获取功能。对于Get()和List()而言，listers提供给二者的数据都是从缓存中读取的。</span>
 ├── pkg
 ├── plugin      <span class="c1"># 提供第三方插件。</span>
 ├── scale       <span class="c1"># 定义用于Deploy, RS, RC等资源进行的扩、缩容的客户端ScaleClient。</span>
 ├── tools       <span class="c1"># 实现client查询和缓存机制，以及定义诸如SharedInformer、Reflector、DealtFIFO和Indexer等常用工具。</span>
 ├── transport
 └── util        <span class="c1"># 提供诸如WorkQueue、Certificate等常用方法。</span></code></pre></div><p data-pid="D3Qpo4qF">  对上面的解释：</p><ul><li data-pid="-5ojRJS0"><code>/discovery</code>：该目录包含用于发现和获取Kubernetes API资源的代码。这些资源包括Pod、Service、ReplicationController等。<code>discovery</code>目录中的代码可以帮助开发人员发现和使用这些资源。</li><li data-pid="Nanp77ID"><code>/dynamic</code>：该目录包含动态客户端库，用于与Kubernetes API交互，而无需生成代码。这对于构建需要与任意Kubernetes资源交互的通用工具和实用程序非常有用。</li><li data-pid="YDJ-gjzX"><code>/kubernetes</code>：这个包中方的是用 client-gen 自动生成的用来访问 Kubernetes API 的 ClientSet，后面会经常看到 ClientSet 这个工具。</li><li data-pid="4Jc95Cgi"><code>/informers</code>：该目录包含用于监视Kubernetes资源变化的代码。这些变化可以包括资源的创建、更新和删除。<code>informers</code>目录中的代码可以帮助开发人员构建控制器和其他需要对Kubernetes环境中的变化做出反应的应用程序。</li><li data-pid="yYH-LtKb"><code>/listers</code>：该目录包含用于从Kubernetes服务器获取资源列表的代码。这些资源列表包括Pod、Service、Namespace等。<code>listers</code>目录中的代码可以帮助开发人员更轻松地获取有关Kubernetes资源的信息。</li><li data-pid="cJzOKZNe"><code>/rest</code>：该目录包含用于与Kubernetes API交互的代码。这些API包括Pod、Service、Namespace等。<code>rest</code>目录中的代码可以帮助开发人员执行各种操作，包括管理Pod、Deployment、Service、Namespace等。</li><li data-pid="1NcoQs2g"><code>/scale</code>：该目录包含用于与Kubernetes资源的自动缩放相关的代码。这些资源包括Deployment、ReplicaSet、StatefulSet等。<code>scale</code>目录中的代码可以帮助开发人员自动缩放与Kubernetes资源相关的组件。</li><li data-pid="2c2kOZq2"><code>transport</code>：这个包用于设置认证和建立连接</li><li data-pid="rE-ZIC2l"><code>/tools</code>：该目录包含用于测试和其他实用程序的代码。这些实用程序包括代码生成器、测试工具等。<code>tools</code>目录中的代码可以帮助开发人员更轻松地测试和使用client-go库。</li><li data-pid="kuUqm3P3"><code>/util</code>：该目录包含用于客户端库的辅助功能的代码。这些功能包括对Kubernetes API对象的类型转换、对象比较等。<code>util</code>目录中的代码可以帮助开发人员更轻松地使用client-go库。</li></ul><p class="ztext-empty-paragraph"><br></p><h3><b>获取 Client-go</b></h3><p data-pid="NE8eHzaT">可以通过 go get 命令获取 client-go，不过我直接克隆最新源代码，然后构建为可执行文件：</p><div class="highlight"><pre><code class="language-bash"> git clone https://github.com/kubernetes/client-go.git</code></pre></div><p data-pid="brBnjXmg">他们给了一些样例的文件，我找出来：</p><div class="highlight"><pre><code class="language-bash"> ❯ find -name main.go
 ./examples/workqueue/main.go
 ./examples/in-cluster-client-configuration/main.go
 ./examples/out-of-cluster-client-configuration/main.go
 ./examples/dynamic-create-update-delete-deployment/main.go
 ./examples/create-update-delete-deployment/main.go
 ./examples/leader-election/main.go</code></pre></div><p data-pid="RxXvnA-q">这些文件可以帮助我们快速上手 client-go：</p><ul><li data-pid="Bz_Wl6tw"><code>./examples/workqueue/main.go</code>：演示如何使用 Kubernetes 的工作队列（Workqueue）实现资源控制器（Controller）。</li><li data-pid="h6TrsVeb"><code>./examples/in-cluster-client-configuration/main.go</code>：演示如何在 Kubernetes 集群内部使用 <code>client-go</code> 访问 Kubernetes API Server。</li><li data-pid="lvVnwGnl"><code>./examples/out-of-cluster-client-configuration/main.go</code>：演示如何在 Kubernetes 集群外部使用 <code>client-go</code> 访问 Kubernetes API Server。</li><li data-pid="9nk1DuoK"><code>./examples/dynamic-create-update-delete-deployment/main.go</code>：演示如何使用 Kubernetes 的动态客户端库（Dynamic Client）实现对 Deployment 资源对象的增删改查等操作。</li><li data-pid="-5vpNQEj"><code>./examples/create-update-delete-deployment/main.go</code>：演示如何使用 <code>client-go</code> 实现对 Deployment 资源对象的增删改查等操作。</li><li data-pid="SVkzWYVO"><code>./examples/leader-election/main.go</code>：演示如何使用 Kubernetes 的 Leader Election 机制，实现资源控制器的高可用性和故障转移。</li></ul><p class="ztext-empty-paragraph"><br></p><p data-pid="FmlP2Hoo">在 <code>/root/workspaces/client-go/examples/workqueue</code> 目录中：</p><p data-pid="w-6rE6OM">我们是不能直接编译的，看一下：</p><div class="highlight"><pre><code class="language-bash"> ❯ ./main --help
 Usage of ./main:
   -kubeconfig string
         absolute path to the kubeconfig file
   -master string
         master url</code></pre></div><p data-pid="SSfNI-tJ">指定 kubeconfig （也可以通过设置环境变量  <code>export KUBECONFIG</code> ）</p><div class="highlight"><pre><code class="language-bash"> ❯ ./main -kubeconfig ~/.kube/config</code></pre></div><blockquote data-pid="BvBmaAXi">举例：使用 kubectl 命令行工具创建一个名为 myresource 的自定义资源，并将其保存到 YAML 文件中。然后，运行 <code>go run ./examples/workqueue/main.go</code> 命令启动控制器。此时，控制器会开始监听 myresource 资源，并在该资源被创建或更新时，异步地处理一些任务。</blockquote><p class="ztext-empty-paragraph"><br></p><p data-pid="byHLFCmS"><b>继续演示 对 Deployment CURD 操作：</b></p><div class="highlight"><pre><code class="language-bash"> ❯ <span class="nb">cd</span> dynamic-create-update-delete-deployment/
 ❯ ls
 README.md  main.go
 ❯ go build main.go
 ❯ ./main 
 Creating deployment...
 Created deployment <span class="s2">"demo-deployment"</span>.
 -&gt; Press Return key to <span class="k">continue</span>.
 ​
 Updating deployment...
 Updated deployment...
 -&gt; Press Return key to <span class="k">continue</span>.
 ​
 Listing deployments in namespace <span class="s2">"default"</span>:
  * demo-deployment <span class="o">(</span><span class="m">1</span> replicas<span class="o">)</span>
  * my-nginx-app <span class="o">(</span><span class="m">3</span> replicas<span class="o">)</span>
  * nginx-deployment <span class="o">(</span><span class="m">3</span> replicas<span class="o">)</span>
 -&gt; Press Return key to <span class="k">continue</span>.
 ​
 Deleting deployment...
 Deleted deployment.</code></pre></div><p data-pid="MBgJq230"><code>./examples/dynamic-create-update-delete-deployment/main.go</code>：这个示例文件演示如何使用 Kubernetes 的动态客户端库（Dynamic Client）实现对 Deployment 资源对象的增删改查等操作。使用动态客户端库，开发人员可以更加灵活地操作 Kubernetes 资源对象，而不需要手动编写复杂的代码。例如，在这个示例中，开发人员可以使用 DynamicClient 对象，动态地创建、更新和删除 Deployment 资源对象。</p><blockquote data-pid="eE7t1EAM">举例：使用 kubectl 命令行工具创建一个名为 my-deployment 的 Deployment 对象，并将其保存到 YAML 文件中。然后，运行 <code>go run ./examples/dynamic-create-update-delete-deployment/main.go</code> 命令，使用 DynamicClient 对象，动态地创建、更新和删除 my-deployment Deployment 对象。</blockquote><p data-pid="hk7uf-Ib">测试：</p><div class="highlight"><pre><code class="language-bash"> ❯ k get deployment
 NAME               READY   UP-TO-DATE   AVAILABLE   AGE
 demo-deployment    0/1     <span class="m">0</span>            <span class="m">0</span>           4s
 my-nginx-app       0/3     <span class="m">3</span>            <span class="m">0</span>           26h
 nginx-deployment   3/3     <span class="m">3</span>            <span class="m">3</span>           165m</code></pre></div><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>WorkQueue 源码分析</b></h3><p data-pid="CSbDLQLR">WorkQueue 一般使用的说就是延迟队列的实现，在 Resopurce Event Handlers 中会完成将对象的 key 放入 WorkQueue 的过程，然后再自己的逻辑代码中从 WorkQueue 中消费这些 Key。</p><p data-pid="I0EO1lMc">Client-go 的 <code>utile/Workqueue</code> 包中有三个队列：</p><p data-pid="ZBNKr3w1">分别对应的是 普通队列、延时队列和限速队列。对应的源文件分别是：</p><ul><li data-pid="nhOK_Aye">queue.go</li><li data-pid="uFWf7FF0">delaying_queue.go</li><li data-pid="B1RXfRGS">rate_limiting_queue.go</li></ul><p class="ztext-empty-paragraph"><br></p><p data-pid="xSIF8t5e"><b>我们先看看 普通队列，这个对应的文件就是 queue.go：</b></p><div class="highlight"><pre><code class="language-go"> <span class="kd">type</span> <span class="nx">Interface</span> <span class="kd">interface</span> <span class="p">{</span>
     <span class="nf">Add</span><span class="p">(</span><span class="nx">item</span> <span class="kd">interface</span><span class="p">{})</span>
     <span class="nf">Len</span><span class="p">()</span> <span class="kt">int</span>
     <span class="nf">Get</span><span class="p">()</span> <span class="p">(</span><span class="nx">item</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">shutdown</span> <span class="kt">bool</span><span class="p">)</span>
     <span class="nf">Done</span><span class="p">(</span><span class="nx">item</span> <span class="kd">interface</span><span class="p">{})</span>
     <span class="nf">ShutDown</span><span class="p">()</span>
     <span class="nf">ShutDownWithDrain</span><span class="p">()</span>
     <span class="nf">ShuttingDown</span><span class="p">()</span> <span class="kt">bool</span>
 <span class="p">}</span>
</code></pre></div><p data-pid="GUhDKGPn">看接口就知道了实现了哪些方法，分别是添加元素，元素个数、获取第一个元素、第二个返回值和 channel 类似，标记了队列是否关闭。</p><p data-pid="_FC7TN73">Done 标记一个元素是否已经处理完，ShutDown 关闭队列，ShowDownWithDrain 关闭队列，但是等待队列中的元素处理完。ShuttingDown 标记当前的 channel 是否正在关闭。</p><p class="ztext-empty-paragraph"><br></p><p data-pid="GYomuUSz"><b>我们再看延迟队列，对应的文件在delaying_queue.go</b></p><div class="highlight"><pre><code class="language-go"> <span class="c1">// DelayingInterface is an Interface that can Add an item at a later time. This makes it easier to
</span><span class="c1"></span> <span class="c1">// requeue items after failures without ending up in a hot-loop.
</span><span class="c1"></span> <span class="kd">type</span> <span class="nx">DelayingInterface</span> <span class="kd">interface</span> <span class="p">{</span>
     <span class="nx">Interface</span>
     <span class="c1">// AddAfter adds an item to the workqueue after the indicated duration has passed
</span><span class="c1"></span>     <span class="nf">AddAfter</span><span class="p">(</span><span class="nx">item</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">duration</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span><span class="p">)</span>
 <span class="p">}</span>
</code></pre></div><p data-pid="JW_fKO9B">接口就很简单，定义 DelayingInterface 接口在 delaying_queue.go 源文件，名字和 Queue 所使用的interface对称，叫做 DelayingInterface。</p><p data-pid="qpKYZHK5">这里有一个 Interface，对此我感觉到有一些疑惑，Interface 是普通队列命名的接口，这个设计模式的接口设计的思路蛮有意思的，先别激动，后面有你激动的，看到 Controller 的接口设计，那简直就是 6 ~</p><p class="ztext-empty-paragraph"><br></p><p data-pid="3qyNNPSW"><b>最后我们看一下限速队列，这个有意思很多了，同样今天的项目 <code>sample-controller</code> 也用到了这个队列，我们看一下 controller 部分：</b></p><div class="highlight"><pre><code class="language-go"> <span class="kd">type</span> <span class="nx">Controller</span> <span class="kd">struct</span> <span class="p">{</span>
     <span class="c1">//...
</span><span class="c1"></span>     <span class="nx">workqueue</span> <span class="nx">workqueue</span><span class="p">.</span><span class="nx">RateLimitingInterface</span>
 <span class="p">}</span> 
</code></pre></div><p data-pid="Piwkrn71">我们看到了 限速队列包含了延迟队列的所有接口实现，也包含了 基本队列的所有接口实现。</p><p data-pid="1_mQM2KP"><b>分析这个队列的接口：</b></p><ul><li data-pid="cxpkHjcK">AddRateLimited：在速率限制器认可的情况下将项目添加到工作队列中。</li><li data-pid="PJJKiiap">Forget：表示项目已经完成重试。无论是永久性失败还是成功，我们都会停止速率限制器对其进行跟踪。这仅清除了<code>rateLimiter</code>，您仍然需要在队列上调用<code>Done</code>方法。</li><li data-pid="r53EXkbB">NumRequeues：返回项目被重新排队的次数。</li></ul><div class="highlight"><pre><code class="language-go"> <span class="c1">// RateLimitingInterface is an interface that rate limits items being added to the queue.
</span><span class="c1"></span> <span class="kd">type</span> <span class="nx">RateLimitingInterface</span> <span class="kd">interface</span> <span class="p">{</span>
     <span class="nx">DelayingInterface</span>
 <span class="err">​</span>
     <span class="c1">// AddRateLimited adds an item to the workqueue after the rate limiter says it's ok
</span><span class="c1"></span>     <span class="nf">AddRateLimited</span><span class="p">(</span><span class="nx">item</span> <span class="kd">interface</span><span class="p">{})</span>
 <span class="err">​</span>
     <span class="c1">// Forget indicates that an item is finished being retried.  Doesn't matter whether it's for perm failing
</span><span class="c1"></span>     <span class="c1">// or for success, we'll stop the rate limiter from tracking it.  This only clears the `rateLimiter`, you
</span><span class="c1"></span>     <span class="c1">// still have to call `Done` on the queue.
</span><span class="c1"></span>     <span class="nf">Forget</span><span class="p">(</span><span class="nx">item</span> <span class="kd">interface</span><span class="p">{})</span>
 <span class="err">​</span>
     <span class="c1">// NumRequeues returns back how many times the item was requeued
</span><span class="c1"></span>     <span class="nf">NumRequeues</span><span class="p">(</span><span class="nx">item</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">int</span>
 <span class="p">}</span>
</code></pre></div><p data-pid="zaKOGb2Z">在后面的学习中，我们再深入探索这些 WorkQueue 的实现。</p><p class="ztext-empty-paragraph"><br></p><h3><b>DeltaFIFO 源码分析</b></h3><p data-pid="f5UU0_V9">DeltaFIFO 也是一个特别重要的组件，在 <code>k8s.io/client-go/tools/cache</code> 包中，用于存储对象的增量更新。</p><ul><li data-pid="ToNAaswD">存储对象的增量更新，包括添加、删除和更新操作。</li><li data-pid="4EFiAOWY">能够按顺序处理更新，以确保它们被正确地应用。</li><li data-pid="vFEepwXQ">支持阻塞式同步，以便在应用所有更新之前等待。</li></ul><p data-pid="rY86M-1g">在 fifo.go 中定义了一个 Queue 的接口，我们看一下接口代码：</p><div class="highlight"><pre><code class="language-go"> <span class="kd">type</span> <span class="nx">Queue</span> <span class="kd">interface</span> <span class="p">{</span>
     <span class="nx">Store</span>
     <span class="nf">Pop</span><span class="p">(</span><span class="nx">PopProcessFunc</span><span class="p">)</span> <span class="p">(</span><span class="kd">interface</span><span class="p">{},</span> <span class="kt">error</span><span class="p">)</span>
     <span class="nf">AddIfNotPresent</span><span class="p">(</span><span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span>
     <span class="nf">HasSynced</span><span class="p">()</span> <span class="kt">bool</span>
     <span class="c1">// Close the queue
</span><span class="c1"></span>     <span class="nf">Close</span><span class="p">()</span>
 <span class="p">}</span>
</code></pre></div><p data-pid="anQj8dE2">嵌入了一个 Store 接口：</p><div class="highlight"><pre><code class="language-go"> <span class="nx">Store</span> <span class="kd">interface</span> <span class="p">{</span>
     <span class="nf">Add</span><span class="p">(</span><span class="nx">obj</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span>
     <span class="nf">Update</span><span class="p">(</span><span class="nx">obj</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span>
     <span class="nf">Delete</span><span class="p">(</span><span class="nx">obj</span> <span class="kd">interface</span><span class="p">{})</span> <span class="kt">error</span>
     <span class="nf">List</span><span class="p">()</span> <span class="p">[]</span><span class="kd">interface</span><span class="p">{}</span>
     <span class="nf">ListKeys</span><span class="p">()</span> <span class="p">[]</span><span class="kt">string</span>
     <span class="nf">Get</span><span class="p">(</span><span class="nx">obj</span> <span class="kd">interface</span><span class="p">{})</span> <span class="p">(</span><span class="nx">item</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">exists</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
     <span class="nf">GetByKey</span><span class="p">(</span><span class="nx">key</span> <span class="kt">string</span><span class="p">)</span> <span class="p">(</span><span class="nx">item</span> <span class="kd">interface</span><span class="p">{},</span> <span class="nx">exists</span> <span class="kt">bool</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
     <span class="nf">Replace</span><span class="p">([]</span><span class="kd">interface</span><span class="p">{},</span> <span class="kt">string</span><span class="p">)</span> <span class="kt">error</span>
     <span class="nf">Resync</span><span class="p">()</span> <span class="kt">error</span>
 <span class="p">}</span>
</code></pre></div><p data-pid="Cu37YIA9">都是表面的意思了，CURD 操作，各种 Get、List 操作。</p><p data-pid="BzJpvyIQ"><b>除此之外，还有其他的，阅读源码即可，后面慢慢深入讲解。</b></p><p class="ztext-empty-paragraph"><br></p><h3><b>Informer 机制</b></h3><p data-pid="4RUvS6_T">Informar 这个单词出镜率很高，我们在很多文章中都可以看到这个 Informer，包括 Kubernetes 源码讲解的 ETCD 和 API Server 中。</p><p data-pid="-HhSmgwv">Informer 从 DeltaFIFO 中 Pop 相对应的对象，会通过 Indexer 将对象和索引都丢在本地的 cache 中，再触发相应的事件处理函数（Resource Event Handlers) 的运行。</p><p data-pid="e3bKYyqF">源码位置： <code>k8s.io/client-go/tools/cache</code></p><p data-pid="tYOVuhs5">Informar 是通过一个 Controller 对象来进行定义的，我们先看看对象接口：</p><p data-pid="iF7-gn1h">在 <code>controller.go</code> 文件中能看到 Controller 的定义：</p><div class="highlight"><pre><code class="language-go"> <span class="kd">type</span> <span class="nx">Controller</span> <span class="kd">interface</span> <span class="p">{</span>
     <span class="nf">Run</span><span class="p">(</span><span class="nx">stopCh</span> <span class="o">&lt;-</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span>
     <span class="nf">HasSynced</span><span class="p">()</span> <span class="kt">bool</span>
     <span class="nf">LastSyncResourceVersion</span><span class="p">()</span> <span class="kt">string</span>
 <span class="p">}</span>
</code></pre></div><p data-pid="CIEHPR6m">看出，最核心的方法是 <code>Run(stopCh &lt;-chan struct{})</code> Run 这个函数我们点击进去会发现，主要做了两个事情：</p><ul><li data-pid="xg_U7Drl">构造 Reflector 利用 ListerWatcher 的能力将对象事件更新到 DeltaFIFO</li><li data-pid="_YPV0xk_">从 DeltaFIFO 中 Pop 对象后调用 ProcessFunc 来处理。</li></ul><p data-pid="38WV6Y9m">初始化是什么样的？</p><div class="highlight"><pre><code class="language-go"> <span class="c1">// New makes a new Controller from the given Config.
</span><span class="c1"></span> <span class="kd">func</span> <span class="nf">New</span><span class="p">(</span><span class="nx">c</span> <span class="o">*</span><span class="nx">Config</span><span class="p">)</span> <span class="nx">Controller</span> <span class="p">{</span>
     <span class="nx">ctlr</span> <span class="o">:=</span> <span class="o">&amp;</span><span class="nx">controller</span><span class="p">{</span>
         <span class="nx">config</span><span class="p">:</span> <span class="o">*</span><span class="nx">c</span><span class="p">,</span>
         <span class="nx">clock</span><span class="p">:</span>  <span class="o">&amp;</span><span class="nx">clock</span><span class="p">.</span><span class="nx">RealClock</span><span class="p">{},</span>
     <span class="p">}</span>
     <span class="k">return</span> <span class="nx">ctlr</span>
 <span class="p">}</span>
</code></pre></div><p data-pid="eiVhBXWG">传入了一个 Config 过来，然后初始化，核心逻辑那就在 Config 中了：</p><div class="highlight"><pre><code class="language-go"> <span class="c1">// Config contains all the settings for one of these low-level controllers.
</span><span class="c1"></span> <span class="kd">type</span> <span class="nx">Config</span> <span class="kd">struct</span> <span class="p">{</span>
     <span class="nx">Queue</span>
     <span class="c1">// Something that can list and watch your objects.
</span><span class="c1"></span>     <span class="nx">ListerWatcher</span>
     <span class="c1">// Something that can process a popped Deltas.
</span><span class="c1"></span>     <span class="nx">Process</span> <span class="nx">ProcessFunc</span>
     <span class="c1">// ObjectType is an example object of the type this controller is
</span><span class="c1"></span>     <span class="c1">// expected to handle.
</span><span class="c1"></span>     <span class="nx">ObjectType</span> <span class="nx">runtime</span><span class="p">.</span><span class="nx">Object</span>
     <span class="c1">// ObjectDescription is the description to use when logging type-specific information about this controller.
</span><span class="c1"></span>     <span class="nx">ObjectDescription</span> <span class="kt">string</span>
     <span class="c1">// FullResyncPeriod is the period at which ShouldResync is considered.
</span><span class="c1"></span>     <span class="nx">FullResyncPeriod</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Duration</span>
     <span class="nx">ShouldResync</span> <span class="nx">ShouldResyncFunc</span>
     <span class="nx">RetryOnError</span> <span class="kt">bool</span>
     <span class="c1">// Called whenever the ListAndWatch drops the connection with an error.
</span><span class="c1"></span>     <span class="nx">WatchErrorHandler</span> <span class="nx">WatchErrorHandler</span>
     <span class="c1">// WatchListPageSize is the requested chunk size of initial and relist watch lists.
</span><span class="c1"></span>     <span class="nx">WatchListPageSize</span> <span class="kt">int64</span>
 <span class="p">}</span>
</code></pre></div><p class="ztext-empty-paragraph"><br></p><h3><b>SharedInformer 对象源码</b></h3><p data-pid="fhw7H1MW">SharedInformer 和 Informer 之间的名字就差一个 Shared，在 Operator 开发中，如果不适用 controller-runtime 库（kubebuilder controller-runtime 子项目的Repo），也就是不用 Kubebuilder 等工具生成脚手架，那么应该用到的是 SharedInformerFactory，比如今天主要做的 sample-controller 的 <code>main()</code>  函数，在下面的 sample-controller 源码介绍中会讲解~</p><p data-pid="D2PxkLXr">我们能看到这两行代码：</p><div class="highlight"><pre><code class="language-go"> <span class="nx">kubeInformerFactory</span> <span class="o">:=</span> <span class="nx">kubeinformers</span><span class="p">.</span><span class="nf">NewSharedInformerFactory</span><span class="p">(</span><span class="nx">kubeClient</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="o">*</span><span class="mi">30</span><span class="p">)</span>
     
 <span class="nx">exampleInformerFactory</span> <span class="o">:=</span> <span class="nx">informers</span><span class="p">.</span><span class="nf">NewSharedInformerFactory</span><span class="p">(</span><span class="nx">exampleClient</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Second</span><span class="o">*</span><span class="mi">30</span><span class="p">)</span>
 <span class="err">​</span>
 <span class="nx">controller</span> <span class="o">:=</span> <span class="nf">NewController</span><span class="p">(</span><span class="nx">ctx</span><span class="p">,</span> <span class="nx">kubeClient</span><span class="p">,</span> <span class="nx">exampleClient</span><span class="p">,</span>
     <span class="nx">kubeInformerFactory</span><span class="p">.</span><span class="nf">Apps</span><span class="p">().</span><span class="nf">V1</span><span class="p">().</span><span class="nf">Deployments</span><span class="p">(),</span> <span class="nx">exampleInformerFactory</span><span class="p">.</span><span class="nf">Samplecontroller</span><span class="p">().</span><span class="nf">V1alpha1</span><span class="p">().</span><span class="nf">Foos</span><span class="p">())</span>
</code></pre></div><p data-pid="4Kd4rKVW">控制器的初始化后面会讲 <code>controller.go</code> 的时候重点讲解，先看看初始化过程和 SharedInformer 的关系。</p><p data-pid="mp0PeoSb">controller 依赖于 <code>kubeInformerFactory.Apps().V1().Deployments()</code> 和 <code>exampleInformerFactory.Samplecontroller().V1alpha1().Foos()</code></p><p data-pid="lfJ06Uq_">后者是 <code>sample-controller</code> 自己 pkg 包提供的，前者是 client-go 提供的，那么看看前者： </p><p data-pid="KyAXaSJP">这里的 Deployment 依赖的是：<code>Deployments() DeploymentInformer</code></p><p data-pid="JkFaHZjM">而 <code>DeploymentInformer</code> 是一个接口类型，看一看：</p><div class="highlight"><pre><code class="language-go"> <span class="c1">// DeploymentInformer provides access to a shared informer and lister for
</span><span class="c1"></span> <span class="c1">// Deployments.
</span><span class="c1"></span> <span class="kd">type</span> <span class="nx">DeploymentInformer</span> <span class="kd">interface</span> <span class="p">{</span>
     <span class="nf">Informer</span><span class="p">()</span> <span class="nx">cache</span><span class="p">.</span><span class="nx">SharedIndexInformer</span>
     <span class="nf">Lister</span><span class="p">()</span> <span class="nx">v1</span><span class="p">.</span><span class="nx">DeploymentLister</span>
 <span class="p">}</span>
</code></pre></div><p data-pid="vaR8hkKd">实现了 <code>Informer</code>  和 <code>Lister</code>，<code>Informer</code> 本质上就是一个 <code>ShareIndexInformer</code></p><p class="ztext-empty-paragraph"><br></p><hr><p class="ztext-empty-paragraph"><br></p><p data-pid="L4C7BLXz"><b>接下来的三个部分，我将详细介绍 sample-controller、kubebuilder、operator-sdk 以及它们之间那微妙的关系。</b></p></div> </details> 
 <hr /> 

 #### - [Kubernetes 社区规范](https://zhuanlan.zhihu.com/p/629622183) 
 <details><summary>توضیحات</summary> <p><img src="https://picx.zhimg.com/v2-475366694622ccb1992834ad1bd53996_720w.jpg?source=d16d100b"></p><div><h2><b>前言</b></h2><p data-pid="EUCR-ciN">一个顶级的社区，必然有着最全面和最规范的章程值得我们学习和借鉴，对于 Kubernetes 来说也是如此，如果想要做好一个顶级的社区，Kubernetes 必然值得我们去借鉴的。</p><p data-pid="TnG6yVU0">用官方的一句话来描述：Kubernetes builds upon a decade and a half of experience at Google running production workloads at scale using a system called <a href="https://research.google.com/pubs/pub43438.html" target="_blank">Borg</a>, combined with best-of-breed ideas and practices from the community.</p><h2><b>Community </b></h2><p data-pid="pBJU2k7v">Community 的地址在 <a href="https://github.com/kubernetes/community" target="_blank"><span class="invisible">https://</span><span class="visible">github.com/kubernetes/c</span><span class="invisible">ommunity</span><span class="ellipsis"></span></a> 。很多社区的社区都是这样设计的。</p><p data-pid="qc6SITf4">Kubernetes具有以下类型的官方支持的组（greps）：</p><ul><li data-pid="LNIjw_8l"><b>Committees</b>：委员会是一批被授权处理敏感话题的人。鼓励该小组在完成其使命时尽可能开放，但由于所讨论主题的性质，允许私下交流。委员会的例子包括指导委员会和安全或行为准则等。</li><li data-pid="Ivstk8Qr"><b>Special Interest Groups (SIGs)</b>  特殊兴趣小组（SIG）是专注于项目某个部分的持续性开放小组。特别政府必须有公开和透明的程序。欢迎任何人参与和贡献，只要他们遵守Kubernetes行为准则。SIG的目的是拥有和开发一组子项目。<br>子项目每个SIG可以有一组子项目。这些是可以独立工作的小团体。一些子项目将是Kubernetes主要交付成果的一部分，而其他子项目则更具推测性，位于 <code>kubernetes-sigs</code> <a href="https://github.com/kubernetes-sigs" target="_blank">github org</a> 中（例如 <a href="https://github.com/kubernetes-sigs/kind" target="_blank">kind</a> 和 <a href="https://github.com/kubernetes-sigs/kubebuilder" target="_blank">kubebuilder</a> 就是在这里）。</li><li data-pid="s9SeX1qk"><b>Working Groups</b> 工作组是为解决跨越SIG边界的问题而成立的临时小组。工作组不拥有任何代码或其他长期工件。工作组可以通过参与的SIG进行汇报和采取行动。</li><li data-pid="8vtEM9_K"><b>User Groups</b> 用户组是用于促进交流和发现与Kubernetes大用户组具有长期相关性的主题相关的信息的组。他们没有Kubernetes代码库的部分所有权。</li></ul><p data-pid="J6cq5CM9">SIG可以有自己的贡献策略（在此存储库的SIG文件夹中的 <code>README</code> 或 <code>CONTRIBUTING</code> 文件中描述）（例如<a href="https://github.com/kubernetes/community/blob/master/sig-cli/CONTRIBUTING.md" target="_blank">sig-cli/CONTRIBUTING.md</a>），以及自己的邮件列表、空闲通道等。</p><p data-pid="RZ8ea_UR">所以是独立出去的，不过依旧是为 kubernetes 服务的。</p><p data-pid="mUTvAy2n">Kubernetes-sig 社区提供了 Kubernetes 的开发学习实验，在 <a href="https://github.com/kubernetes/community/blob/master/contributors/devel/development.md" target="_blank"><span class="invisible">https://</span><span class="visible">github.com/kubernetes/c</span><span class="invisible">ommunity/blob/master/contributors/devel/development.md</span><span class="ellipsis"></span></a> 中</p><p data-pid="kS1sS8ps">告诉了我们如何构建出一个开发环境，并且需要哪些工具。其实和我们在前面二进制搭建是差不多类似的。</p><p data-pid="42bvGxg3">Kubernetes 为贡献 git CICD 流程有一个帮助文档在这里: <a href="https://github.com/kubernetes/community/blob/master/contributors/guide/github-workflow.md" target="_blank"><span class="invisible">https://</span><span class="visible">github.com/kubernetes/c</span><span class="invisible">ommunity/blob/master/contributors/guide/github-workflow.md</span><span class="ellipsis"></span></a></p><p data-pid="qOm8Vd7J">要测试Kubernetes，你需要安装最新版本的etcd，这是一个一致且高度可用的键值存储。要安装本地版本的etcd，请在Kubernetes工作目录中运行以下命令。</p><div class="highlight"><pre><code class="language-bash"> ./hack/install-etcd.sh</code></pre></div><p data-pid="XzLesnQ8">此脚本将指示你对 <code>PATH</code> 进行更改。要使其永久化，请将其添加到你的 <code>.bashrc</code> 或登录脚本中：</p><div class="highlight"><pre><code class="language-bash"> <span class="nb">export</span> <span class="nv">PATH</span><span class="o">=</span><span class="s2">"</span><span class="nv">$GOPATH</span><span class="s2">/src/k8s.io/kubernetes/third_party/etcd:</span><span class="si">${</span><span class="nv">PATH</span><span class="si">}</span><span class="s2">"</span></code></pre></div><h3><b>Makefile</b></h3><p data-pid="mnbQA4MB">我们即使知道了对于一个开发者来说，一个 Makefile 文档带来的帮助是巨大的。</p><p data-pid="RMdaYY1x">要构建Kubernetes的特定部分，请使用 <code>WHAT</code> 环境变量。在Kubernetes项目目录 <code>$GOPATH/src/k8s.io/kubernetes/</code> 中，运行以下命令：</p><div class="highlight"><pre><code class="language-bash"> make <span class="nv">WHAT</span><span class="o">=</span>cmd/&lt;subsystem&gt;</code></pre></div><p data-pid="x-unt8m6">将 <code>&lt;subsystem&gt;</code> 替换为 <code>cmd/</code> 目录下的命令文件夹之一。例如，要构建 <code>kubectl</code> CLI，请运行以下命令：</p><div class="highlight"><pre><code class="language-bash"> make <span class="nv">WHAT</span><span class="o">=</span>cmd/kubectl</code></pre></div><p data-pid="f8wcbE5p">如果此命令成功，你现在将在Kubernetes项目目录的 <code>_output/bin/kubectl</code> 处拥有一个可执行文件。</p><p data-pid="Wd1TkM9d">要构建整个Kubernetes项目，请运行以下命令：</p><div class="highlight"><pre><code class="language-text"> make all</code></pre></div><p data-pid="3IhoVyeq">注意：你可以省略 <code>all</code> ，只运行 <code>make</code> 。</p><p data-pid="S0mXuIMo">Kubernetes构建系统默认将报告的Go编译器错误数量限制为10。如果你想删除此限制，请在命令行中添加 <code>GOGCFLAGS="-e"</code> 。</p><div class="highlight"><pre><code class="language-bash"> make <span class="nv">WHAT</span><span class="o">=</span><span class="s2">"cmd/kubectl"</span> <span class="nv">GOGCFLAGS</span><span class="o">=</span><span class="s2">"-e"</span></code></pre></div><p data-pid="8qDeytn0">如果你需要在已编译的Kubernetes可执行文件上使用调试检查工具，请设置DBG=1。例如：</p><div class="highlight"><pre><code class="language-bash"> make <span class="nv">WHAT</span><span class="o">=</span><span class="s2">"cmd/kubectl"</span> <span class="nv">DBG</span><span class="o">=</span><span class="m">1</span></code></pre></div><p data-pid="wd-O_wHy">要为所有平台交叉编译Kubernetes，请运行以下命令：</p><div class="highlight"><pre><code class="language-bash"> make cross</code></pre></div><p data-pid="f8sK5Xl_">要为特定平台构建二进制文件，请添加 <code>KUBE_BUILD_PLATFORMS=&lt;os&gt;/&lt;arch&gt;</code> 。例如：</p><div class="highlight"><pre><code class="language-bash"> make cross <span class="nv">KUBE_BUILD_PLATFORMS</span><span class="o">=</span>windows/amd64</code></pre></div><p data-pid="Z54Gcttw">要运行所有提交前验证测试，请使用以下命令：</p><div class="highlight"><pre><code class="language-bash"> make verify</code></pre></div><p data-pid="8aq3CwWx">如果某个特定的验证测试失败，可能会有一个更新脚本来帮助解决问题。它们位于 <code>hack/update-*.sh</code> 。例如， <code>hack/update-gofmt.sh</code> 确保所有源代码文件的格式正确。向项目中添加新文件时通常需要此选项。</p><p data-pid="fVG4_ncP">可以使用此命令运行所有更新脚本：</p><div class="highlight"><pre><code class="language-bash"> make update</code></pre></div><p data-pid="1GNNJlJD">ull request需要通过所有单元测试。要运行每个单元测试，请使用以下命令：</p><div class="highlight"><pre><code class="language-bash"> make test</code></pre></div><p data-pid="70gBYYWm">你还可以使用 <code>WHAT</code> 选项来控制要测试的包和子系统，并使用 <code>GOFLAGS</code> 来更改测试的运行方式。例如，要对一个包详细运行单元测试，请使用以下命令：</p><div class="highlight"><pre><code class="language-bash"> make <span class="nb">test</span> <span class="nv">WHAT</span><span class="o">=</span>./pkg/apis/core/helper <span class="nv">GOFLAGS</span><span class="o">=</span>-v</code></pre></div><p data-pid="aEiEmVk-">要运行集成测试，请使用以下命令：</p><div class="highlight"><pre><code class="language-bash"> make test-integration</code></pre></div><h2><b>Kubernetes增强建议（KEP）</b></h2><blockquote data-pid="cjnr7FtG">Kubernetes Enhancement Proposals (KEPs) </blockquote><p data-pid="Yv_Ei0Wk">Kubernetes增强提案（KEP）是一种为Kubernetes项目提出，沟通和协调新工作的方式。你可以在KEP-0000中阅读该项目的全部细节。</p><p data-pid="yFFTI9S1">什么是 KEP？</p><p data-pid="IKTG8jHd"><b>提出了Kubernetes的标准化开发流程，以便：</b></p><ul><li data-pid="_K0DM9Ko">为Kubernetes的变更建议提供一个通用的结构</li><li data-pid="19zwosPU">确保变更的动机明确</li><li data-pid="46Sp6T-t">允许列举稳定性里程碑和稳定性分级标准</li><li data-pid="KbAkYO1B">在版本控制系统（VCS）中持久保存项目信息，以便将来使用Kubernetes</li><li data-pid="3mAf4ceU">支持创建面向用户的高价值信息，例如：<br></li><ul><li data-pid="inUjWO8h">总体项目开发路线图</li><li data-pid="1L10t3AG">有影响力的面向用户的变更的动机</li></ul><li data-pid="XNlXa9Hx">保留GitHub问题用于跟踪正在进行的工作，而不是创建  "umbrella" issues</li><li data-pid="AWh7SaRS">确保社区参与者能够成功地推动一个或多个版本的变更完成，同时在整个过程中充分代表利益相关者</li></ul><p data-pid="TSSpD5zC"><b>这个过程由一个名为  Kubernetes Enhancement Proposals (KEPs)  或KEP的工作单元支持。KEP尝试将以下方面结合起来</b></p><ul><li data-pid="N4MGbBQP">功能和工作跟踪文档</li><li data-pid="1arGx1g7">产品需求文档</li><li data-pid="EtslvgEX">设计文件</li></ul><p data-pid="PqxYA_nP">一个文件，该文件是与一个或多个特殊兴趣组（SIG）协作逐步创建的。</p><h2><b>第一次参与 Kubernetes </b></h2><ul><li data-pid="wAGONWFY"><a href="https://github.com/kubernetes/community/blob/master/contributors/guide/first-contribution.md#find-something-to-work-on" target="_blank">这篇文档告诉了我们贡献的一些方法</a></li></ul><p data-pid="A058MO5h">以下是你今天可以做的一些事情，以开始贡献：</p><ul><li data-pid="WpnNUScZ">帮助改进Kubernetes文档</li><li data-pid="m_9e7rg7">阐明可以重命名或注释的代码、变量或函数</li><li data-pid="0zXkGVXL">写测试覆盖率</li><li data-pid="ohcgzzYg">帮助分类问题（并不一定需要权限，而是通过命令和机器人）</li></ul><p data-pid="-1F0Mbgn">如果上面的建议对你没有吸引力，你可以浏览被标记为 <a href="https://go.k8s.io/good-first-issue" target="_blank">好的第一个问题</a> 的问题，看看谁在寻求帮助。那些有兴趣在不编写代码的情况下进行贡献的人也可以在非代码贡献指南中找到想法。</p><h3><b>修改自己的 <code>kubectl</code> fork</b></h3><p data-pid="11_xFq8s">确保你准备好立即开始之前，你声称任何一块的工作。</p><ul><li data-pid="IaRcb9hi">设置开发环境。</li><li data-pid="2DXe2EN1">熟悉代码：<br></li><ul><li data-pid="gwDeYYf1"><a href="https://git.k8s.io/kubernetes/cmd/kubectl" target="_blank">kubernetes/cmd/kubectl</a> is the entry point</li><li data-pid="MLf_oe9c"><a href="https://git.k8s.io/kubernetes/pkg/kubectl" target="_blank">kubernetes/pkg/kubectl</a> is the implementation</li><li data-pid="TJy3cSdp">Look at how some of the other commands are implemented</li><li data-pid="H_WCLCGe"><a href="https://youtu.be/eZeCFRh2uGg?t=538" target="_blank">Codebase Tour</a></li></ul><li data-pid="iuSauu41">尝试添加一个新命令来执行一些简单的操作：<br></li><ul><li data-pid="Zz7EbVgO">添加 <code>kubectl hello-world</code> ：打印“Hello World”</li><li data-pid="1LsrW4_X">添加 <code>kubectl hello-kubernetes -f file</code> ：打印 <code>Hello&lt;kind of resource&gt;&lt;name of resource&gt;</code></li><li data-pid="rUz6jkCn">添加 <code>kubectl hello-kubernetes type/name</code> ：打印 <code>Hello&lt;kind of resource&gt;&lt;name of resource&gt;&lt;creation time&gt;</code> </li></ul></ul><p data-pid="JcPf6z27">注意：考虑将你的命令发布到一个fork上，这样维护人员就可以查看它。</p><h3><b>Find a good first topic</b></h3><p data-pid="6lSUZ-_P">Kubernetes组织中有多个存储库。每个存储库都有初学者友好的问题，这是开始你的贡献者之旅的好地方。例如，kubernetes/kubernetes对于不需要高级Kubernetes知识来贡献的问题有<a href="https://github.com/issues?q=org%3Akubernetes+org%3Akubernetes-sigs+org%3Akubernetes-csi+org%3Akubernetes-client+is%3Aopen+is%3Aissue+label%3A%22help+wanted%22+no%3Aassignee" target="_blank">help wanted</a>和 good first issue标签。 <code>good first issue</code> 标签还表示Kubernetes成员已承诺为新贡献者提供额外帮助。另一种开始的方法是找到一个文档改进，比如一个丢失/断开的链接，这将给予你接触到代码提交/审查过程，而不会增加技术深度的复杂性。</p><h3><b>Github中的问题分配</b></h3><blockquote data-pid="XjezRFfn">Issue Assignment in Github</blockquote><p data-pid="RAZ8xbxF">当你发现一个问题要解决时，你可以将它分配给自己。</p><ul><li data-pid="6SYWon3g">就你希望解决的问题回复 <code>/assign</code> 或 <code>/assign @yourself</code></li><li data-pid="OO-qyC2O"><a href="https://github.com/k8s-ci-robot" target="_blank">K8s-ci-robot</a> 会自动将问题分配给你。</li><li data-pid="YT4oPEvT">你的姓名将列在 <code>Assignees</code> 下。</li></ul><h3><b>选择合适的 sig</b></h3><blockquote data-pid="IfsYMWvU">Find a SIG that is related to your contribution</blockquote><p data-pid="0LjdwsAQ">为你的贡献找到合适的SIG并添加SIG标签将有助于你在正确的位置提出问题，并给予你的贡献具有更高的可见性和更快的社区响应。</p><p data-pid="QZyedyDh">对于合并请求，自动分配的审阅者将添加SIG标签（如果你尚未添加）。</p><p data-pid="Tq9_xqeS">对于问题，请注意，社区正在开发一个更加自动化的工作流程。由于SIG不直接映射到Kubernetes子存储库，因此可能很难找到你的贡献属于哪个SIG。查看 <a href="https://github.com/kubernetes/community/blob/master/sig-list.md" target="_blank">SIG列表</a> 以确定哪个SIG最有可能与你的贡献相关。</p><p data-pid="-nzwZZf3">例如：如果你正在提交一个CNI问题（即容器网络接口），你将选择<a href="https://github.com/kubernetes/community/tree/master/sig-network" target="_blank">网络SIG</a>。在GitHub上的新评论中添加SIG标签，方法是键入以下内容：</p><div class="highlight"><pre><code class="language-text"> /sig network</code></pre></div><p data-pid="H0HOVwC3">按照SIG名称列中的链接访问每个SIG的README。</p><p data-pid="m8toSlRQ">大多数SIG都有一组GitHub团队，这些团队的标签可以在问题评论和拉取请求中提及，以获得更高的可见性。如果你不确定问题的正确SIG，可以尝试  <a href="https://github.com/kubernetes/community/blob/master/sig-contributor-experience/README.md" target="_blank">SIG-contributor-experience</a>, or <a href="http://slack.k8s.io/" target="_blank">ask in Slack</a>。</p><h3><b>SIG专用贡献指南</b></h3><p data-pid="qBQszAfN">一些SIG有自己的 <code>CONTRIBUTING.md</code> 文件，其中可能包含除了这些一般信息或指南之外的额外信息或指南。这些位于SIG特定的社区目录中：</p><ul><li data-pid="oxzijtyH"><code><a href="https://github.com/kubernetes/community/blob/master/sig-apps/CONTRIBUTING.md" target="_blank">/sig-apps/CONTRIBUTING.md</a></code></li><li data-pid="Ji5u1it8"><code><a href="https://github.com/kubernetes/community/blob/master/sig-cli/CONTRIBUTING.md" target="_blank">/sig-cli/CONTRIBUTING.md</a></code></li><li data-pid="6brrfSvN"><code><a href="https://github.com/kubernetes/community/blob/master/sig-multicluster/CONTRIBUTING.md" target="_blank">/sig-multicluster/CONTRIBUTING.md</a></code></li><li data-pid="-bF-PNJo"><code><a href="https://github.com/kubernetes/community/blob/master/sig-storage/CONTRIBUTING.md" target="_blank">/sig-storage/CONTRIBUTING.md</a></code></li><li data-pid="cMbpUIZB"><code><a href="https://github.com/kubernetes/community/blob/master/sig-windows/CONTRIBUTING.md" target="_blank">/sig-windows/CONTRIBUTING.md</a></code> </li></ul><h2><b>Kubernetes 分类指南</b></h2><ul><li data-pid="t2EuTCgV"><a href="https://github.com/kubernetes/community/blob/master/contributors/guide/issue-triage.md" target="_blank"><span class="invisible">https://</span><span class="visible">github.com/kubernetes/c</span><span class="invisible">ommunity/blob/master/contributors/guide/issue-triage.md</span><span class="ellipsis"></span></a></li></ul><p data-pid="WjrBae1f">Issue triage是一个SIG接收和审查新的GitHub问题和请求的过程，并将其组织起来，由自己的成员或其他SIG采取行动。</p><p data-pid="-6ff2Ig8">分类涉及根据优先级/紧急程度、问题的SIG所有权和问题类型（错误、功能等）等因素对问题和拉取请求进行分类。</p><h3><b>权限和机器人</b></h3><p data-pid="RVyqEJ4W">所有贡献者都可以打开新问题并对其他人的问题发表评论。但是，分配特定标签（如 <code>triage</code> ）、更改里程碑或关闭其他贡献者问题的权限仅授予问题的作者、受让人和组织成员。出于这个原因，我们使用机器人来管理标签和分类。有关bot的命令和权限的完整列表，请<a href="https://prow.k8s.io/command-help" target="_blank">参阅Prow命令参考页面</a>。</p><ul><li data-pid="y7JCF0Hl"><a href="https://prow.k8s.io/command-help" target="_blank"><span class="invisible">https://</span><span class="visible">prow.k8s.io/command-hel</span><span class="invisible">p</span><span class="ellipsis"></span></a></li></ul><p data-pid="lrjmnr-V">除了机器人，Kubernetes 还有一个特别有意思的工具，可以显示你当前哪些pull requests正在等待你的反馈，哪些PR正在等待贡献者响应。请注意，Gubernator只显示pull requests。你将看不到分配给你的问题。</p><ul><li data-pid="vA8G3UrE"><a href="https://gubernator.k8s.io/pr/cubxxw" target="_blank"><span class="invisible">https://</span><span class="visible">gubernator.k8s.io/pr/cu</span><span class="invisible">bxxw</span><span class="ellipsis"></span></a></li></ul><h3><b>标签分类</b></h3><p data-pid="eGO4A4wI">对于 Kubernetes 来说，标签分类很复杂，但是确实很有必要，能够帮助 member 快速的去定位和解决问题。</p><p data-pid="jGONmBir">在 Kubernetes 中的标签列表定义在 ：<a href="https://github.com/kubernetes/kubernetes/labels" target="_blank"><span class="invisible">https://</span><span class="visible">github.com/kubernetes/k</span><span class="invisible">ubernetes/labels</span><span class="ellipsis"></span></a></p><p data-pid="HKjW1TJH">新问题将自动分配 <code>needs-triage</code> 标签，指示这些问题当前正在等待分类。在对问题进行分类后，拥有SIG的问题将使用bot命令 <code>/triage accepted</code> 。此命令删除 <code>needs-triage</code> 标签并添加 <code>triage/accepted</code> 标签。</p><p data-pid="fuW8xBH1">请注意，添加标签需要Kubernetes GitHub org成员资格。如果你不是组织成员，你应该添加你的分类结果作为评论。</p><h3><b>进行搜索</b></h3><p data-pid="z0M3BhDm">GitHub允许你过滤出问题类型和拉取请求，这有助于你发现需要分类的项目。为方便起见，此表包括一些预定的搜索：</p><table data-draft-node="block" data-draft-type="table" data-size="normal" data-row-style="normal"><tbody><tr><th>Search</th><th>What it sorts 它的分类</th></tr><tr><td>created-asc</td><td>按年龄分类的未分类问题</td></tr><tr><td>needs-sig</td><td>需要分配给SIG的问题</td></tr><tr><td>is:open is:issue</td><td>最新收到的问题</td></tr><tr><td>comments-desc</td><td>最繁忙的未分类问题，按评论数排序</td></tr><tr><td>comments-asc</td><td>需要更多关注的问题，基于评论数</td></tr></tbody></table><p data-pid="IhNM0sCG">我们建议你先过滤掉最老的、未标记的问题和pull requests。</p><h3><b>按类型分类问题</b></h3><p data-pid="avV3UbpB">使用这些 <code>triage/</code> 和 <code>kind/support</code> 标签查找可以快速关闭的未决问题。分类工程师可以添加适当的标签。</p><p data-pid="4XnW_tdx"><code>triage/needs-information</code> 标签表示问题需要更多信息才能继续工作;评论或关闭它。</p><h3><b>Help Wanted/Good First Issues </b></h3><p data-pid="9cusPKTN">为了识别专门为新贡献者准备的问题，我们使用了 <a href="https://github.com/kubernetes/kubernetes/issues?q=is%3Aopen+is%3Aissue+label%3A%22help+wanted%22+sort%3Aupdated-desc" target="_blank">help wanted</a> and <a href="https://github.com/kubernetes/kubernetes/issues?q=is%3Aopen+is%3Aissue+label%3A%22good+first+issue%22+sort%3Aupdated-desc" target="_blank">good first issue</a> 标签。要使用这些标签，请执行以下操作：</p><ul><li data-pid="L6_v5Xty">如果问题满足这些准则，你可以使用 <code>/help</code> 命令添加 <code>help wanted</code> 标签。使用 <code>/good-first-issue</code> 命令创建 <code>good first issue</code> 标签。请注意，添加 <code>good first issue</code> 标签也会自动添加 <code>help wanted</code> 标签。</li><li data-pid="MMtA3v6d">如果某个问题有这些标签，但不符合指导原则，请询问要添加到该问题的更多详细信息，或使用 <code>/remove-help</code> 或 <code>/remove-good-first-issue</code> 命令删除标签。</li></ul><h3><b>Kind Labels</b></h3><p data-pid="Sy3FfiVt">GitHub 默认是没有 <code>Kind</code> 类型的，也就是说，为了方便管理， Kubernetes 对问题使用了 <code>Kind</code> 类型标签：</p><ul><li data-pid="lW4fHp6D"><a href="https://github.com/kubernetes/kubernetes/labels?q=kind" target="_blank"><span class="invisible">https://</span><span class="visible">github.com/kubernetes/k</span><span class="invisible">ubernetes/labels?q=kind</span><span class="ellipsis"></span></a></li></ul><p data-pid="vYpNIev9">通常 <code>kind</code> 标签由提交问题的人应用。错误的 <code>kind</code> 问题（例如，标记为bug的支持请求）可以由分类的人纠正;反复检查是个好办法。我们的问题模板旨在引导人们选择正确的类型。</p><ul><li data-pid="eijFtbnc"><a href="https://github.com/kubernetes/kubernetes/issues?q=is%3Aopen+label%3Akind%2Fdocumentation+sort%3Aupdated-desc" target="_blank">kind/documentation</a></li><li data-pid="mTMnPd0J"><a href="https://github.com/kubernetes/kubernetes/issues?q=is%3Aopen+label%3Akind%2Ffeature+sort%3Aupdated-desc" target="_blank">kind/feature</a></li><li data-pid="Eb2fp86M"><a href="https://github.com/kubernetes/kubernetes/issues?q=is%3Aopen+label%3Akind%2Fbug+sort%3Aupdated-desc" target="_blank">kind/bug</a></li><li data-pid="eLZaRc1t"><a href="https://github.com/kubernetes/kubernetes/issues?q=is%3Aopen+label%3Akind%2Fsupport+sort%3Aupdated-desc" target="_blank">kind/support</a></li><li data-pid="ZL-BMq9T"><a href="https://github.com/kubernetes/kubernetes/issues?q=is%3Aopen+label%3Akind%2Fcleanup+sort%3Aupdated-desc" target="_blank">kind/cleanup</a>: Categorizes issue or PR as related to cleaning up code, process, or technical debt.</li></ul><h3><b>Define Priority </b></h3><p data-pid="mtuP7Xzq">我们使用GitHub标签进行优先级排序。如果问题缺少 <code>priority</code> 标签，则意味着尚未对其进行评审和优先级排序。</p><p data-pid="wKJkKX05">我们的目标是整个项目的一致性。但是，如果你发现你认为优先级不正确的问题，请留下评论，提供你的反建议，我们将对其进行评估。</p><h3><b>找到并设置正确的SIG来拥有问题</b></h3><p data-pid="sMkh4YHG">各组成部分在特殊兴趣小组（SIG）之间进行划分。 机器人帮助找到合适的SIG来拥有问题。</p><p data-pid="nui88O4i"> 如果你认为可以解决此问题，请仅使用 <code>/assign</code> 命令将其分配给自己。如果你由于权限相关的原因无法自行分配，请留下你想要声明的评论并开始处理PR。</p><p data-pid="Sm7mKAlC">如果问题已经有受理人，请不要将其分配给你自己，也不要在未与现有受理人交谈或未完成本文档中所述的后续步骤之前创建PR。当其他人已经在处理一个问题时创建PR不是一个好的做法，不鼓励这样做。</p><p data-pid="s43JIQId">如果你发现分配了SIG标签的问题，但在30天内没有移动或讨论的证据，那么请轻轻地戳SIG关于此未决问题。另外，考虑参加他们的一次会议，提出这个问题。</p><p data-pid="bdrikGMl"> 当问题90天没有活动时，k8s-triage-robot会将 <code>lifecycle/stale</code> 标签添加到该问题。你可以通过抢先应用 <code>/lifecycle frozen</code> 标签来阻止bot，或者使用 <code>/remove-lifecycle stale</code> 命令删除标签。k8s-triage-robot在问题中添加了评论，包括其他细节。如果你不采取任何步骤，问题最终将自动关闭。</p><p></p></div> </details> 
 <hr /> 

 #### - [高级的 Githook 设计](https://zhuanlan.zhihu.com/p/629617458) 
 <details><summary>توضیحات</summary> <p><img src="https://picx.zhimg.com/v2-4ff73ff11d72de6e14b7a5a79d9d63a5_720w.jpg?source=d16d100b"></p><div><ul><li data-pid="jOLHfQQx"><a href="http://nsddd.top/" target="_blank">author</a></li></ul><h2><b>高级的 Githook 设计</b></h2><blockquote data-pid="qkTUiQI3">❤️  记录<a href="https://github.com/3293172751/sealos" target="_blank">sealos</a>开源项目的学习过程。<a href="https://github.com/3293172751/sealos" target="_blank">k8s,docker和云原生的学习</a>。Myblog:<a href="http://nsddd.top/" target="_blank">http://nsddd.top</a></blockquote><h2><b>社区不规范怎么办</b></h2><p data-pid="rrhQGarT">作为 <a href="https://github.com/OpenIMSDK" target="_blank">OpenIM</a> 社区首席运营官，对整个社区的 <a href="https://github.com/OpenIMSDK/community" target="_blank">communtiy</a> 以及 <a href="https://github.com/OpenIMSDK/.github" target="_blank">GitHub 配置仓库</a> 进行了全面的配置。并且对整个 OpenIM 的 <code>Makefile</code> 和 <code>CICD</code> 流，以及整个 OpenIM 使用的日志包 、错误码、协同流、贡献者文档以及 社区文档 进行架构和设计。</p><p data-pid="NgLuZBJn">在这个时候总会有一些问题，即使你觉得自己的 <a href="https://github.com/OpenIMSDK/Open-IM-Server/blob/main/CONTRIBUTING.md" target="_blank">贡献者文档</a> 写的很牛逼了，很全面了，但是依旧很少有人愿意花心思去按照你写的规范去学习。这对我打造顶级的开源社区是一个非常大的阻碍，于是就有了今天的这个文档，我会将它记录在 <a href="https://gist.github.com/cubxxw/126b72104ac0b0ca484c9db09c3e5694" target="_blank">GitHub Gists</a> 上，提供拉取和使用的说明、链接，并且定期的维护它。</p><p data-pid="aqDE3RyN">首先，我提供克隆的链接：</p><div class="highlight"><pre><code class="language-bash"> git clone https://gist.github.com/cubxxw/126b72104ac0b0ca484c9db09c3e5694</code></pre></div><h2><b>如何设计</b></h2><p data-pid="rMPb7oNq">首先是针对基础的功能，那就是我们熟知的 <code>commit</code> 信息和 <code>push</code> 信息。</p><ul><li data-pid="n5BKdrsf">我们可以对 <code>commit</code> 信息的格式进行设置</li><li data-pid="wh-P909W">我们可以对 <code>push</code> 的大小进行设置</li><li data-pid="YNLMyPun">我们提供了 <code>actions</code> 的功能</li><li data-pid="xf2WCmo1">我们提供了 <code>Makefile</code> 标记和清除 <code>Hook</code> 的能力</li></ul><p data-pid="Ko1jG3ih">我之前在学习 git 的时候写了一篇很全的笔记，并且分享在 GitHub 上面，在这个 <a href="https://github.com/cubxxw/awesome-cs-course/blob/master/Git/README.md" target="_blank">  链接</a> 上可以学习到 git 很多高级用法。</p><blockquote data-pid="_sFcy3C5">这篇文章讲解了 git 有哪些规范，寻找合适的 CICD 流：<br>统一格式：<br> 统一格式：git commit -m 'type(scope): 描述(#issue)'<br>我们在提交的时候带上邮箱信息 <code>-s</code> 来签证，这是一个很好的习惯。 <br> git commit -s -m "..."<br><code>git commit</code>艺术：<br> &lt;类型&gt;[可选 范围]: &lt;描述&gt;<br> [可选 正文]<br> [可选 脚注]<br><code>git commit</code>提交类型可以是如下：</blockquote><ol><li data-pid="toH1wa6s"><code>feat</code>：新功能（feature）</li><li data-pid="tv7apGIT"><code>fix</code>：修补bug</li><li data-pid="H-5CAp-Z"><code>docs</code>：文档（documentation）</li><li data-pid="4siEfJIx"><code>style</code>： 格式（不影响代码运行的变动）</li><li data-pid="FXehgkHm"><code>refactor</code>：重构（即不是新增功能，也不是修改bug的代码变动）</li><li data-pid="788Mug9m"><code>test</code>：增加测试</li><li data-pid="ODfG1fHV"><code>chore</code>：构建过程或辅助工具的变动</li><li data-pid="sKD1XRsW"><code>perf</code>：性能优化</li><li data-pid="tuXfHiHT"><code>revert</code>：回滚</li><li data-pid="ZnbAOZ2i"><code>build</code>：构建</li><li data-pid="6eketvro"><code>ci</code>：持续集成</li></ol><p data-pid="-KN1N-Cn"><b>⚠️ 使用这个 Git hook 应该注意什么？</b></p><ul><li data-pid="aOZbIA05">这个 <code>git hook</code> 会在你不小心上传大文件的时候，阻止你，并且警告你，这是不可逆转的</li><li data-pid="v3qgSg1H">这个 <code>git hook</code> 会在你没有办法控制提交格式的时候，让你很痛苦。</li></ul><h2><b>如何使用</b></h2><p data-pid="r_ZKUd96"><b>你可以选择两种方式来使用 Git hook:</b></p><ol><li data-pid="snCF0BEC">直接作为 <code>.git/hooks</code>文件夹中的 <code>pre-commit</code> 钩子。</li><li data-pid="BNOGzEgz">使用 Husky 更新您的 <code>package.json</code>：</li></ol><p data-pid="y_dhl9I8"><a href="https://github.com/cubxxw/awesome-cs-course/blob/master/Git/README.md" target="_blank">Husky</a> 使得 git hook 变的更加容易和方便：</p><div class="highlight"><pre><code class="language-json"> <span class="s2">"husky"</span><span class="err">:</span> <span class="p">{</span>
     <span class="nt">"hooks"</span><span class="p">:</span> <span class="p">{</span>
       <span class="nt">"pre-commit"</span><span class="p">:</span> <span class="s2">"sh ./some-path/pre-commit-prevent-large-files.sh"</span>
     <span class="p">}</span>
 <span class="p">}</span></code></pre></div><p data-pid="U1zbkr2_">这个钩子我是为 <a href="https://github.com/OpenIMSDK/Open-IM-Server/" target="_blank">OpenIM</a> 社区项目设计的，但是转念一想，反正都做成很方便和高端的 <a href="https://gist.github.com/cubxxw/126b72104ac0b0ca484c9db09c3e5694" target="_blank">Github Gist</a> 了，为何不用 Gist 的特性来对 Git Hook 做一个记录和保存，后期提供维护和下载，也提供了一个交流平台，这是非常 perfect 的。</p><p data-pid="jPr_nNsc">所以我第一步，利用了 <a href="https://gist.github.com/cubxxw/126b72104ac0b0ca484c9db09c3e5694" target="_blank">GitHub Gist</a> 提供了一个下载的通道，这样以后有别的项目也可以直接一键使用脚本来拉取到本地。</p><p data-pid="_jFP2RtS">不仅仅如此，我针对提交设计了一个<a href="https://gist.githubusercontent.com/cubxxw/126b72104ac0b0ca484c9db09c3e5694/raw/gitsync.sh" target="_blank">脚本</a>，我们使用脚本可以一键并且规范的 push 到远程仓库。</p><div class="highlight"><pre><code class="language-bash"> curl -L https://gist.githubusercontent.com/cubxxw/126b72104ac0b0ca484c9db09c3e5694/raw/gitsync.sh <span class="p">|</span>sh</code></pre></div><p data-pid="9oF4KARI"><b>默认限制为每个文件最大5MB。如果你觉得你的提交是一个特例，你可以使用以下命令覆盖这个限制：</b></p><div class="highlight"><pre><code class="language-bash"> <span class="nv">GIT_FILE_SIZE_LIMIT</span><span class="o">=</span><span class="m">50000000</span> git commit -m <span class="s2">"test: this commit is allowed file sizes up to 50MB"</span>
 <span class="c1"># OR</span>
 git commit --no-verify</code></pre></div><p data-pid="CzID83Uh">我不关心任何特定的文件，只是限制整个提交本身，这至少应该使开发人员的事情两次之前，他们可能会作出决定 <code>git commit --no-verify</code></p><p data-pid="TeDUTloD"><b>可复用脚本一键安装：</b></p><div class="highlight"><pre><code class="language-bash"> curl -L https://gist.github.com/cubxxw/126b72104ac0b0ca484c9db09c3e5694/raw/install.sh <span class="p">|</span>bash</code></pre></div><h2><b>Contents</b></h2><ul><li data-pid="k5biEa87"><a href="https://gist.github.com/cubxxw/126b72104ac0b0ca484c9db09c3e5694#file-install-sh" target="_blank">使用安装脚本</a></li><li data-pid="z7wTA9Yl"><a href="https://gist.github.com/cubxxw/126b72104ac0b0ca484c9db09c3e5694#file-commit-msg" target="_blank">commit 的信息</a></li><li data-pid="qgbQUftY"><a href="https://gist.github.com/cubxxw/126b72104ac0b0ca484c9db09c3e5694#file-gitsync-sh" target="_blank">自动 push 一键流脚本 gitsync</a></li><li data-pid="q8_EDf_z"><a href="https://gist.github.com/cubxxw/126b72104ac0b0ca484c9db09c3e5694#file-makefile" target="_blank">Makefile</a></li><li data-pid="OLmlaJvt"><a href="https://gist.github.com/cubxxw/126b72104ac0b0ca484c9db09c3e5694#file-pre-commit" target="_blank">预提交：钩子本身: pre-commit</a></li><li data-pid="Dpec6hl6"><a href="https://gist.github.com/cubxxw/126b72104ac0b0ca484c9db09c3e5694#file-pre-push" target="_blank">提交 push 处理</a></li></ul><blockquote data-pid="johq_Di3"><b>Note</b> 点击右上角 <code>Raw</code> 进入脚本文件</blockquote><h2><b>可复用的安装脚本 </b></h2><div class="highlight"><pre><code class="language-bash"> <span class="c1">#!/bin/sh</span>
 <span class="nb">set</span> -e
 <span class="nb">echo</span> <span class="s2">"Starting install script..."</span>
 ​
 <span class="nv">SET_GIT_TEMPLATE_DIR</span><span class="o">=</span><span class="nb">false</span>
 <span class="nv">EXISTING_TEMPLATE</span><span class="o">=</span><span class="k">$(</span>git config --global init.templateDir <span class="o">||</span> <span class="nb">echo</span> <span class="s2">""</span><span class="k">)</span>
 <span class="k">if</span> <span class="o">[</span> -z <span class="s2">"</span><span class="nv">$EXISTING_TEMPLATE</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
   <span class="nb">echo</span> <span class="s2">"Creating a new global git template dir at ~/.git_template"</span>
   mkdir ~/.git_template
   <span class="nv">EXISTING_TEMPLATE</span><span class="o">=</span><span class="s2">"</span><span class="k">$(</span><span class="nb">cd</span> ~<span class="p">;</span> <span class="nb">pwd</span> -P<span class="k">)</span><span class="s2">/.git_template"</span>
   <span class="nv">SET_GIT_TEMPLATE_DIR</span><span class="o">=</span><span class="nb">true</span>
 <span class="k">else</span>
   <span class="nv">EXISTING_TEMPLATE</span><span class="o">=</span><span class="s2">"</span><span class="k">$(</span><span class="nb">eval</span> <span class="nb">cd</span> <span class="k">$(</span>dirname <span class="s2">"</span><span class="nv">$EXISTING_TEMPLATE</span><span class="s2">"</span><span class="k">)</span><span class="p">;</span> <span class="nb">pwd</span> -P<span class="k">)</span><span class="s2">/</span><span class="k">$(</span>basename <span class="s2">"</span><span class="nv">$EXISTING_TEMPLATE</span><span class="s2">"</span><span class="k">)</span><span class="s2">"</span>
   <span class="nb">echo</span> <span class="s2">"Using existing git template dir: </span><span class="nv">$EXISTING_TEMPLATE</span><span class="s2">"</span>
 <span class="k">fi</span>
 ​
 <span class="nv">HOOKS_DIR</span><span class="o">=</span><span class="s2">"</span><span class="nv">$EXISTING_TEMPLATE</span><span class="s2">/hooks"</span>
 <span class="nv">PRECOMMIT_HOOK</span><span class="o">=</span><span class="s2">"</span><span class="nv">$HOOKS_DIR</span><span class="s2">/pre-commit"</span>
 <span class="nb">echo</span> <span class="s2">"Creating hooks dir if it doesn't already exist: </span><span class="nv">$HOOKS_DIR</span><span class="s2">"</span>
 mkdir -p <span class="s2">"</span><span class="nv">$HOOKS_DIR</span><span class="s2">"</span>
 <span class="k">if</span> <span class="o">[</span> -f <span class="s2">"</span><span class="nv">$PRECOMMIT_HOOK</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
   <span class="nb">echo</span> <span class="s2">"Cannot install hook as it's already defined: '</span><span class="nv">$PRECOMMIT_HOOK</span><span class="s2">'"</span> &gt;<span class="p">&amp;</span><span class="m">2</span>
   <span class="nb">exit</span> <span class="m">1</span>
 <span class="k">fi</span>
 ​
 <span class="nb">echo</span> <span class="s2">"Downloading the hook to </span><span class="nv">$PRECOMMIT_HOOK</span><span class="s2">"</span>
 curl -L https://gist.github.com/cubxxw/126b72104ac0b0ca484c9db09c3e5694/raw/pre-commit -o <span class="s2">"</span><span class="nv">$PRECOMMIT_HOOK</span><span class="s2">"</span> 2&gt; /dev/null
 curl -L https://gist.github.com/cubxxw/126b72104ac0b0ca484c9db09c3e5694/raw/commit-msg -o <span class="s2">"</span><span class="nv">$PRECOMMIT_HOOK</span><span class="s2">"</span> 2&gt; /dev/null
 curl -L https://gist.github.com/cubxxw/126b72104ac0b0ca484c9db09c3e5694/raw/pre-push -o <span class="s2">"</span><span class="nv">$PRECOMMIT_HOOK</span><span class="s2">"</span> 2&gt; /dev/null
 ​
 <span class="nb">echo</span> <span class="s2">"Making it executable"</span>
 chmod +x <span class="s2">"</span><span class="nv">$PRECOMMIT_HOOK</span><span class="s2">"</span>
 ​
 <span class="k">if</span> <span class="o">[</span> <span class="s2">"</span><span class="nv">$SET_GIT_TEMPLATE_DIR</span><span class="s2">"</span> <span class="o">=</span> <span class="nb">true</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
   <span class="nb">echo</span> <span class="s2">"Defining ~/.git_template as the global git template dir"</span>
   git config --global init.templateDir <span class="s1">'~/.git_template'</span>
 <span class="k">fi</span>
 ​
 <span class="nb">echo</span> -e <span class="s2">"\nDone! Any future git repo created in this user profile will contain the hook\n"</span>
 ​
 ​
 <span class="c1">##################################################</span>
 <span class="nv">GIT_PATH</span><span class="o">=</span><span class="k">$(</span>git rev-parse --show-toplevel<span class="k">)</span>
 <span class="nb">echo</span> <span class="s2">"===&gt; Copying hooks to </span><span class="nv">$GIT_PATH</span><span class="s2">/.git/hooks/"</span>
 mv ~/.git_template/hooks/* <span class="nv">$GIT_PATH</span>/.git/hooks/</code></pre></div><h2><b>git commit 设置</b></h2><p data-pid="-4VV3Sb_"><b>pre-commit 文件:</b></p><div class="highlight"><pre><code class="language-bash"> <span class="c1">#!/usr/bin/env bash</span>
 ​
 <span class="c1"># Copyright © 2023 OpenIMSDK.</span>
 <span class="c1">#</span>
 <span class="c1"># Licensed under the Apache License, Version 2.0 (the "License");</span>
 <span class="c1"># you may not use this file except in compliance with the License.</span>
 <span class="c1"># You may obtain a copy of the License at</span>
 <span class="c1">#</span>
 <span class="c1">#     http://www.apache.org/licenses/LICENSE-2.0</span>
 <span class="c1">#</span>
 <span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
 <span class="c1"># distributed under the License is distributed on an "AS IS" BASIS,</span>
 <span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
 <span class="c1"># See the License for the specific language governing permissions and</span>
 <span class="c1"># limitations under the License.</span>
 <span class="c1">#</span>
 <span class="c1"># ==============================================================================</span>
 <span class="c1"># This is a pre-commit hook that ensures attempts to commit files that are</span>
 <span class="c1"># are larger than $limit to your _local_ repo fail, with a helpful error message.</span>
 ​
 <span class="c1"># You can override the default limit of 2MB by supplying the environment variable:</span>
 <span class="c1"># GIT_FILE_SIZE_LIMIT=50000000 git commit -m "test: this commit is allowed file sizes up to 50MB"</span>
 <span class="c1">#</span>
 <span class="c1"># ==============================================================================</span>
 ​
 ​
 <span class="nv">YELLOW</span><span class="o">=</span><span class="s2">"\e[93m"</span>
 <span class="nv">GREEN</span><span class="o">=</span><span class="s2">"\e[32m"</span>
 <span class="nv">RED</span><span class="o">=</span><span class="s2">"\e[31m"</span>
 <span class="nv">ENDCOLOR</span><span class="o">=</span><span class="s2">"\e[0m"</span>
 ​
 printMessage<span class="o">()</span> <span class="o">{</span>
    <span class="nb">printf</span> <span class="s2">"</span><span class="si">${</span><span class="nv">YELLOW</span><span class="si">}</span><span class="s2">OpenIM : </span><span class="nv">$1</span><span class="si">${</span><span class="nv">ENDCOLOR</span><span class="si">}</span><span class="s2">\n"</span>
 <span class="o">}</span>
 ​
 printSuccess<span class="o">()</span> <span class="o">{</span>
    <span class="nb">printf</span> <span class="s2">"</span><span class="si">${</span><span class="nv">GREEN</span><span class="si">}</span><span class="s2">OpenIM : </span><span class="nv">$1</span><span class="si">${</span><span class="nv">ENDCOLOR</span><span class="si">}</span><span class="s2">\n"</span>
 <span class="o">}</span>
 ​
 printError<span class="o">()</span> <span class="o">{</span>
    <span class="nb">printf</span> <span class="s2">"</span><span class="si">${</span><span class="nv">RED</span><span class="si">}</span><span class="s2">OpenIM : </span><span class="nv">$1</span><span class="si">${</span><span class="nv">ENDCOLOR</span><span class="si">}</span><span class="s2">\n"</span>
 <span class="o">}</span>
 ​
 printMessage <span class="s2">"Running local OpenIM pre-commit hook."</span>
 ​
 <span class="c1"># flutter format .</span>
 <span class="c1"># https://gist.github.com/cubxxw/126b72104ac0b0ca484c9db09c3e5694</span>
 <span class="c1"># TODO! GIT_FILE_SIZE_LIMIT=50000000 git commit -m "test: this commit is allowed file sizes up to 50MB"</span>
 <span class="c1"># Maximum file size limit in bytes</span>
 <span class="nv">limit</span><span class="o">=</span><span class="si">${</span><span class="nv">GIT_FILE_SIZE_LIMIT</span><span class="k">:-</span><span class="nv">2000000</span><span class="si">}</span> <span class="c1"># Default 2MB</span>
 <span class="nv">limitInMB</span><span class="o">=</span><span class="k">$((</span> <span class="nv">$limit</span> <span class="o">/</span> <span class="m">1000000</span> <span class="k">))</span>
 ​
 <span class="k">function</span> file_too_large<span class="o">(){</span>
     <span class="nv">filename</span><span class="o">=</span><span class="nv">$0</span>
     <span class="nv">filesize</span><span class="o">=</span><span class="k">$((</span> <span class="nv">$1</span> <span class="o">/</span> <span class="m">2</span><span class="o">**</span><span class="m">20</span> <span class="k">))</span>
 ​
     cat <span class="s">&lt;&lt;HEREDOC
</span><span class="s"> ​
</span><span class="s">     File $filename is $filesize MB, which is larger than github's maximum
</span><span class="s">         file size (2 MB). We will not be able to push this file to GitHub.
</span><span class="s">     Commit aborted
</span><span class="s"> ​
</span><span class="s"> HEREDOC</span>
     git status
 ​
 <span class="o">}</span>
 ​
 <span class="c1"># Move to the repo root so git files paths make sense</span>
 <span class="nv">repo_root</span><span class="o">=</span><span class="k">$(</span> git rev-parse --show-toplevel <span class="k">)</span>
 <span class="nb">cd</span> <span class="nv">$repo_root</span>
 ​
 <span class="nv">empty_tree</span><span class="o">=</span><span class="k">$(</span> git hash-object -t tree /dev/null <span class="k">)</span>
 ​
 <span class="k">if</span> git rev-parse --verify HEAD &gt; /dev/null 2&gt;<span class="p">&amp;</span><span class="m">1</span>
 <span class="k">then</span>
     <span class="nv">against</span><span class="o">=</span>HEAD
 <span class="k">else</span>
     <span class="nv">against</span><span class="o">=</span><span class="s2">"</span><span class="nv">$empty_tree</span><span class="s2">"</span>
 <span class="k">fi</span>
 ​
 <span class="c1"># Set split so that for loop below can handle spaces in file names by splitting on line breaks</span>
 <span class="nv">IFS</span><span class="o">=</span><span class="s1">'
</span><span class="s1"> '</span>
 ​
 <span class="nv">shouldFail</span><span class="o">=</span><span class="nb">false</span>
 <span class="k">for</span> file in <span class="k">$(</span> git diff-index --cached --name-only <span class="nv">$against</span> <span class="k">)</span><span class="p">;</span> <span class="k">do</span>
     <span class="nv">file_size</span><span class="o">=</span><span class="k">$((</span><span class="o">[</span> ! <span class="o">-</span>f <span class="nv">$file</span> <span class="o">]</span> <span class="o">&amp;&amp;</span> <span class="nb">echo</span> <span class="m">0</span><span class="o">)</span> <span class="o">||</span> <span class="o">(</span>ls <span class="o">-</span>la <span class="nv">$file</span> <span class="o">|</span> awk <span class="s1">'{ print $5 }'</span><span class="k">))</span>
     <span class="k">if</span> <span class="o">[</span> <span class="s2">"</span><span class="nv">$file_size</span><span class="s2">"</span> -gt  <span class="s2">"</span><span class="nv">$limit</span><span class="s2">"</span> <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
         printError <span class="s2">"File </span><span class="nv">$file</span><span class="s2"> is </span><span class="k">$((</span> <span class="nv">$file_size</span> <span class="o">/</span> <span class="m">10</span><span class="o">**</span><span class="m">6</span> <span class="k">))</span><span class="s2"> MB, which is larger than our configured limit of </span><span class="nv">$limitInMB</span><span class="s2"> MB"</span>
         <span class="nv">shouldFail</span><span class="o">=</span><span class="nb">true</span>
     <span class="k">fi</span>
 <span class="k">done</span>
 ​
 <span class="k">if</span> <span class="nv">$shouldFail</span>
 <span class="k">then</span>
     printMessage <span class="s2">"If you really need to commit this file, you can override the size limit by setting the GIT_FILE_SIZE_LIMIT environment variable, e.g. GIT_FILE_SIZE_LIMIT=42000000 for 42MB. Or, commit with the --no-verify switch to skip the check entirely."</span>
       printError <span class="s2">"Commit aborted"</span>
     <span class="nb">exit</span> 1<span class="p">;</span>
 <span class="k">fi</span></code></pre></div><p class="ztext-empty-paragraph"><br></p><p data-pid="EfADw5Wk"><b>commit-msg</b></p><div class="highlight"><pre><code class="language-bash"> <span class="c1">#!/usr/bin/env bash</span>
 ​
 <span class="c1"># Copyright © 2023 OpenIMSDK.</span>
 <span class="c1">#</span>
 <span class="c1"># Licensed under the Apache License, Version 2.0 (the "License");</span>
 <span class="c1"># you may not use this file except in compliance with the License.</span>
 <span class="c1"># You may obtain a copy of the License at</span>
 <span class="c1">#</span>
 <span class="c1">#     http://www.apache.org/licenses/LICENSE-2.0</span>
 <span class="c1">#</span>
 <span class="c1"># Unless required by applicable law or agreed to in writing, software</span>
 <span class="c1"># distributed under the License is distributed on an "AS IS" BASIS,</span>
 <span class="c1"># WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
 <span class="c1"># See the License for the specific language governing permissions and</span>
 <span class="c1"># limitations under the License.</span>
 <span class="c1">#</span>
 <span class="c1"># ==============================================================================</span>
 <span class="c1">#</span>
 <span class="c1"># Store this file as .git/hooks/commit-msg in your repository in order to</span>
 <span class="c1"># enforce checking for proper commit message format before actual commits.</span>
 <span class="c1"># You may need to make the script executable by 'chmod +x .git/hooks/commit-msg'.</span>
 ​
 <span class="c1"># commit-msg use go-gitlint tool, install go-gitlint via `go get github.com/llorllale/go-gitlint/cmd/go-gitlint`</span>
 <span class="c1"># go-gitlint --msg-file="$1"</span>
 ​
 <span class="c1"># An example hook script to check the commit log message.</span>
 <span class="c1"># Called by "git commit" with one argument, the name of the file</span>
 <span class="c1"># that has the commit message.  The hook should exit with non-zero</span>
 <span class="c1"># status after issuing an appropriate message if it wants to stop the</span>
 <span class="c1"># commit.  The hook is allowed to edit the commit message file.</span>
 ​
 <span class="nv">YELLOW</span><span class="o">=</span><span class="s2">"\e[93m"</span>
 <span class="nv">GREEN</span><span class="o">=</span><span class="s2">"\e[32m"</span>
 <span class="nv">RED</span><span class="o">=</span><span class="s2">"\e[31m"</span>
 <span class="nv">ENDCOLOR</span><span class="o">=</span><span class="s2">"\e[0m"</span>
 ​
 printMessage<span class="o">()</span> <span class="o">{</span>
    <span class="nb">printf</span> <span class="s2">"</span><span class="si">${</span><span class="nv">YELLOW</span><span class="si">}</span><span class="s2">OpenIM : </span><span class="nv">$1</span><span class="si">${</span><span class="nv">ENDCOLOR</span><span class="si">}</span><span class="s2">\n"</span>
 <span class="o">}</span>
 ​
 printSuccess<span class="o">()</span> <span class="o">{</span>
    <span class="nb">printf</span> <span class="s2">"</span><span class="si">${</span><span class="nv">GREEN</span><span class="si">}</span><span class="s2">OpenIM : </span><span class="nv">$1</span><span class="si">${</span><span class="nv">ENDCOLOR</span><span class="si">}</span><span class="s2">\n"</span>
 <span class="o">}</span>
 ​
 printError<span class="o">()</span> <span class="o">{</span>
    <span class="nb">printf</span> <span class="s2">"</span><span class="si">${</span><span class="nv">RED</span><span class="si">}</span><span class="s2">OpenIM : </span><span class="nv">$1</span><span class="si">${</span><span class="nv">ENDCOLOR</span><span class="si">}</span><span class="s2">\n"</span>
 <span class="o">}</span>
 ​
 printMessage <span class="s2">"Running the OpenIM commit-msg hook."</span>
 ​
 <span class="c1"># This example catches duplicate Signed-off-by lines.</span>
 ​
 <span class="nb">test</span> <span class="s2">""</span> <span class="o">=</span> <span class="s2">"</span><span class="k">$(</span>grep <span class="s1">'^Signed-off-by: '</span> <span class="s2">"</span><span class="nv">$1</span><span class="s2">"</span> <span class="p">|</span>
      sort <span class="p">|</span> uniq -c <span class="p">|</span> sed -e <span class="s1">'/^[   ]*1[    ]/d'</span><span class="k">)</span><span class="s2">"</span> <span class="o">||</span> <span class="o">{</span>
     <span class="nb">echo</span> &gt;<span class="p">&amp;</span><span class="m">2</span> Duplicate Signed-off-by lines.
     <span class="nb">exit</span> <span class="m">1</span>
 <span class="o">}</span>
 ​
 ./tools/go-gitlint <span class="se">\
</span><span class="se"></span>      --msg-file<span class="o">=</span><span class="nv">$1</span> <span class="se">\
</span><span class="se"></span>      --subject-regex<span class="o">=</span><span class="s2">"^(build|chore|ci|docs|feat|feature|fix|perf|refactor|revert|style|test)(.*)?:\s?.*"</span> <span class="se">\
</span><span class="se"></span>     --subject-maxlen<span class="o">=</span><span class="m">150</span> <span class="se">\
</span><span class="se"></span>     --subject-minlen<span class="o">=</span><span class="m">10</span> <span class="se">\
</span><span class="se"></span>     --body-regex<span class="o">=</span><span class="s2">".*"</span> <span class="se">\
</span><span class="se"></span>     --max-parents<span class="o">=</span><span class="m">1</span>
 ​
 <span class="k">if</span> <span class="o">[</span> <span class="nv">$?</span> -ne <span class="m">0</span> <span class="o">]</span>
 <span class="k">then</span>
     printError <span class="s2">"Please fix your commit message to match OpenIM coding standards"</span>
     printError <span class="s2">"https://gist.github.com/cubxxw/126b72104ac0b0ca484c9db09c3e5694"</span>
     <span class="nb">exit</span> <span class="m">1</span>
 <span class="k">fi</span></code></pre></div><p class="ztext-empty-paragraph"><br></p><h2><b>push </b></h2><div class="highlight"><pre><code class="language-bash"> <span class="c1">#!/usr/bin/env bash</span>
 ​
 <span class="nv">YELLOW</span><span class="o">=</span><span class="s2">"\e[93m"</span>
 <span class="nv">GREEN</span><span class="o">=</span><span class="s2">"\e[32m"</span>
 <span class="nv">RED</span><span class="o">=</span><span class="s2">"\e[31m"</span>
 <span class="nv">ENDCOLOR</span><span class="o">=</span><span class="s2">"\e[0m"</span>
 ​
 printMessage<span class="o">()</span> <span class="o">{</span>
    <span class="nb">printf</span> <span class="s2">"</span><span class="si">${</span><span class="nv">YELLOW</span><span class="si">}</span><span class="s2">OpenIM : </span><span class="nv">$1</span><span class="si">${</span><span class="nv">ENDCOLOR</span><span class="si">}</span><span class="s2">\n"</span>
 <span class="o">}</span>
 ​
 printSuccess<span class="o">()</span> <span class="o">{</span>
    <span class="nb">printf</span> <span class="s2">"</span><span class="si">${</span><span class="nv">GREEN</span><span class="si">}</span><span class="s2">OpenIM : </span><span class="nv">$1</span><span class="si">${</span><span class="nv">ENDCOLOR</span><span class="si">}</span><span class="s2">\n"</span>
 <span class="o">}</span>
 ​
 printError<span class="o">()</span> <span class="o">{</span>
    <span class="nb">printf</span> <span class="s2">"</span><span class="si">${</span><span class="nv">RED</span><span class="si">}</span><span class="s2">OpenIM : </span><span class="nv">$1</span><span class="si">${</span><span class="nv">ENDCOLOR</span><span class="si">}</span><span class="s2">\n"</span>
 <span class="o">}</span>
 ​
 printMessage <span class="s2">"Running local OpenIM pre-push hook."</span>
 ​
 <span class="k">if</span> <span class="o">[[</span> <span class="sb">`</span>git status --porcelain<span class="sb">`</span> <span class="o">]]</span><span class="p">;</span> <span class="k">then</span>
   printError <span class="s2">"This script needs to run against committed code only. Please commit or stash you changes."</span>
   <span class="nb">exit</span> <span class="m">1</span>
 <span class="k">fi</span>
 ​
 <span class="c1">#</span>
 <span class="c1">#printMessage "Running the Flutter analyzer"</span>
 <span class="c1">#flutter analyze</span>
 <span class="c1">#</span>
 <span class="c1">#if [ $? -ne 0 ]; then</span>
 <span class="c1">#  printError "Flutter analyzer error"</span>
 <span class="c1">#  exit 1</span>
 <span class="c1">#fi</span>
 <span class="c1">#</span>
 <span class="c1">#printMessage "Finished running the Flutter analyzer"</span>
 ​</code></pre></div><p class="ztext-empty-paragraph"><br></p><h2><b>actions</b></h2><p data-pid="n5cJvHgj"><code>git-warning.yml</code> 文件：</p><div class="highlight"><pre><code class="language-yaml"><span class="w"> </span><span class="c"># This workflow will check for large files being added in PRs</span><span class="w">
</span><span class="w"> </span><span class="c"># and label the PR if one is found that exceeds the configured limit.</span><span class="w">
</span><span class="w"> </span><span class="c">#</span><span class="w">
</span><span class="w"> </span><span class="c"># For more information, see: https://github.com/marketplace/actions/lfs-warning</span><span class="w">
</span><span class="w"> </span><span class="l">​</span><span class="w">
</span><span class="w"> </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">Large file size warning</span><span class="w">
</span><span class="w"> </span><span class="l">​</span><span class="w">
</span><span class="w"> </span><span class="nt">on</span><span class="p">:</span><span class="w"> 
</span><span class="w">   </span><span class="nt">pull_request</span><span class="p">:</span><span class="w">
</span><span class="w">     </span><span class="c"># Ignore some files to avoid consuming Actions minutes unnecessarily </span><span class="w">
</span><span class="w">     </span><span class="c"># for file types we're fairly confident we'll never need to worry about</span><span class="w">
</span><span class="w">     </span><span class="nt">paths-ignore</span><span class="p">:</span><span class="w"> 
</span><span class="w">       </span>- <span class="s1">'**.config'</span><span class="w">
</span><span class="w">       </span>- <span class="s1">'**.cs'</span><span class="w">
</span><span class="w">       </span>- <span class="s1">'**.cshtml'</span><span class="w">
</span><span class="w">       </span>- <span class="s1">'**.cs'</span><span class="w">
</span><span class="w">       </span>- <span class="s1">'**.csproj'</span><span class="w">
</span><span class="w">       </span>- <span class="s1">'**.cmd'</span><span class="w">
</span><span class="w">       </span>- <span class="s1">'**.dockerignore'</span><span class="w">
</span><span class="w">       </span>- <span class="s1">'**.gitignore'</span><span class="w">
</span><span class="w">       </span>- <span class="s1">'**.graphql'</span><span class="w">
</span><span class="w">       </span>- <span class="s1">'**.jsx?'</span><span class="w">
</span><span class="w">       </span>- <span class="s1">'**.md'</span><span class="w">
</span><span class="w">       </span>- <span class="s1">'**.props'</span><span class="w">
</span><span class="w">       </span>- <span class="s1">'**.ps1'</span><span class="w">
</span><span class="w">       </span>- <span class="s1">'**.scss'</span><span class="w">
</span><span class="w">       </span>- <span class="s1">'**.sh'</span><span class="w">
</span><span class="w">       </span>- <span class="s1">'**.sln'</span><span class="w">
</span><span class="w">       </span>- <span class="s1">'**.tsx?'</span><span class="w">
</span><span class="w">       </span>- <span class="s1">'**.yml'</span><span class="w">
</span><span class="w">       </span>- <span class="s1">'**/appsettings.*.json'</span><span class="w">
</span><span class="w">       </span>- <span class="s1">'**/Dockerfile'</span><span class="w">
</span><span class="w">       
</span><span class="w"> </span><span class="nt">jobs</span><span class="p">:</span><span class="w">
</span><span class="w">   </span><span class="nt">run-check</span><span class="p">:</span><span class="w">
</span><span class="w">     </span><span class="nt">runs-on</span><span class="p">:</span><span class="w"> </span><span class="l">ubuntu-latest</span><span class="w">
</span><span class="w">     </span><span class="nt">steps</span><span class="p">:</span><span class="w">
</span><span class="w">     </span>- <span class="nt">uses</span><span class="p">:</span><span class="w"> </span><span class="l">actionsdesk/lfs-warning@v2.0</span><span class="w">
</span><span class="w">       </span><span class="nt">with</span><span class="p">:</span><span class="w">
</span><span class="w">         </span><span class="c">#token: ${{ secrets.GITHUB_TOKEN }} # Optional</span><span class="w">
</span><span class="w">         </span><span class="nt">filesizelimit</span><span class="p">:</span><span class="w"> </span><span class="s1">'5242880'</span><span class="w"> </span><span class="c"># 5MB</span></code></pre></div><p class="ztext-empty-paragraph"><br></p><p data-pid="AKdwVv9d"><b>嵌入到 Makefile 后，整个逻辑就更简单了：</b></p><div class="highlight"><pre><code class="language-text"> # Copy githook scripts when execute makefile
 COPY_GITHOOK:=$(shell cp -f script/githooks/* .git/hooks/; chmod +x .git/hooks/*)</code></pre></div><p></p></div> </details> 
 <hr /> 

 #### - [CloudNative / Kubernetes 学习资源整理](https://zhuanlan.zhihu.com/p/614921043) 
 <details><summary>توضیحات</summary> <p><img src="https://pica.zhimg.com/v2-e9c8f471d1986e0a623b2d51f987d4b5_720w.jpg?source=d16d100b"></p><div><p data-pid="q00arbg7">我们需要对 kubernetes 进一步的学习和深造，看源码是必须的道路。</p><p data-pid="IjKcyLEh">与其重要的，是对 kubernetes 资源的收集。</p><p data-pid="8_DcBCHm"><i><b>⚠️ 所有资源均是采用外链连接，书本资源或不放连接，其他均为自己感受和总结。如有侵权请联系删除。</b></i></p><p data-pid="FgxU3B8D">⚠️ <b>注意，这篇文章将永久保存在 notion，将会不断地更新下去，提供了可写通道，如果你有更好的资源，欢迎补充在notion上，地址是：<a href="https://nsddd.notion.site/CloudNative-2f278e98ed274999829333272415c72d" target="_blank"><span class="invisible">https://</span><span class="visible">nsddd.notion.site/Cloud</span><span class="invisible">Native-2f278e98ed274999829333272415c72d</span><span class="ellipsis"></span></a></b> </p><a href="https://nsddd.notion.site/CloudNative-2f278e98ed274999829333272415c72d" data-draft-node="block" data-draft-type="link-card" target="_blank">Notion 永久更新连接（可编辑添加）</a><p data-pid="wjL_L2VF"><b>关于kubernetes：</b></p><ul><li data-pid="e8qdJflm"><a href="https://kubernetes.io/" target="_blank">官网</a></li><li data-pid="ul98m8q7"><a href="https://github.com/kubernetes/kubernetes" target="_blank">GitHub</a></li><li data-pid="_amP2WF8"><a href="https://github.com/cubxxw/kubernetes" target="_blank">cubxxw - pr</a></li><li data-pid="mMy38lJj"><a href="https://github.com/kubernauts/Kubernetes-Learning-Resources" target="_blank">社区维护的 kubernetes 学习资源合集</a></li><li data-pid="jZnYdlSy"><a href="https://blog.opskumu.com/borg.html" target="_blank">Kubernetes源码必读的 Google 大规模集群管理器 Borg</a></li><li data-pid="z4mQtiqn"><a href="https://www.cnblogs.com/sunsky303/p/14371768.html" target="_blank">etcd：从应用场景到实现原理的全方位解读</a> 和 <a href="https://blog.51cto.com/nileader/1040007" target="_blank">ZooKeeper典型应用场景一览</a></li></ul><p class="ztext-empty-paragraph"><br></p><p data-pid="gtBSLAR6"><b>关于 CNCF 的贡献，你需要签署 CLA </b></p><ul><li data-pid="UrvyZGZv"><a href="https://github.com/kubernetes/community/blob/master/CLA.md" target="_blank">Kubernetes CLA  的签署流程</a></li><li data-pid="Ja0XFV_V"><a href="https://github.com/kubernetes/community/tree/master/contributors/devel" target="_blank">官方开发者向导 markdown 文件</a></li><li data-pid="YRPi_IU6"><a href="https://github.com/kubernetes/community/blob/master/contributors/guide/owners.md" target="_blank">Kubernetes ownes 所有者md介绍</a></li></ul><p class="ztext-empty-paragraph"><br></p><p data-pid="ez0Z7IXE"><b>自己写作的一些资源：</b></p><ul><li data-pid="KfZkO3RL"><a href="https://docker.nsddd.top/" target="_blank">云原生学习</a></li><li data-pid="X8DDqO4e"><a href="https://go.nsddd.top/" target="_blank">golang 学习</a></li></ul><blockquote data-pid="nd4CMo9-">都收纳到 awesome 仓库中，覆盖   菜鸟成长手册  CS系列 、云原生系列、区块链系列、web3系列 、Golang系列 ...... 访问 GitHub  <a href="https://github.com/cubxxw/awesome-cs-cloudnative-blockchain" target="_blank"><span class="invisible">https://</span><span class="visible">github.com/cubxxw/aweso</span><span class="invisible">me-cs-cloudnative-blockchain</span><span class="ellipsis"></span></a></blockquote><h2><b>最好需要什么</b></h2><ol><li data-pid="uVZA3ZJM">如果说第一步的话，那必须要了解 docker 容器底层原理和 Linux 内核基础相关。</li><li data-pid="v4m98EAF">先理解理解完架构了，读起来就比较快了。</li><li data-pid="lfldEITy">学会使用它，不会使用，永远无法理解它的设计理念。</li><li data-pid="ojuGdfGE">读源码还得带着问题去读，不然会很枯燥。一定要带着问题去读，不然就会很枯燥，然后陷入细节中去</li><li data-pid="rl9WN7rA">读源码还得有一定积累量，比如你已经读过很多基础包的源码比如 net/http grpc-go 等等</li><li data-pid="s4y-W8Ks">要尝试着调试，要尝试着练习，要尝试着理解和分析产品理念，更要学会自己设计。</li></ol><h2><b>基础知识</b></h2><p data-pid="P4N1V3Jd"><b>基础概念：</b></p><p data-pid="L-E_tDU7">我们需要知道 kubernetes 的基础概念，我们或许在前面有讲解过。</p><p data-pid="c7caQIi0">比如 Build-in 的 API Groups 和 API Objects 有什么，做什么用；</p><p class="ztext-empty-paragraph"><br></p><p data-pid="T62WUZTj"><b>有一些很重要的工具库：</b> 如 <b>gengo</b> ，包括 informer 机制；</p><ul><li data-pid="oyb2BhEA">Cobra：命令行阿，docker、Kubernetes、sealos、sealer、ks 都具备的~</li><li data-pid="BTHpdVQk"><a href="https://github.com/emicklei/go-restful" target="_blank">go-restful</a>：REST 要求开发人员以与协议定义一致的方式显式使用 HTTP 方法。这个基本的 REST 设计原则在创建、读取、更新和删除 (CRUD) 操作和 HTTP 方法之间建立了一对一的映射。</li><li data-pid="cj7MY07q">etcd：和 fabric 一样采用 raft 共识机制的数据库，在 k3s 中很深的讲解和应用。</li></ul><p class="ztext-empty-paragraph"><br></p><p data-pid="fAlX53pD"><b>Restful 基础：</b></p><p data-pid="6n2XoFq4">简单了解 Restful 概念，如果做过 Restful Service 那么最好了</p><p class="ztext-empty-paragraph"><br></p><p data-pid="QAYRmGnX"><b>熟悉一些常见的设计模式：</b></p><ul><li data-pid="Y-qFp5vg">参考：<a href="https://www.yuque.com/aceld/lfhu8y/rg6nsf" target="_blank"><span class="invisible">https://www.</span><span class="visible">yuque.com/aceld/lfhu8y/</span><span class="invisible">rg6nsf</span><span class="ellipsis"></span></a></li></ul><p class="ztext-empty-paragraph"><br></p><p data-pid="ntv-elKl"><b>熟悉常用的算法，熟悉操作系统（尤其是 Linux 的基础知识），熟悉网络的一些协议和原理。</b></p><blockquote data-pid="U5FFs-cW">Kubernetes 有很多复杂的地方，尤其是网络和存储，希望以后可以成为 ×</blockquote><p class="ztext-empty-paragraph"><br></p><h2><b>阅读方法（其他开源项目类似）</b></h2><ul><li data-pid="cy5oZMTY">先整体，后局部（不钻牛角尖）</li><li data-pid="YNptoq2q">深入局部中的学习中去</li><li data-pid="lR1oH7QV">耐心，多看代码~</li></ul><p class="ztext-empty-paragraph"><br></p><h2><b>学习方法</b></h2><blockquote data-pid="zFRbBHY5">参考2022GSoC 谷歌开源之夏活动，对于学院的解答。<br>我是opensuse组织的GSoC'22贡献者，我想知道我可以如何学习和贡献k8s社区。我知道k8s的基础知识，但现在我想学习一些中级和高级概念，以便我可以在未来为k8s做出贡献。非常需要帮助</blockquote><ol><li data-pid="h5dgOhkW">Start learning each part of k8s.</li><li data-pid="dk7KbYPM">For example, start with Scheduler part.</li><li data-pid="n86un5CT">Go to k8s github and look into the code <a href="https://github.com/kubernetes/kubernetes" target="_blank"><span class="invisible">https://</span><span class="visible">github.com/kubernetes/k</span><span class="invisible">ubernetes</span><span class="ellipsis"></span></a></li><li data-pid="63DiXBLW">It will be the best place to start </li><li data-pid="KdYXAk3n">Read about scheduler and find described logic in the source code.</li><li data-pid="IZLBtDn8">But first i think that you need to learn how each part is communicating and for what it is responsible.</li><li data-pid="rJYwH7Z5">It is great that you wish to contribute. </li><li data-pid="ijTWv-KA">after that, learn everything about different Workloads (StatefulSet, ReplicaSet, DaemonSet etc.)</li><li data-pid="tDS0LK-U">then services and ingress</li><li data-pid="Y8qWF1FB">then pv/pvc</li><li data-pid="pFS3kR_J">then go deeper and learn about Container Runtime Interface (CRI)</li><li data-pid="NHqjrn6z">and about Network Interface (CNI)</li><li data-pid="M-GqslSB">and how they are communicating</li><li data-pid="8f5bXwEo">between themselves and with the host machine</li><li data-pid="zWkXk0ki">i guess that should give you a good grasp of how everything is working internally</li><li data-pid="7n3gSexZ">you can always check kubernetes api specification if you are looking for something what you have not learned yet </li></ol><h3><b>阶段型方法</b></h3><ol><li data-pid="tKZGcJAC"><b>第一阶段</b> 先了解k8s，是什么，能做什么，架构，核心资源对象，设计理念，发展历程等等</li><li data-pid="cv-DdTr8"><b>第二阶段</b> 开始使用k8s, 自己创建pod, deploy, job等资源。能够基于k8s开发一下组件，比如实现一个controller监听pod的创建删除等。【看山是山】</li><li data-pid="MN5WEVnF"><b>第三阶段</b> 开始阅读源码，了解底层实现。这个过程会对k8s有一个更深的理解。比如创建一个pod的完成历程是什么样的，k8s gc 机制到底是怎么实现的。namespaces删除的时候怎么做到删除所有资源后在删除的。【看山不是山】 这里推荐源码阅读方式：理论+实践结合。<br></li><ol><li data-pid="sP5iAvxV">理论：通过 ide 之间各种跳转阅读源码 </li><li data-pid="0F9GmKWz">实践：自己动手在[关键代码]处增加日志，通过查看日志输出理解源码 （repo也介绍了如何二进制搭建一套K8s集群）</li></ol></ol><p class="ztext-empty-paragraph"><br></p><ol><li data-pid="gd71gE1c"><b>第四阶段</b> 再排查问题中进一步深入k8s的理解</li></ol><p class="ztext-empty-paragraph"><br></p><h2><b>书籍推荐</b></h2><ul><li data-pid="w0I9Q43o">Go语言程序设计语言 （买了，建议有一些其他语言基础 &amp;&amp; Go语言基础再看最好）</li><li data-pid="7cX8j8IG">深入解刨 Kubernetes （这个我也买了，emmm，特别完美的一本书，作者有自己的讲解，是个大佬）</li><li data-pid="nDfMGsHH">kubernetes 编程</li><li data-pid="mZCq0a5Q">kubernetes 源码刨析（这个我买了！！！！！！，不推荐，copy 多干货少）</li><li data-pid="TxElHpRH">第一本 docker 书</li><li data-pid="-KxzCgV0">深入理解计算机系统 / 现代操作系统</li><li data-pid="P-Hryw61">docker 容器与容器云 （还没开始看）</li><li data-pid="_AbUEWJ1">Kubernetes 权威指南（熟练使用、贯穿场景）</li><li data-pid="pPC6rAIR">docker 开发指南 （还没开始看）</li><li data-pid="CqkukO8P"><a href="https://golang.coding3min.com/" target="_blank">Go语言精进之路</a></li><li data-pid="Fs86c2yL">Istio （服务网格 推荐 <a href="https://academy.tetrate.io/courses/take/istio-fundamentals-zh/lessons/26470007-1-0" target="_blank"><span class="invisible">https://</span><span class="visible">academy.tetrate.io/cour</span><span class="invisible">ses/take/istio-fundamentals-zh/lessons/26470007-1-0</span><span class="ellipsis"></span></a>）</li><li data-pid="I9XBCDrD"><a href="https://lib.jimmysong.io/what-is-ebpf/" target="_blank">eBPF</a></li><li data-pid="tu3eQtCO"><a href="https://lib.jimmysong.io/kubernetes-hardening-guidance/" target="_blank">Kubernetes 加固指南</a></li><li data-pid="VNsIzk2e"><a href="https://lib.jimmysong.io/cloud-native-infra/" target="_blank">云原生基础架构</a></li><li data-pid="VJXko6PW"><a href="https://lib.jimmysong.io/kubernetes-handbook/" target="_blank">Kubernetes 基础教程</a></li><li data-pid="tOE5evXZ"><a href="https://lib.jimmysong.io/migrating-to-cloud-native-application-architectures/the-rise-of-cloud-native/" target="_blank">迁移到云原生应用程序</a></li><li data-pid="znZ5mRFs"><a href="https://jimmysong.io/kubernetes-handbook/" target="_blank">Kubernetes 中文指南/云原生应用架构实战手册</a></li></ul><p class="ztext-empty-paragraph"><br></p><h2><b>视频资源</b></h2><ul><li data-pid="Uy53UOz0"><a href="https://space.bilibili.com/1748865719?share_from=space&amp;share_medium=iphone&amp;share_plat=ios&amp;share_session_id=160FA9F0-624A-411F-AD29-CE83BBBA3D35&amp;share_source=WEIXIN&amp;share_tag=s_i&amp;timestamp=1669727398&amp;unique_k=ulDpC8O" target="_blank">张海龙 kubernetes 开发之旅</a></li><li data-pid="lFimVAJu"><a href="https://search.bilibili.com/all?keyword=client-go&amp;from_source=webtop_search&amp;spm_id_from=333.999&amp;search_source=5" target="_blank">bilibili 搜索 client-go kubernetes必会</a></li><li data-pid="ux2ezdBu"><a href="https://space.bilibili.com/547971176?share_from=space&amp;share_medium=iphone&amp;share_plat=ios&amp;share_session_id=DE3B8DC0-6E79-4FCC-A128-21D5FB84D251&amp;share_source=WEIXIN&amp;share_tag=s_i&amp;timestamp=1669727447&amp;unique_k=TjDCl4U" target="_blank">插座煤电 深入理解 k8s 网络</a></li><li data-pid="XWoilEqX">极客时间 云原生 训练营课程（十五节）</li></ul><p class="ztext-empty-paragraph"><br></p><h2><b>网站资源</b></h2><ul><li data-pid="93BNMVbU"><a href="https://mp.weixin.qq.com/s/K6ynL_9nSTLCTy0_2xCobg" target="_blank">从 0 实现一个 k8s 的 CNI 网络插件</a></li><li data-pid="18992eLK"><a href="https://cloud.redhat.com/blog/kubernetes-deep-dive-code-generation-customresources" target="_blank">Kubernetes Deep Dive：CustomResources 的代码生成</a></li></ul><p class="ztext-empty-paragraph"><br></p><h2><b>推荐书籍</b></h2><ul><li data-pid="5MxzCAqk"><a href="https://zhuanlan.zhihu.com/write">深入剖析kubernetes</a></li><li data-pid="jVFhtHsX">Kubernetes 源码解析</li></ul><p class="ztext-empty-paragraph"><br></p><h2><b>youtube 精选视频</b></h2><ul><li data-pid="1HAA4CqJ"><a href="https://www.youtube.com/watch?v=Q91iZywBzew" target="_blank">教程：从源代码构建和运行 Kubernetes 并提交您的第一个 PR</a></li><li data-pid="d1sEmXTy"><a href="https://www.youtube.com/watch?v=Jbm0W9Dd4k4" target="_blank">Kubernetes源码解读: APIServer之server chain by Daniel Guo</a></li><li data-pid="1Ryrb9kh"><a href="https://www.youtube.com/watch?v=ytbEmcxM4yQ" target="_blank">如何理解开源中的大型代码库</a></li><li data-pid="llJaaFxn"><a href="https://www.youtube.com/watch?v=kA1T0zDPtQo" target="_blank">如何理解开源中的大型代码库？</a></li><li data-pid="zRAJQmKw"><a href="https://www.youtube.com/watch?v=toIncOqOBTA" target="_blank">Kubernetes 源码阅读</a></li></ul><p class="ztext-empty-paragraph"><br></p><h2><b>GitHub 精选仓库</b></h2><ul><li data-pid="PuiWwm8h"><a href="https://github.com/JackyZhangFuDan/K8sSourceCodeDeepDive/" target="_blank">go 开发之旅</a></li><li data-pid="AGUW0D9P"><a href="https://github.com/derekguo001/understanding-kubernetes" target="_blank">kubernetes 源码解读</a></li><li data-pid="weTCfPfn"><a href="https://github.com/dtsola/best-practices-for-cloud-native" target="_blank">云原生（Cloud Native）、容器化（Docker）、容器编排（k8s）、服务网格（Istio）、无服务器（Serverless）、微服务、CI/CD、DevOps相关内容总结。</a></li><li data-pid="WD4eEbRM"><a href="https://jimmysong.io/kubernetes-handbook/" target="_blank">Kubernetes 中文指南/云原生应用架构实战手册</a></li></ul><p class="ztext-empty-paragraph"><br></p><h2><b>数据统计和收集</b></h2><h3><b>CNCF 数据</b></h3><ul><li data-pid="jOOBmG5x">网站：<a href="https://kubernetes.io/" target="_blank">kubernetes.io</a></li><li data-pid="uxay2ilj">资料库：<a href="https://github.com/kubernetes/kubernetes" target="_blank">github.com/kubernetes/kubernetes</a> 94,767  </li><li data-pid="GM0wvNjT">Crunchbase：<a href="https://www.crunchbase.com/organization/cloud-native-computing-foundation" target="_blank">crunchbase.com/organization/cloud-native-computing-foundation</a></li><li data-pid="1Dwjw08v">领英：<a href="https://www.linkedin.com/company/cloud-native-computing-foundation" target="_blank">linkedin.com/company/cloud-native-computing-foundation</a></li><li data-pid="1kFsfhvL">推特：<a href="https://twitter.com/kubernetesio" target="_blank">@kubernetesio</a></li><li data-pid="bvhm3Ls1">第一次提交：<a href="https://github.com/kubernetes/kubernetes/commit/2c4b3a562ce34cddc3f8218a2c4d11c7310e6d56%22" target="_blank">9年前</a></li><li data-pid="_U3GJ507">贡献者：<a href="https://github.com/kubernetes/kubernetes/graphs/contributors" target="_blank">500+</a></li><li data-pid="ouen5yjv">最新推文：<a href="https://twitter.com/kubernetesio" target="_blank">2个月前</a></li><li data-pid="fLsSyWSw">公认: 2016-03-10</li><li data-pid="szyDEKeS">已毕业：2018-03-06</li><li data-pid="3EZ1HMRC">总部：<a href="https://landscape.cncf.io/?grouping=headquarters&amp;headquarters=san-francisco-california" target="_blank">加利福尼亚州旧金山</a></li><li data-pid="EIOsXv4g">孵化：7 年前</li><li data-pid="kf399eGX">开发统计：<a href="https://k8s.devstats.cncf.io/" target="_blank"><span class="invisible">https://</span><span class="visible">k8s.devstats.cncf.io/</span><span class="invisible"></span></a></li><li data-pid="THg2JxSu">艺术品： <a href="https://github.com/cncf/artwork/blob/master/examples/graduated.md#kubernetes-logos" target="_blank"><span class="invisible">https://</span><span class="visible">github.com/cncf/artwork</span><span class="invisible">/blob/master/examples/graduated.md#kubernetes-logos</span><span class="ellipsis"></span></a></li><li data-pid="77ndHz56">stackoverflow：<a href="https://stackoverflow.com/questions/tagged/kubernetes" target="_blank"><span class="invisible">https://</span><span class="visible">stackoverflow.com/quest</span><span class="invisible">ions/tagged/kubernetes</span><span class="ellipsis"></span></a></li><li data-pid="yFowPU0U">博客：<a href="http://blog.kubernetes.io/" target="_blank"><span class="invisible">http://</span><span class="visible">blog.kubernetes.io/</span><span class="invisible"></span></a></li><li data-pid="xR5wCAsV">邮件列表：<a href="https://groups.google.com/forum/#!forum/kubernetes-dev" target="_blank"><span class="invisible">https://</span><span class="visible">groups.google.com/forum</span><span class="invisible">/#!forum/kubernetes-dev</span><span class="ellipsis"></span></a></li><li data-pid="Szk0IJrm">slack：<a href="http://slack.k8s.io/" target="_blank"><span class="invisible">http://</span><span class="visible">slack.k8s.io/</span><span class="invisible"></span></a></li><li data-pid="dapFmKz1">YouTube： <a href="https://www.youtube.com/channel/UCZ2bu0qutTOM0tHYa_jkIwg" target="_blank"><span class="invisible">https://www.</span><span class="visible">youtube.com/channel/UCZ</span><span class="invisible">2bu0qutTOM0tHYa_jkIwg</span><span class="ellipsis"></span></a></li></ul><p class="ztext-empty-paragraph"><br></p><h3><b>源码统计</b></h3><p data-pid="1QtFcTwJ"><code>Kubernetes</code> 代码特别庞大，使用 cloc 统计 <b>（⏱️ 2023-03-17）</b>：</p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic3.zhimg.com/v2-efe55ab3479b2504fba0dbff51755eee_r.jpg" data-caption="" data-size="normal" width="2061" referrerpolicy="no-referrer"></figure><h3><b>其他源码统计</b></h3><p data-pid="wniSDlJq"><b>⚠️ 数据截止到 2023 年 3 月 17 日</b></p><ul><li data-pid="Tp-946C7">Istio :  SUN：514910 （GO：339739）</li><li data-pid="dI7W6R1w">Kind : 21060</li><li data-pid="hkJqTPsJ">Minikube:  178446</li><li data-pid="4u6pwkQT">sealos: 116277</li></ul><p></p></div> </details> 
 <hr /> 

 #### - [Istio 高级流量管理](https://zhuanlan.zhihu.com/p/614775174) 
 <details><summary>توضیحات</summary> <p><img src="https://picx.zhimg.com/v2-a645ece5992a7b2a730cd6a77c282b2c_720w.jpg?source=d16d100b"></p><div><ul><li data-pid="AvTl1sIk"><a href="http://nsddd.top/" target="_blank">author</a></li></ul><h2><b>第62节 Istio 高级流量管理</b></h2><p data-pid="ZMl4R7IY">​<a href="https://zhuanlan.zhihu.com/61.md">⬆️上一节 </a><a href="https://zhuanlan.zhihu.com/63.md">⬇️下一节 </a><br>​</p><blockquote data-pid="e1NNoofX">❤️  新时代拥抱云原生，云原生具有环境统一、按需付费、即开即用、稳定性强特点。Myblog:<a href="http://nsddd.top/" target="_blank">http://nsddd.top</a></blockquote><a href="https://www.notion.so/nsddd/Istio-a8e419634e7245c3b75eb4b855128e1c?pvs=4" data-draft-node="block" data-draft-type="link-card" target="_blank">本文 Notion 连接</a><p data-pid="d1o3gG_Y"><b>Andress：</b></p><ol><li data-pid="k6CgdUzp"><a href="https://github.com/istio/istio" target="_blank"><span class="invisible">https://</span><span class="visible">github.com/istio/istio</span><span class="invisible"></span></a></li><li data-pid="o-BC_wCy"><a href="https://istio.io/" target="_blank">Istio</a></li></ol><h2><b>Istio 高级流量管理</b></h2><p data-pid="sUx81JyE">Kubernetes是一个强大的容器编排平台，但是其自带的服务治理功能较为基础，只能实现基本的负载均衡和服务发现功能。而Istio则是一个专注于服务网格的开源项目，提供了强大的高级流量管理，可观察性和安全性功能，能够帮助企业快速构建高可用，高性能，高安全性的微服务架构。使用Istio可以实现更加灵活和高效的服务管理和治理。</p><p data-pid="R8Rq3k4N"><b>要想知道为什么需要 Istio，我们需要知道微服务 ~</b></p><h3><b>微服务架构的演变</b></h3><p data-pid="uwkXB9DO">微服务架构的演变包括单体应用、SOA架构、微服务架构等，随着业务的增长，单体应用和SOA架构逐渐暴露出诸多问题，如可扩展性、可维护性、服务间耦合度等，而微服务架构则以其松耦合、高内聚、可扩展等特点逐渐成为业界关注的重点。Istio是一个专注于服务网格的开源项目，提供了强大的高级流量管理、可观察性和安全性功能，帮助企业快速构建高可用、高性能、高安全性的微服务架构，是当前最流行的服务网格之一。</p><p data-pid="PH9da6Iv">微服务架构是分布式架构的一种具体实现。在微服务架构中，系统被拆分为多个服务，每个服务都是独立的、可替换的、可扩展的。每个服务都有自己的业务逻辑和数据库，服务之间通过轻量级的通信机制进行交互，如REST API或消息队列。微服务架构可以帮助企业快速构建高可用、高性能、高安全性的系统，具有更好的可维护性和可扩展性。</p><p data-pid="Qp_fK8Oe">服务网格则是分布式架构中的一种基础设施层，主要用于管理服务之间的通信。Istio是一种服务网格，提供了强大的高级流量管理、可观察性和安全性功能，可以帮助企业快速构建高可用、高性能、高安全性的微服务架构。Istio的流量管理功能可以实现灰度发布、流量控制、故障注入、流量镜像等高级流量管理功能；Istio的可观察性功能可以实现对服务的流量监控、日志收集、分布式追踪等功能；Istio的安全性功能可以实现服务间的认证、授权、加密等功能。</p><p data-pid="rlTeDaz4">因此，微服务架构和服务网格是分布式架构中的两个重要概念，可以帮助企业构建高可用、高性能、高安全性的系统。</p><table data-draft-node="block" data-draft-type="table" data-size="normal" data-row-style="normal"><tbody><tr><th>架构</th><th>优点</th><th>缺点</th><th>适用场景</th><th>案例</th></tr><tr><td>单体应用</td><td>简单易懂，易于开发</td><td>可扩展性和可维护性差</td><td>小型项目，小团队</td><td>单体应用的Web应用程序</td></tr><tr><td>SOA架构</td><td>松耦合，分布式</td><td>复杂性高，学习曲线陡峭</td><td>大规模项目，大团队</td><td>Amazon，eBay</td></tr><tr><td>微服务架构</td><td>松耦合，可扩展，模块化，易于维护</td><td>部署和运维复杂</td><td>大规模项目，大团队</td><td>Netflix，Uber</td></tr><tr><td>无服务器架构</td><td>高度灵活，无需管理服务器</td><td>可能存在性能问题</td><td>适用于短期、低流量的任务</td><td>AWS Lambda</td></tr><tr><td>事件驱动架构</td><td>异步处理，可扩展性强</td><td>处理复杂性高</td><td>高并发，大数据量、实时性要求高</td><td>Apache Kafka</td></tr><tr><td>CQRS架构</td><td>读写分离，可扩展</td><td>增加开发复杂性</td><td>大型复杂系统，高并发读写场景</td><td>Microsoft</td></tr><tr><td>服务器端渲染架构</td><td>首屏加载快，SEO友好</td><td>代码复杂度高</td><td>对首屏加载速度和SEO要求高</td><td>Airbnb</td></tr></tbody></table><p data-pid="R3kRhUtr">除了单体应用、SOA架构和微服务架构之外，还有无服务器架构，事件驱动架构，CQRS架构和服务器端渲染架构等。</p><p data-pid="V04AtJjV">无服务器架构是一种新兴的架构，可以实现高度灵活和无需管理服务器的目标，适用于短期、低流量的任务。事件驱动架构通过异步处理和可扩展性强，适用于高并发、大数据量、实时性要求高的场景。CQRS架构通过读写分离和可扩展性，适用于大型复杂系统、高并发读写场景。服务器端渲染架构通过首屏加载快和SEO友好特点，适用于对首屏加载速度和SEO要求高的场景。</p><p data-pid="uzvv8eOC">每种架构都有其优点和缺点，选择适合自己业务场景的架构是非常重要的。</p><p data-pid="DD07-KtS">​  微服务架构适用于大规模项目和大团队，具有以下典型业务场景：<br>​</p><ul><li data-pid="Nl5VcHhJ">高可用性要求：微服务架构可以将系统拆分为多个服务，每个服务都是独立的、可替换的、可扩展的，可以实现服务的高可用性。</li><li data-pid="IKWX-wNA">高性能要求：微服务架构可以将系统拆分为多个服务，每个服务都有自己的业务逻辑和数据库，服务之间通过轻量级的通信机制进行交互，如REST API或消息队列，可以实现高性能的服务调用。</li><li data-pid="vR3Qj29O">高可扩展性要求：微服务架构可以将系统拆分为多个服务，每个服务都是独立的、可替换的、可扩展的，可以实现服务的高可扩展性。</li><li data-pid="bR26594w">多团队协作开发：微服务架构可以将系统拆分为多个服务，每个服务都有自己的业务逻辑和数据库，不同的团队可以分别开发和维护不同的服务，可以实现多团队协作开发。</li><li data-pid="ENsvto4r">持续交付和部署：微服务架构可以将系统拆分为多个服务，每个服务都是独立的、可替换的、可扩展的，可以实现服务的独立部署和持续交付。 &lt;/aside&gt;</li></ul><h3><b>思维导图</b></h3><div class="highlight"><pre><code class="language-text">HTTP/RESTgRPCKafkaService AService BService C
</code></pre></div><blockquote data-pid="PfNECtbJ">上面的图是一个简单的服务网格的示例。它包含三个服务：A，B和C。服务A通过HTTP/REST协议与服务B通信，服务A通过gRPC协议与服务C通信，服务B通过Kafka与服务C通信。服务网格通过代理模式实现对服务的流量管理和安全管理，同时提供对服务的可观察性监控。在上面的图中，服务网格通过 <code>Envoy</code> 代理实现对服务的流量管理和安全管理。服务A的请求通过 <code>Envoy</code> 代理路由到服务B或服务C，服务B的响应通过Envoy代理返回给服务A。服务C的响应也通过Envoy代理返回给服务A。服务网格通过Envoy代理实现对服务的流量路由和流量控制，以便对服务进行灰度发布、流量控制、故障注入等高级流量管理功能。</blockquote><h3><b>SpringCloud和Istio的区别</b></h3><p data-pid="5DcHKrN4">SpringCloud是一组用于构建企业级应用程序的框架和工具。它提供了很多解决方案，如服务发现、配置管理、负载均衡、断路器、网关等，通过这些解决方案可以快速构建微服务应用程序。SpringCloud是一个基于Java的框架，它使用Spring Boot来简化微服务开发流程。</p><p data-pid="1-NI93jk">Istio是一个开源服务网格平台，它提供了流量管理、安全性和可观察性功能。Istio使用Envoy代理来管理网络流量，并通过控制Envoy的流量路由规则来实现灰度发布、流量控制、故障注入等高级流量管理功能。Istio是与Kubernetes集成的，因此可以很容易地部署和管理在Kubernetes上运行的微服务应用程序。</p><p data-pid="fzFpT4bQ">SpringCloud和Istio都用于构建微服务应用程序，但是它们在实现微服务治理方面有些许不同。SpringCloud是一组基于Java的框架和工具，适用于构建Java应用程序。它的优势在于开发人员可以使用熟悉的Java技术栈来构建微服务应用程序，这意味着开发人员可以更快地上手。而Istio是一个基于Envoy代理的服务网格平台，适用于构建任何语言的应用程序，但是在部署和管理方面需要对Kubernetes有一定的了解。Istio的优势在于它提供了很多高级的流量管理和安全性功能，这些功能在SpringCloud中可能需要开发人员自己来实现。</p><h3><b>为什么不选择SpringCloud</b></h3><p data-pid="o5A-lLo7">尽管SpringCloud是一个优秀的微服务框架，但是它也存在一些问题。首先，SpringCloud是一个基于Java的框架，因此只适用于构建Java应用程序。如果你的团队使用的是其他语言，那么SpringCloud可能不是最佳选择。其次，SpringCloud的学习曲线相对较陡峭，需要开发人员掌握很多概念和技术。最后，SpringCloud的性能可能比Istio略差，因为它使用了更多的Java代码来实现微服务治理功能。</p><div class="highlight"><pre><code class="language-text">HTTP/RESTHTTP/RESTHTTP/RESTHTTP/RESTHTTP/RESTgRPCgRPCgRPCgRPC客户端Spring Cloud Gateway微服务 A微服务 B微服务 C客户端Istio Ingress GatewayEnvoy Proxy微服务 A微服务 B微服务 C
</code></pre></div><p data-pid="kxC-9cre">上面的图分别体现了 Spring Cloud 和 Istio 的架构图。在 Spring Cloud 架构中，客户端通过 HTTP/REST 协议与 Spring Cloud Gateway 通信，Spring Cloud Gateway 负责路由请求并将请求发送到对应的微服务上。在 Istio 架构中，客户端通过 HTTP/REST 协议与 Istio Ingress Gateway 通信，Istio Ingress Gateway 负责路由请求并将请求发送到 Envoy Proxy，Envoy Proxy 负责将请求转发到对应的微服务上。</p><p data-pid="JM7vhPiT">在 Spring Cloud 架构中，Spring Cloud Gateway 是一个独立的组件，需要自己部署和运维；而在 Istio 架构中，Istio Ingress Gateway 是 Istio 的一部分，由 Istio 自动部署和运维。此外，在 Istio 架构中，Envoy Proxy 代理可以实现更多的流量管理和安全性功能，例如灰度发布、流量控制、故障注入等高级流量管理功能。因此，在流量管理和安全性方面，Istio 比 Spring Cloud 更加强大和灵活。</p><p data-pid="WOIBLXtR">然而，Spring Cloud 作为一个基于 Java 的微服务框架，可以轻松地与 Spring Boot 框架集成，因此可以快速构建 Java 微服务应用程序。而 Istio 可以支持多种语言，但需要对 Kubernetes 有一定的了解，因此在部署和管理方面需要一定的学习成本。</p><h2><b>什么是 Service Mesh（服务网格）？</b></h2><p data-pid="qDluFBzy">服务网格（Service Mesh）是一种基础设施层，用于管理服务之间的通信。它通过在服务之间插入代理来实现流量管理、安全性和可观察性。服务网格通常由一个控制平面和一个数据平面组成，其中控制平面负责配置和管理代理，数据平面负责处理流量。服务网格可以提供很多高级功能，例如流量路由、故障注入、流量控制、灰度发布、可观察性等。Istio是一个开源的服务网格平台，它使用Envoy代理来实现流量管理、安全性和可观察性功能。</p><table data-draft-node="block" data-draft-type="table" data-size="normal" data-row-style="normal"><tbody><tr><th>功能</th><th>适应性</th><th>服务发现</th><th>安全和访问控制</th><th>可观测性</th><th>部署和通讯</th></tr><tr><td>Spring Cloud</td><td>适用于构建Java应用程序</td><td>支持多种服务发现方式</td><td>可以使用Spring Security等框架实现安全性和访问控制</td><td>提供了Spring Boot Actuator等工具来实现可观测性</td><td>可以使用HTTP/REST协议或其他协议进行通讯</td></tr><tr><td>Istio</td><td>适用于构建任何语言的应用程序</td><td>支持多种服务发现方式</td><td>使用Envoy代理实现安全性和访问控制</td><td>提供了Istio Mixer等组件来实现可观测性</td><td>可以使用HTTP/REST协议、gRPC协议等协议进行通讯</td></tr></tbody></table><p data-pid="NiOu2j7_">当前说的 Service Mesh 一般就是指 Istio。</p><ul><li data-pid="D3hmGMUa">HTTP、gRPC、WebSocket 和TCP流量的自动负载均衡。</li><li data-pid="sqrFi0Hv">通过丰富的路由规则、重试、故障转移和故障注入，可以对流量行为进行细粒度控制。</li><li data-pid="zWFugycU">可插入的策略层和配置API，支持访问控制、速率限制和配额。</li><li data-pid="UNPSplnZ">对出入集群入口和出口中所有流量的自动度量指标、日志记录和跟踪。</li><li data-pid="sFnB0oeB">通过强大的基于身份的验证和授权，在集群中实现安全的服务间通信。</li></ul><p data-pid="_jWaEeyP">逻辑图：</p><div class="highlight"><pre><code class="language-text">HTTP/RESTgRPCgRPCgRPCgRPC客户端Istio Ingress GatewayEnvoy Proxy微服务 A微服务 B微服务 CRedisPrometheusGrafanaJaegerElasticsearchKibana
</code></pre></div><p data-pid="_8Qt2wVr">上面的图展示了 Service Mesh 的架构，其中客户端通过 HTTP/REST 协议与 Istio Ingress Gateway 通信，Istio Ingress Gateway 负责路由请求并将请求发送到 Envoy Proxy，Envoy Proxy 负责将请求转发到对应的微服务上。同时，Envoy Proxy 通过 Sidecar 模式与 Jaeger、Prometheus、Grafana 等监控工具进行通信，实现对服务的可观察性监控。此外，微服务 A、B、C 还通过 Redis 进行数据共享，Envoy Proxy 可以通过 Redis 进行流量控制和故障注入等高级流量管理功能。</p><p data-pid="t9cjp5Du">​  Sidecar<br>​</p><p data-pid="O4iX-ckd">Sidecar 是一个模式，它将一个辅助容器作为主容器的一个辅助进程来运行。在微服务架构中，使用 Sidecar 模式可以将代理作为辅助容器与每个微服务实例一起运行，以便实现流量管理、安全管理和可观察性等功能。Sidecar 模式还可以将监控、日志记录和跟踪工具作为辅助容器与主容器一起运行，以便对微服务进行可观察性监控。Istio 服务网格使用 Sidecar 模式来管理网络流量，并使用 Envoy 代理作为辅助容器进行流量管理和安全管理。</p><p data-pid="tW8eT5Q9">&lt;/aside&gt;</p><p data-pid="hvyJAw43">Service Mesh 把认证鉴权、服务发现、负载均衡、熔断等通用能力整合到 Sidecar 里，让业务专注于业务本身。</p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic4.zhimg.com/v2-fa32fa74ff28fdc1083beab4ae4ff137_r.jpg" data-caption="" data-size="normal" width="1726" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>服务网格可选方案</b></h3><p data-pid="7Q1uhz9E">在 Istio 之前，已经有了一些服务网格的解决方案。下面是一些可选方案：</p><ul><li data-pid="OGx7WkNu"><b>Linkerd</b>：Linkerd 是一个开源的服务网格，它使用代理模式来实现流量管理和安全管理。Linkerd 使用 Finagle 作为代理，可以支持多种语言的应用程序。</li><li data-pid="6w-Aro7B"><b>Consul Connect</b>：Consul Connect 是 HashiCorp 公司开发的服务网格解决方案。它使用 Envoy 代理来实现流量管理和安全管理，同时提供了服务发现、配置管理等功能。</li><li data-pid="QT-_ARfb"><b>AWS App Mesh</b>：AWS App Mesh 是 Amazon Web Services 公司开发的服务网格解决方案。它使用 Envoy 代理来实现流量管理和安全管理，同时提供了服务发现、配置管理等功能。AWS App Mesh 可以与 AWS 上的其他服务集成，例如 Amazon ECS 和 Amazon EKS。</li><li data-pid="cMBcvNdC"><b>Kuma</b>：Kuma 是一个开源的服务网格，它使用 Envoy 代理来实现流量管理和安全管理。Kuma 支持多种数据平面和控制平面，可以灵活地适应不同的应用场景。</li></ul><p data-pid="OE79Dqlf">​  我们最后在描述一下 Service Mesh： 服务网格（Service Mesh）这个术语通常用来描述构成这些应用程序的微服务网格以及应用之间的交互。随着规模和复杂性的增长，服务网格越来越难以理解和管理。<br>​</p><p data-pid="rMSinFq4">&lt;/aside&gt;</p><h2><b>流量管理</b></h2><p data-pid="4JFrK9On">Istio通过Envoy代理实现流量管理，通过控制Envoy的流量路由规则，可以实现灰度发布，流量控制，故障注入等高级流量管理功能。</p><div class="highlight"><pre><code class="language-text">HTTP/RESTgRPCgRPCgRPCgRPC客户端Istio Ingress GatewayEnvoy Proxy微服务 A微服务 B微服务 CRedisPrometheusGrafanaJaegerElasticsearchKibana
</code></pre></div><p data-pid="OkGQ__cX">上面的图展示了Istio的完整架构，其中客户端通过HTTP/REST协议与Istio Ingress Gateway通信，Istio Ingress Gateway负责路由请求并将请求发送到Envoy Proxy，Envoy Proxy负责将请求转发到对应的微服务上。同时，Envoy Proxy通过sidecar模式与Jaeger、Prometheus、Grafana等监控工具进行通信，实现对服务的可观察性监控。此外，微服务A、B、C还通过Redis进行数据共享，Envoy Proxy可以通过Redis进行流量控制和故障注入等高级流量管理功能。</p><h3><b>灰度发布</b></h3><p data-pid="bEreax6O">灰度发布是一种逐步将新版本服务引入生产环境的方式。在灰度发布中，可以将部分流量引导到新版本服务，逐步验证新版本的稳定性和可用性。最终实现全量升级。Istio支持基于用户ID，源IP，HTTP头等多种方式进行流量路由。这些流量规则可以通过Istio的流量管理功能进行配置和管理。</p><h3><b>流量控制</b></h3><p data-pid="aGEkzT_S">Istio支持对服务的流量进行控制，包括限流，超时控制，重试等功能。可以通过Istio的流量规则，对不同的服务进行不同的流量控制策略，以保障服务的稳定性和可用性。通过Istio的流量控制功能，可以帮助企业快速构建高可用，高性能的微服务架构。</p><h3><b>故障注入</b></h3><p data-pid="7iL3ss5f">Istio可以通过流量规则，模拟服务故障，以便测试服务的容错性和可用性。例如，可以通过Istio将一定比例的流量引导到故障服务上，验证服务的降级和自愈能力。这些流量规则可以通过Istio的流量管理功能进行配置和管理。</p><h3><b>流量镜像</b></h3><p data-pid="I4XhqzIP">Istio支持流量镜像功能，将一部分流量镜像到另一个服务中，以便测试新服务的性能和可用性。例如，可以将一定比例的流量镜像到新服务中，对新服务进行验证和测试。这些流量镜像规则也可以通过Istio的流量管理功能进行配置和管理。</p><h2><b>可观察性</b></h2><p data-pid="wM-UibJr">Istio通过Envoy代理实现对服务的流量监控，可以实时收集服务的流量数据，包括请求量，成功率，响应时间等指标，以便进行性能和容量规划。同时，Istio支持对服务的请求进行追踪和分析，以便快速定位和解决问题。这些监控和诊断功能可以通过Istio的可观察性管理功能进行配置和管理。</p><p data-pid="9RPFabB8">谈论到可观察性，永远都是这么几个，监控指标、日志以及分布式追踪。</p><h3><b>监控指标</b></h3><p data-pid="Q9mbTeE-">lstio 基于4个监控的黄金标识(延迟、流量、错误、饱和)生成了一系列服务指标。Istio还为网格控制平面提供了更详细的指标。除此以外还提供了- -组默认的基于这些指标的网格监控仪表板 </p><p data-pid="IDY2RMHh">Istio通过Prometheus实现对服务的监控，可以实时收集服务的流量数据，包括请求量，成功率，响应时间等指标。可以通过Istio的监控管理功能进行配置和管理。</p><h3><b>日志</b></h3><p data-pid="8X3SlQVJ">Istio通过Envoy代理实现对服务的日志收集，可以收集服务的请求和响应信息，以便进行追踪和分析。可以通过Istio的日志管理功能进行配置和管理。</p><p data-pid="tVvw1CBO">当流量流入网格中的服务时，Istio 可以生成每个请求的完整记录,包括源和目标的元数据。此信息使运维人员能够将服务行为的审查控制到单个工作负载实例的级别。</p><h3><b>分布式追踪</b></h3><p data-pid="vPVxLice">Istio 为每个服务生成分布式追踪span,运维人员可以理解网格内服务的依赖和调用流程。</p><p data-pid="wPOgEy7X">Istio通过Jaeger实现对服务的分布式追踪，可以追踪服务的请求链路，以便快速定位和解决问题。可以通过Istio的追踪管理功能进行配置和管理。</p><h2><b>Istio 架构演进</b></h2><p data-pid="NDmcDp7v">数据平面:</p><ul><li data-pid="C3yHqLYO">由一组以Sidecar方式部署的智能代理(Envoy) 组成。这些代理可以调节和控制微服务及Mixer之间所有的网络通信。</li></ul><p data-pid="VAQ9qWAm">控制平面:</p><ul><li data-pid="xFbH69Vt">负责管理和配置代理来路由流量。此外控制平面配置Mixer以实施策略和收集遥测数据。</li></ul><p data-pid="j36AfFKy">架构演进:</p><ul><li data-pid="_uQvIodb">从微服务回归单体</li></ul><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic2.zhimg.com/v2-6fc3febf6c31768a681c6f36c8ad61c1_r.jpg" data-caption="" data-size="normal" width="1614" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p data-pid="ETZgDFZ6">Istio有三个控制平面组件：Pilot、Mixer和Citadel。</p><ul><li data-pid="kNPc3q1J"><b>Pilot</b>：负责流量管理，包括流量路由、流量转移、请求重试、故障注入、流量镜像等功能。Pilot将流量管理规则下发到Envoy代理，控制流量的转发和策略的执行。</li><li data-pid="29okTWbC"><b>Mixer</b>：负责策略和遥测数据收集。Mixer提供了一个插件框架，可以使用插件来实现策略功能，如请求认证、访问控制、配额管理等。同时，Mixer还负责收集服务的遥测数据，如请求量、错误率、延迟等指标。</li><li data-pid="Fh7dAx5t"><b>Citadel</b>：负责服务之间的认证和授权。Citadel为每个服务生成证书，并将证书下发到服务的Sidecar代理中。Sidecar代理使用证书来进行服务之间的安全通信，同时Citadel还提供了一个API，用于管理证书和密钥。</li></ul><p data-pid="MgfQEb_V">以上三个控制平面组件协同工作，实现了Istio的高级流量管理和安全功能。</p><p data-pid="WwzCgB7s">​  所以我们在做架构演进的时候，可能经常需要去复盘这个架构到底是不是和，经常反思。 最开始可能野心很大，后面希望做更可控的事情。<br>​</p><p data-pid="jn1ErLBu">&lt;/aside&gt;</p><h2><b>设计目标</b></h2><p data-pid="BmK22l-h">Istio 的设计理念是将服务网格从应用程序中解耦出来，以便将流量管理、策略执行、安全性和可观察性与应用程序代码分离。这种解耦允许开发人员专注于应用程序的核心业务逻辑，而不是流量管理和安全性。Istio 的设计目标是提供一种灵活的、可扩展的、易于部署和维护的服务网格解决方案，可以适应各种不同的应用场景。Istio 还提供了丰富的流量管理和安全功能，包括流量路由、流量控制、故障注入、灰度发布、流量镜像、认证和授权等功能。同时，Istio 还提供了强大的监控和诊断功能，可以帮助企业快速发现和解决问题，提高服务的可用性和可靠性。</p><h3><b>策略一致性</b></h3><p data-pid="BzC_iKrh">Istio 的策略一致性指的是，一旦制定了策略，就会在整个服务网格中得到强制执行，无论在哪个数据平面中运行。这种一致性可以确保服务网格中的所有服务都遵循相同的策略，从而提高服务的安全性和可靠性。Istio 通过控制平面中的 Mixer 组件来实现策略一致性，Mixer 负责收集遥测数据和实施策略，可以为整个服务网格提供一致的策略执行。</p><h3><b>可移植性</b></h3><p data-pid="rdpFBltR">Istio 的可移植性指的是，可以在不同的数据平面上运行 Istio，而不需要重新编写或修改应用程序代码。这种可移植性可以帮助企业快速部署和扩展服务网格，同时降低维护成本。Istio 使用 Envoy 作为数据平面，Envoy 是一个通用的代理，可以与多种语言和框架进行交互，从而实现 Istio 的可移植性。此外，Istio 还提供了丰富的 API 和插件，可以与不同的数据平面集成，从而实现 Istio 的可扩展性和可定制性。</p><h2><b>安全性</b></h2><p data-pid="9dO7hMDS">Istio通过Envoy代理实现对服务的安全性管理，包括服务间的认证，授权，加密等功能。可以通过Istio的安全规则，对不同的服务进行不同的安全策略，以保障服务的安全性。Istio的安全性管理功能可以帮助企业快速构建高安全性的微服务架构。</p><p data-pid="CJ4NZEIM">​  Istio支持服务间的认证功能，可以对服务进行身份验证，以保障服务间的安全性。可以通过Istio的认证管理功能进行配置和管理。<br>​</p><p data-pid="FG2SWc4B">&lt;/aside&gt;</p><p data-pid="LtyVqUrQ">​  Istio支持对服务的授权功能，可以控制服务的访问权限，以保障服务的安全性。可以通过Istio的授权管理功能进行配置和管理。<br>​</p><p data-pid="VAyMDR2E">&lt;/aside&gt;</p><p data-pid="8YR2MsFe">​  Istio支持对服务的加密功能，可以对服务间的通信进行加密，以保障服务间的数据安全性。可以通过Istio的加密管理功能进行配置和管理。<br>​</p><p data-pid="VtCiOHTJ">&lt;/aside&gt;</p><h2><b>数据平面 Envoy</b></h2><table data-draft-node="block" data-draft-type="table" data-size="normal" data-row-style="normal"><tbody><tr><th>代理名称</th><th>开发语言</th><th>功能特点</th><th>支持的特性</th><th>GitHub地址</th></tr><tr><td>HAProxy</td><td>C</td><td>高性能、稳定性好</td><td>HTTP2、Rate Limit、ACL、Connection draining</td><td><a href="https://github.com/haproxy/haproxy" target="_blank"><span class="invisible">https://</span><span class="visible">github.com/haproxy/hapr</span><span class="invisible">oxy</span><span class="ellipsis"></span></a></td></tr><tr><td>Nginx</td><td>C</td><td>高性能、支持反向代理和负载均衡</td><td>HTTP2、Rate Limit、ACL、Connection draining</td><td><a href="https://github.com/nginx/nginx" target="_blank"><span class="invisible">https://</span><span class="visible">github.com/nginx/nginx</span><span class="invisible"></span></a></td></tr><tr><td>Apache</td><td>C</td><td>支持多种代理模式，如正向代理、反向代理等</td><td>HTTP2、Rate Limit、ACL</td><td><a href="https://github.com/apache/httpd" target="_blank"><span class="invisible">https://</span><span class="visible">github.com/apache/httpd</span><span class="invisible"></span></a></td></tr><tr><td>Envoy</td><td>C++</td><td>支持多种协议、多种语言，可扩展、易于管理</td><td>HTTP2、Rate Limit、ACL、Connection draining</td><td><a href="https://github.com/envoyproxy/envoy" target="_blank"><span class="invisible">https://</span><span class="visible">github.com/envoyproxy/e</span><span class="invisible">nvoy</span><span class="ellipsis"></span></a></td></tr><tr><td>Traefik</td><td>Go</td><td>支持多种后端服务、自动发现、动态配置</td><td>HTTP2、Rate Limit、ACL、Connection draining</td><td><a href="https://github.com/traefik/traefik" target="_blank"><span class="invisible">https://</span><span class="visible">github.com/traefik/trae</span><span class="invisible">fik</span><span class="ellipsis"></span></a></td></tr><tr><td>Linkerd</td><td>Scala</td><td>面向服务网格，支持多种协议、负载均衡、流量控制</td><td>HTTP2、Rate Limit、ACL、Connection draining</td><td><a href="https://github.com/linkerd/linkerd" target="_blank"><span class="invisible">https://</span><span class="visible">github.com/linkerd/link</span><span class="invisible">erd</span><span class="ellipsis"></span></a></td></tr><tr><td>Kong</td><td>Lua</td><td>基于Nginx，支持多种协议、插件可扩展</td><td>HTTP2、Rate Limit、ACL、Connection draining</td><td><a href="https://github.com/Kong/kong" target="_blank"><span class="invisible">https://</span><span class="visible">github.com/Kong/kong</span><span class="invisible"></span></a></td></tr></tbody></table><p data-pid="ZxSK0UBc">各自优势和缺点：</p><ul><li data-pid="g4PAdFBc">HAProxy：高性能、低延迟、支持多种负载均衡算法，但缺乏流量控制功能。</li><li data-pid="oj1zVFvj">Nginx：高性能、稳定性好、支持反向代理和负载均衡，但缺乏流量控制功能。</li><li data-pid="mQbA6qg6">Apache：支持多种代理模式，如正向代理、反向代理等，但不适合高并发场景。</li><li data-pid="6pO5bV_t">Envoy：支持多种协议、多种语言，可扩展、易于管理，支持流量控制、故障注入、灰度发布等高级功能。</li><li data-pid="tJSr01g3">Traefik：支持多种后端服务、自动发现、动态配置，易于使用，但缺乏灵活性。</li><li data-pid="meCEutqY">Linkerd：面向服务网格，支持多种协议、负载均衡、流量控制，具有良好的可观察性，但性能可能不如其他代理。</li><li data-pid="Lz0qxeMa">Kong：基于Nginx，支持多种协议、插件可扩展，具有良好的可扩展性和可配置性，但不太适合大规模部署。</li></ul><table data-draft-node="block" data-draft-type="table" data-size="normal" data-row-style="normal"><tbody><tr><th>Envoy</th><th>Ngnix</th><th>HA Proxy</th></tr><tr><td>HTTP/2</td><td>对HTTP/2有最完整的支持，同时upstream和downstream HTTP/2</td><td>从1.9.5开始有限支持HTTP/2，只在 upstream 支持 HTTP/2,downstream 依然是 HTTP/1.1</td></tr><tr><td>Rate Limit</td><td>通过插件支持限流</td><td>支持基于配置的限流，只支持基于源IP的限流</td></tr><tr><td>ACL</td><td>基于插件实现四层ACL</td><td>基于源/目标地址实现ACL</td></tr><tr><td>Connection draining</td><td>支持 hot reload,并且通过 share memory 实现 connection draining 的功能</td><td>Nginx Plus收费版支持connection draining</td></tr></tbody></table><h3><b>Envoy 的优势</b></h3><ul><li data-pid="7iIdDivd"><a href="https://github.com/envoyproxy/envoy" target="_blank"><span class="invisible">https://</span><span class="visible">github.com/envoyproxy/e</span><span class="invisible">nvoy</span><span class="ellipsis"></span></a></li></ul><p data-pid="X-gOpX8L">Envoy 作为 Istio 的数据平面代理，具有以下优势：</p><ul><li data-pid="7k1NYqlq">高性能：Envoy 采用了多种技术，如异步 I/O、线程池和内存池等技术，可以处理高并发的请求，同时减少 CPU 和内存的使用。</li><li data-pid="qZiDqp3z">可扩展性：Envoy 支持多种协议、多种语言和可扩展的插件机制，可以满足不同服务的需求，从而实现 Istio 的高级流量管理和安全功能。</li><li data-pid="ePehOuop">API 可配置性：Envoy 提供了丰富的 API 和配置选项，可以根据业务需求进行灵活的配置和管理，例如可以进行流量控制、故障注入、安全策略等。</li></ul><p data-pid="5GHgawt7">除此之外，Envoy 还具有易于管理、可移植性强等优势，可以与多种语言和框架进行交互，从而实现 Istio 的可移植性和可扩展性。企业可以通过 Istio 的管理平台配置和管理 Envoy 的这些优势，使得企业能够更加灵活和高效地管理自己的微服务架构。随着企业对微服务架构的需求不断增长，Envoy 的优势将成为企业构建微服务架构的重要选择之一。</p><div class="highlight"><pre><code class="language-text">EnvoyNetwork FiltersEnvoyHTTP Connection ManagerTCP ProxyAccess LoggingStats LoggingTracingCluster ManagerSDS/ADSSecret Discovery ServiceRate LimitingHTTP FiltersTCP FiltersRoutesVirtual HostsFiltersLoad BalancerHealth CheckingCircuit BreakingOutlier Detection
</code></pre></div><h3><b>Envoy 的线程模式</b></h3><p data-pid="8vK6k1lS">Envoy 采用了 <b>单进程多线程</b> 的设计，可以充分利用现代 CPU 的多核优势，同时避免了单线程的性能瓶颈。Envoy 的线程模式包括以下几种：</p><ul><li data-pid="OL70o17e">Main 线程：负责 Envoy 的启动和配置，以及管理其他线程的生命周期。</li><li data-pid="FIcjsN-N">Listener 线程：负责处理网络连接的 I/O 操作，包括监听端口、接收连接、读写数据等。</li><li data-pid="2D_QbM8o">Worker 线程：负责处理具体的请求和响应，包括路由、过滤器、负载均衡等功能。</li><li data-pid="hIQtnLMl">File 线程：负责处理文件 I/O 操作，如日志写入、TLS 证书加载等。</li><li data-pid="M0KSmjwL">Admin 线程：负责处理 Envoy 的管理命令，如查看状态、修改配置等。</li></ul><p data-pid="VROe9bQf">Envoy 的线程模式可以根据业务需求进行灵活的配置和调整，从而实现更好的性能和资源利用率。同时，Envoy 还提供了丰富的 API 和插件机制，可以扩展线程模式，实现更复杂的功能和场景。企业可以通过 Istio 的管理平台配置和管理 Envoy 的线程模式，使得企业能够更加灵活和高效地管理自己的微服务架构。</p><p data-pid="yqXPbkOm">当某个连接被监控器接收，那么该连接的全部生命周期会与某线程绑定。</p><h3><b>Envoy 基于非阻塞模式 （Epoll)</b></h3><p data-pid="lxPw5cbm">Epoll 是一种高性能的 I/O 多路复用机制，用于处理大量连接的高并发场景。在传统的 select 和 poll 机制中，每次需要遍历整个文件描述符集合来寻找有事件发生的描述符，这样会造成效率低下和资源浪费。而 Epoll 采用了事件通知的方式，只有在有事件发生时才会通知用户程序，从而大大提高了效率和性能。</p><p data-pid="VMcwlTlU">Epoll 的核心是一个事件表，用于存放所有要监控的文件描述符和对应的事件类型。它包括三个 API 函数：epoll_create、epoll_ctl 和 epoll_wait。其中，epoll_create 用于创建一个新的 epoll 实例，epoll_ctl 用于添加/修改/删除一个文件描述符到 epoll 实例中，epoll_wait 用于等待文件描述符上的 I/O 事件，并返回就绪的文件描述符列表。</p><p data-pid="7u4QYTHL"><b>与传统的 select 和 poll 相比，Epoll 具有以下优势：</b></p><ol><li data-pid="u84EO21h">高效性：Epoll 采用了事件通知的方式，只有在有事件发生时才会通知用户程序，从而避免了轮询整个文件描述符集合的开销，同时也减少了内核和用户程序之间的上下文切换次数，从而提高了效率和性能。</li><li data-pid="L4B5U76w">可扩展性：Epoll 可以支持数十万个连接并发处理，通过修改事件表的大小和调整内部数据结构可以实现更高的扩展性和灵活性。</li><li data-pid="H9cw3t3f">更加灵活：Epoll 支持多种事件类型，包括读、写、异常和优先级事件等，可以满足不同的应用场景和需求。</li><li data-pid="Dz00Er78">良好的兼容性：Epoll 是 Linux 内核中实现的一种 I/O 多路复用机制，可以与其他 Linux 系统调用和库函数进行兼容。</li></ol><p data-pid="Ml2bsY2L">Epoll 在高并发场景下具有重要的应用价值，可以用于优化 Web 服务器、消息队列、数据库等应用程序的性能和效率。在现代的网络应用中，Epoll 已经成为了一种不可或缺的技术，值得我们深入学习和研究。</p><div class="highlight"><pre><code class="language-text">HardwareWirespeedNetwork CardKernelEvent SourceEpollEvent SourceEvent SourceUsersSocketApplication
</code></pre></div><h2><b>Istio 多集群</b></h2><p data-pid="DJkqBk52">架构师要学会做取舍，选择合适的，符合场景的方案。</p><div class="highlight"><pre><code class="language-text">Pod容器1Pod1容器2应用1应用2应用3LocalLB服务端1本地负载均衡器服务端2服务端3Pod1Pod2Pod3Pod4DataCenter2服务端1跨数据中心负载均衡器服务端2服务端3Pod1Pod2Pod3Pod4DataCenter1服务端1跨数据中心负载均衡器服务端2服务端3Pod1Pod2Pod3Pod4SmartDNSCDN节点Smart DNS本地DNS服务器日志服务器
</code></pre></div><p data-pid="w0LZvRPm">该架构图包括以下要素：</p><ul><li data-pid="oK_QtYeN">SmartDNS：智能 DNS 服务器，用于解析域名和地址映射。</li><li data-pid="dn0_6ZjC">CDN节点：内容分发网络节点，用于加速数据传输。</li><li data-pid="cDO-QMb0">本地DNS服务器：本地 DNS 服务器，用于缓存 DNS 解析结果。</li><li data-pid="fwg1WI-a">日志服务器：用于收集和存储系统日志和统计数据。</li><li data-pid="_8gDDH49">跨数据中心负载均衡器：用于跨数据中心的负载均衡和流量控制。</li><li data-pid="sODpEXaD">服务端：用于处理业务逻辑和提供服务的服务器。</li><li data-pid="Y_OxkzEn">Pod：Kubernetes 中最小的可部署的计算单元，包含一个或多个容器。</li><li data-pid="8dMDQpbU">容器：用于封装应用程序和其依赖项的轻量级运行环境。</li><li data-pid="zWKUQ9LU">应用程序：运行在容器内部的业务逻辑，提供服务和处理请求。</li><li data-pid="yQNIGVVw">本地负载均衡器：用于本地的负载均衡和流量控制。</li></ul><p data-pid="9UmUZcu3">在该架构中，SmartDNS、CDN节点和本地DNS服务器协同工作，通过缓存、负载均衡和智能路由等技术，实现了高效的域名解析和地址映射。跨数据中心负载均衡器、本地负载均衡器和 Pod 之间的协作，可以实现跨数据中心和本地的负载均衡、流量控制和服务发现，从而提高了系统的可用性、可伸缩性和性能。同时，日志服务器可以收集和存储系统的日志和统计数据，帮助管理员和开发人员监控和调试系统，提高系统的可管理性和可维护性。</p><h2><b>集群联邦</b></h2><p data-pid="3KkYsYB6"><a href="https://jimmysong.io/kubernetes-handbook/practice/federation.html" target="_blank">集群联邦（Cluster Federation） · Kubernetes 中文指南——云原生应用架构实战手册</a></p><blockquote data-pid="_Cs-wBgj">Kubernetes 从 1.8 版本起就声称单集群最多可支持 5000 个节点和 15 万个 Pod，我相信很少有公司会部署如此庞大的一个单集群，总有很多情况下因为各种各样的原因我们可能会部署多个集群，但是有时候有想将他们统一起来管理，这时候就需要用到集群联邦（Federation）。</blockquote><p data-pid="RSiFcshb">集群联邦（Cluster Federation）是一种将多个 Kubernetes 集群连接起来，实现跨集群资源管理和服务发现的技术。通过集群联邦，企业可以实现跨数据中心、跨可用区的资源管理和负载均衡，从而提高系统的可用性、可伸缩性和性能。</p><p data-pid="SC9bWcQ_"><a href="https://kubernetes.io/blog/2018/12/12/kubernetes-federation-evolution/" target="_blank">Kubernetes 官方博客的文章</a>中介绍了 Kubernetes 集群联邦的演进，该项目是在 SIG Multicluster 中进行的，Federation 是 Kubernetes 的一个子项目，社区对这个项目的兴趣很浓，该项目最初重用 Kubernetes API，以消除现有 Kubernetes 用户的任何附加使用复杂性。但由于以下原因，此方式行不通：</p><ul><li data-pid="yK0Xcjtn">在集群层面重新实施 Kubernetes API 的困难，因为 Federation 的特定扩展存储在注释中。</li><li data-pid="BigkSJdT">由于 Kubernetes API 的1:1仿真，Federation 类型、放置（placement）和调节（reconciliation）的灵活性有限。</li><li data-pid="bCWkM4G-">没有固定的 GA 路径，API 成熟度普遍混乱；例如，Deployment 在Kubernetes 中是 GA，但在 Federation v1 中甚至不是Beta。</li></ul><p data-pid="JWnlyxss">随着 Federation 特定的 API 架构和社区的努力，这些想法有了进一步的发展，改进为 Federation v2。请注意，Federation V1 版本已经归档不再维护和更新，且官方也不再推荐继续使用。如果需要了解更多的 Federation 资料，请参考：<a href="https://github.com/kubernetes-sigs/kubefed" target="_blank">Kubernetes Federation v2</a>。</p><p data-pid="hIKoy7W8"><b>集群联邦包括以下要素：</b></p><ul><li data-pid="HKydXl1z">Kubernetes 集群：分布在不同数据中心或可用区中的 Kubernetes 集群，可以使用不同的云服务提供商或私有数据中心。</li><li data-pid="N1XUlZae">集群联邦控制平面：用于管理和控制集群联邦的核心组件，包括 API Server、Controller Manager、Scheduler 等。</li><li data-pid="P8WoT7rw">集群联邦 API：用于定义和管理跨集群的资源和服务，包括 Endpoint、Service、Namespace 等。</li><li data-pid="hUXGkmpe">集群联邦 DNS：用于解析跨集群的服务和域名，包括 External DNS 和 CoreDNS 等。</li><li data-pid="ssoyxatE">集群联邦 Ingress：用于管理和配置跨集群的 Ingress 路由和负载均衡，包括 Istio Gateway 和 Traefik 等。</li><li data-pid="CPjxGJHj">集群联邦网络：用于实现跨集群的网络互通和安全隔离，包括 Calico、Flannel、Weave Net 等。</li></ul><p data-pid="Agf0lNYA">在集群联邦中，Istio 作为一种服务网格技术，可以为跨集群的服务提供流量管理、安全策略、可观测性等功能。通过 Istio 中的集群联邦支持，企业可以实现跨数据中心、跨可用区的服务发现和流量管理，从而提高系统的可用性和性能。</p><div class="highlight"><pre><code class="language-text">Data Center 2Zone 1Control PlaneKubernetes Cluster 3Worker NodesZone 2Control PlaneKubernetes Cluster 4Worker NodesData Center 1Zone 1Control PlaneKubernetes Cluster 1Worker NodesZone 2Control PlaneKubernetes Cluster 2Worker NodesIstio PrimaryService MeshData Center 1 Zone 1Data Center 1 Zone 2Data Center 2 Zone 1Data Center 2 Zone 2
</code></pre></div><p data-pid="KQBmdsEQ">以上是集群联邦的架构图，包括两个数据中心、四个可用区和一个 Istio Primary。在每个可用区中，都有一个 Kubernetes 集群和一个 Istio Service Mesh。Istio Primary 作为集群联邦的核心组件，可以管理和控制所有的 Istio Service Mesh，实现跨数据中心和可用区的流量管理、安全策略和可观测性等功能。</p><p data-pid="Sxflo9gY">在该架构中，Kubernetes 集群可以使用不同的云服务提供商或私有数据中心，从而实现跨平台的资源管理和负载均衡。集群联邦控制平面可以管理和控制所有的 Kubernetes 集群和 Istio Service Mesh，实现跨集群的资源调度和服务发现。集群联邦 DNS 和 Ingress 可以解析和负载均衡跨集群的服务和域名，从而实现跨数据中心和可用区的流量管理和安全策略。集群联邦网络可以实现跨集群的网络互通和安全隔离，从而保障系统的可用性和安全性。</p><h3><b>集群联邦管理的对象</b></h3><p data-pid="R-_czojB">成员集群是联邦的基本管理单位，所有待管理集群均需要注册到集群联邦。</p><p data-pid="7AhbftQ_">集群联邦 V2 提供了统一的工具集 <code>kubefedctl</code> ，允许用户对单个对象动态的创建联邦对象。</p><p data-pid="7cwcq2tM">动态对象生成基于 CRD。</p><table data-draft-node="block" data-draft-type="table" data-size="normal" data-row-style="normal"><tbody><tr><th>特征</th><th>Kubernetes 集群</th><th>Kubernetes 集群联邦</th></tr><tr><td>计算资源</td><td>可以独立管理和调度，但是无法跨集群调度</td><td>可以通过联邦控制平面进行跨集群调度和资源管理</td></tr><tr><td>部署</td><td>独立部署，需要单独管理</td><td>集群联邦控制平面可以管理和控制所有的成员集群</td></tr><tr><td>配置</td><td>每个集群需要单独配置和管理</td><td>可以通过集群联邦 API 统一管理和调度</td></tr><tr><td>密钥</td><td>每个集群需要单独管理和分发</td><td>可以通过集群联邦控制平面进行跨集群的密钥管理和分发</td></tr><tr><td>其他 Kubernetes 对象</td><td>每个集群需要单独配置和管理</td><td>可以通过集群联邦 API 统一管理和调度</td></tr><tr><td>优点</td><td>独立性强，可以根据需求进行灵活配置</td><td>可以实现跨数据中心和可用区的负载均衡和服务发现</td></tr><tr><td>缺点</td><td>无法实现跨集群的负载均衡和服务发现</td><td>需要额外的管理和配置工作，可能会增加复杂性和风险</td></tr></tbody></table><p data-pid="zP2JcR-0">Kubernetes Cluster Federation 又名 KubeFed 或 Federation v2，v2 架构在 Federation v1 基础之上，简化扩展 Federated API 过程，并加强跨集群服务发现与编排的功能。另外 KubeFed 在设计之初，有两个最重要核心理念是 KubeFed 希望实现的，分别为 Modularization（模块化）与 Customizable (定制化)，这两个理念大概是希望 KubeFed 能够跟随着 Kubernetes 生态发展，并持续保持相容性与扩展性。</p><p data-pid="TZ0kHGKy">由于 Federation 试图解决一系列复杂的问题，因此需要将这些问题的不同部分分解开来。Federation 中涉及的概念和架构图如下所示。</p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic4.zhimg.com/v2-1e2153970bc1ee23b0179ea8a6ee535b_r.jpg" data-caption="" data-size="normal" width="1686" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><h3><b>集群的注册中心</b></h3><p data-pid="-uN_F6K7">集群注册中心 （ClusterRegistry) 提供了所有联邦下的集群清单，以及每一个集群的认证信息、状态信息。</p><h2><b>Kind 搭建集群联邦</b></h2><p data-pid="4sk53vSl">在本教程中，我们将使用 kind（Kubernetes IN Docker）搭建一个简单的集群联邦，包括安装集群联邦。该联邦将包括两个 Kubernetes 集群和一个 Istio Service Mesh。每个 Kubernetes 集群将包含一个控制平面节点和一个工作节点。</p><blockquote data-pid="yJ85O74A">我们在之前学习 Kind 的时候，知道了 Kind 特别适合 集群联邦的搭建。</blockquote><h3><b>安装集群联邦</b></h3><p data-pid="_KSo3AlQ">下载代码：</p><div class="highlight"><pre><code class="language-yaml"><span class="w"> </span><span class="l">git clone https://github.com/kubernetes-sigs/kubefed.git</span></code></pre></div><p data-pid="D-5C5C57">make:</p><div class="highlight"><pre><code class="language-yaml"><span class="w"> </span><span class="l">make deploy.kind</span><span class="w">
</span><span class="w"> </span><span class="l">kubectl -n kube-federation-system get kubefedcluster -oyaml</span></code></pre></div><h3><b>步骤 1：安装 kind</b></h3><p data-pid="xH4Oejeb">要使用 kind 搭建集群联邦，我们需要先安装 kind。可以按照以下步骤在 Linux 或 macOS 系统上安装 kind。</p><div class="highlight"><pre><code class="language-bash"> <span class="c1"># 下载 kind</span>
 curl -Lo ./kind &lt;https://kind.sigs.k8s.io/dl/v0.10.0/kind-<span class="k">$(</span>uname<span class="k">)</span>-amd64&gt;
 chmod +x ./kind
 ​
 <span class="c1"># 将 kind 可执行文件移动到 PATH 中</span>
 sudo mv ./kind /usr/local/bin/kind
 ​
 <span class="c1"># 验证 kind 是否安装成功</span>
 kind version
 ​</code></pre></div><h3><b>步骤 2：创建 Kubernetes 集群</b></h3><p data-pid="2S0UlBJM">使用 kind 命令创建 Kubernetes 集群。在本教程中，我们将创建两个 Kubernetes 集群，分别代表两个数据中心。</p><div class="highlight"><pre><code class="language-bash"> <span class="c1"># 创建第一个 Kubernetes 集群</span>
 kind create cluster --name<span class="o">=</span>dc1 --config<span class="o">=</span>./dc1-config.yaml
 ​
 <span class="c1"># 创建第二个 Kubernetes 集群</span>
 kind create cluster --name<span class="o">=</span>dc2 --config<span class="o">=</span>./dc2-config.yaml</code></pre></div><p data-pid="c9JmXATN">以下是 <code>dc1-config.yaml</code> 的示例文件内容：</p><div class="highlight"><pre><code class="language-text"> kind: Cluster
 apiVersion: kind.x-k8s.io/v1alpha4
 nodes:
 - role: control-plane
 - role: worker
 ​</code></pre></div><p data-pid="_086sL5l">以下是 <code>dc2-config.yaml</code> 的示例文件内容：</p><div class="highlight"><pre><code class="language-text"> kind: Cluster
 apiVersion: kind.x-k8s.io/v1alpha4
 nodes:
 - role: control-plane
 - role: worker</code></pre></div><p data-pid="W6Zle3hD">Kubectl 可以通过 <code>kubectl config use-context [context-name]</code> 命令来选择当前要使用的集群。在 kind 集群联邦中，每个 Kubernetes 集群都有一个唯一的 context 名称，格式为 <code>kind-[cluster-name]</code>。例如，要使用名为 <code>dc1</code> 的 Kubernetes 集群，可以执行以下命令：</p><div class="highlight"><pre><code class="language-text"> kubectl config use-context kind-dc1</code></pre></div><p data-pid="uei8WWsi">然后，您就可以在 <code>dc1</code> 集群上运行 <code>kubectl</code> 命令了。</p><h3><b>步骤 3：安装 Istio</b></h3><p data-pid="80mL3n_d"><a href="https://istio.io/latest/docs/setup/getting-started/" target="_blank">Getting Started</a></p><p data-pid="ZNVYioBg">在本教程中，我们将使用 Istio 作为服务网格技术。可以按照以下步骤安装 Istio。</p><div class="highlight"><pre><code class="language-yaml"><span class="w"> </span><span class="c"># 下载 Istio</span><span class="w">
</span><span class="w"> </span><span class="l">curl -L https://istio.io/downloadIstio | sh -</span><span class="w">
</span><span class="w"> </span><span class="l">​</span><span class="w">
</span><span class="w"> </span><span class="c"># 将 Istio 可执行文件移动到 PATH 中</span><span class="w">
</span><span class="w"> </span><span class="l">cd istio-1.17.1</span><span class="w">
</span><span class="w"> </span><span class="l">export PATH=$PWD/bin:$PATH</span><span class="w">
</span><span class="w"> </span><span class="l">​</span><span class="w">
</span><span class="w"> </span><span class="c"># 安装 Istio</span><span class="w">
</span><span class="w"> </span><span class="l">istioctl install --set profile=default -y</span><span class="w">
</span><span class="w"> </span><span class="l">​</span><span class="w">
</span><span class="w"> </span><span class="c"># 验证 Istio 是否安装成功</span><span class="w">
</span><span class="w"> </span><span class="l">kubectl get pods -n istio-system</span></code></pre></div><p data-pid="sk2JcoJA"><b>安装目录包含：</b></p><ul><li data-pid="627hVCAA"><b><code>samples/</code> 中的示例应用程序</b></li><li data-pid="VEIv1I12"><b><code>bin/</code> 目录中的 <code>istioctl</code> 客户端二进制文件</b></li></ul><p data-pid="RvpgMsFC">还可以选择：</p><p data-pid="ydWCmxaM"><b>添加命名空间标签以指示Istio在您稍后部署应用时自动注入Envoy sidecar代理：</b></p><div class="highlight"><pre><code class="language-yaml"><span class="w"> </span><span class="l">kubectl label namespace default istio-injection=enabled</span></code></pre></div><h3><b>步骤 4：配置集群联邦</b></h3><p data-pid="EfqfldkJ">在本教程中，我们将使用 Istio 作为集群联邦的核心组件。可以按照以下步骤配置集群联邦。</p><div class="highlight"><pre><code class="language-yaml"><span class="w"> </span><span class="c"># 创建 Istio Primary</span><span class="w">
</span><span class="w"> </span><span class="l">kind create cluster --name=istio-primary --config=./istio-primary-config.yaml</span><span class="w">
</span><span class="w"> </span><span class="l">​</span><span class="w">
</span><span class="w"> </span><span class="c"># 部署 Istio</span><span class="w">
</span><span class="w"> </span><span class="l">istioctl manifest generate --set profile=default | kubectl apply -f -</span><span class="w">
</span><span class="w"> </span><span class="l">​</span><span class="w">
</span><span class="w"> </span><span class="c"># 创建 Istio Service Mesh</span><span class="w">
</span><span class="w"> </span><span class="l">istioctl mesh create --config=./istio-primary.yaml --name=istio-primary</span><span class="w">
</span><span class="w"> </span><span class="l">​</span><span class="w">
</span><span class="w"> </span><span class="c"># 将 Istio Service Mesh 注册到集群联邦</span><span class="w">
</span><span class="w"> </span><span class="l">kubefedctl join istio-primary --cluster-context=istio-primary --v=2</span><span class="w">
</span><span class="w"> </span><span class="l">​</span></code></pre></div><p data-pid="Aj18sHHJ">在本教程中，我们使用了三个不同的配置文件来创建 Istio Primary 和 Istio Service Mesh。你可以根据自己的需要自定义配置文件。以下是一个简单的配置文件示例，用于创建 <code>Istio Primary</code>。</p><div class="highlight"><pre><code class="language-text"> kind: Cluster
 apiVersion: kind.x-k8s.io/v1alpha4
 nodes:
 - role: control-plane
 ​</code></pre></div><p data-pid="hzm6dND5">以下是一个简单的配置文件示例，用于创建 <code>Istio Service Mesh</code>。</p><div class="highlight"><pre><code class="language-text"> apiVersion: install.istio.io/v1alpha1
 kind: IstioOperator
 spec:
   profile: default
   components:
     ingressGateways:
     - name: istio-ingressgateway
       enabled: true
 ​</code></pre></div><p data-pid="kmmt4Cxv">在集群联邦中，Istio Service Mesh 将充当跨集群的流量管理和安全策略的核心组件。通过 Istio 中的集群联邦支持，企业可以实现跨数据中心、跨可用区的服务发现和流量管理，从而提高系统的可用性和性能。</p><h3><b>步骤 5：验证集群联邦</b></h3><p data-pid="Kfq4qGkh">在完成集群联邦的配置后，可以使用 kubefedctl 命令验证集群联邦是否正常工作。</p><div class="highlight"><pre><code class="language-bash"> <span class="c1"># 查看成员集群</span>
 kubefedctl get clusters
 ​
 <span class="c1"># 查看跨集群的 Service</span>
 kubefedctl get services --all-namespaces
 ​
 <span class="c1"># 查看跨集群的 Deployment</span>
 kubefedctl get deployments --all-namespaces
 ​</code></pre></div><p data-pid="MmsYhG_i">在我们使用了 kubefedctl 命令来管理集群联邦。你可以根据自己的需要使用其他工具来管理集群联邦。</p><p data-pid="qfwKb-1e">如果没有 <code>kubefedctl</code> 命令，您可以通过以下步骤安装它：</p><ol><li data-pid="200GbINn">下载最新的 kubefedctl 发布包：</li></ol><div class="highlight"><pre><code class="language-text"> curl -LO &lt;https://github.com/kubernetes-sigs/kubefed/releases/latest/download/kubefedctl-$(uname)-$(arch)&gt;
 chmod +x kubefedctl-$(uname)-$(arch)</code></pre></div><ol><li data-pid="NxwgqqOj">移动 kubefedctl 可执行文件到 PATH 中。</li></ol><div class="highlight"><pre><code class="language-text"> sudo mv kubefedctl-$(uname)-$(arch) /usr/local/bin/kubefedctl</code></pre></div><ol><li data-pid="IWyuvaZq">验证 kubefedctl 是否已安装成功。</li></ol><div class="highlight"><pre><code class="language-text"> kubefedctl version</code></pre></div><h3><b>联邦对象的组成</b></h3><p data-pid="dQiqt52z">联邦对象包括 template、placement、overrides 三个部分。下面是一些更详细的解释。</p><ul><li data-pid="qN3qXbZC"><b>Template</b>: 是联邦对象的模板，用于定义联邦对象的规范。任何创建的联邦对象都必须符合此模板。模板包括 API 版本、Kind、metadata 等信息。通过模板，我们可以定义联邦对象的类型和属性，并确保所有的联邦对象都具有相同的属性和行为。</li><li data-pid="W32opVgQ"><b>Placement</b>: 是联邦对象的放置规则，用于指定联邦对象在哪些成员集群中创建。通过放置规则，我们可以控制联邦对象的副本数量、分布情况和优先级等属性。放置规则可以基于标签、名称、命名空间等条件进行定义，也可以使用自定义的选择器进行定义。</li><li data-pid="yip6W2u3"><b>Overrides</b>: 是联邦对象的覆盖规则，用于覆盖联邦对象在成员集群中的属性和行为。通过覆盖规则，我们可以根据需要修改联邦对象的属性和行为，从而实现更灵活和个性化的管理。覆盖规则可以针对不同的成员集群进行定义，也可以使用自定义的选择器进行定义。</li></ul><h2><b>结论</b></h2><p data-pid="FmB7hdT4">Istio提供了强大的高级流量管理，可观察性和安全性功能，可以帮助企业快速构建高可用，高性能，高安全性的微服务架构，是当前最流行的服务网格之一。Istio的流量管理，可观察性和安全性功能均可通过Istio的管理平台进行配置和管理，使得企业能够更加灵活和高效地管理自己的微服务架构。随着企业对微服务架构的需求不断增长，Istio的服务网格将成为企业构建微服务架构的重要选择。</p><p class="ztext-empty-paragraph"><br></p><h2><b>END 链接</b></h2><p data-pid="xTUgWl6o">​</p><ul><li data-pid="S7o2hBbG"><a href="https://zhuanlan.zhihu.com/61.md">⬆️上一节 </a><a href="https://zhuanlan.zhihu.com/63.md">️下一节 </a></li></ul><p data-pid="jx5DOg-X"><br>​</p><ul><li data-pid="GjwpytuI"><a href="typora://app/README.md" target="_blank">Ⓜ️回到目录 </a></li><li data-pid="GXnGmC7j"><b><a href="https://nsddd.top/archives/contributors" target="_blank"> 参与贡献 ❤️‍  </a></b>)</li><li data-pid="IuV11b48">✴️版权声明 © ：本书所有内容遵循<a href="http://zh.wikipedia.org/wiki/Wikipedia:CC-by-sa-3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank">CC-BY-SA 3.0协议（署名-相同方式共享）©</a> </li></ul><p></p></div> </details> 
 <hr /> 

 #### - [Kubernetes 概念以及架构](https://zhuanlan.zhihu.com/p/611169064) 
 <details><summary>توضیحات</summary> <p><img src="https://picx.zhimg.com/v2-ca77d94d86f76a72c2e70ff0a65303c3_720w.jpg?source=d16d100b"></p><div><ul><li data-pid="_hpd0NK-"><a href="http://nsddd.top/" target="_blank">author</a></li></ul><h2><b>第47节 Kubernetes 概念以及架构</b><br></h2><blockquote data-pid="GfnR8AFq">❤️  新时代拥抱云原生，云原生具有环境统一、按需付费、即开即用、稳定性强特点。Myblog:<a href="http://nsddd.top/" target="_blank">http://nsddd.top</a></blockquote><h2><b>前言</b></h2><p data-pid="192kbGr-"><b>云计算： 参考上一节学习：云计算是对所有 存储资源、网络资源、计算资源的抽象</b></p><blockquote data-pid="EAwabYpI">控制平面将大量的节点抽象出来：<br></blockquote><ul><li data-pid="WLUrjUzc">谁能参与计算</li><li data-pid="pAo7s9q2">共有多少 CPU </li><li data-pid="D6U8LjkJ">共有多少内存</li><li data-pid="7Nxjy9X8">业务不需要在乎我的程序跑在哪个节点</li></ul><p class="ztext-empty-paragraph"><br></p><p data-pid="2WNq7m12"><b>过去这段时间里，作业管理平台主要是2个方向：</b></p><p data-pid="0TGJUwrZ">以Openstack为典型的虚拟化平台：</p><blockquote data-pid="Bm9DVcms">这种虚拟化平台可以认为是在很多台物理机上都安装Hypervisor，在Hypervisor上启动很多个虚拟机，再把这些虚拟机组成一个大的云平台。<br>最终交付的产品形态：一个个的OS。在这个OS上去部署应用因此后续工作(应用部署、应用升级、应用管理)与底层的基础云平台有着相对比较明显的界限：</blockquote><ul><li data-pid="CY3XPZ2T">IaaS:Infrastructure as a Service</li><li data-pid="4bjcSoTm">PaaS:Platform as a Service</li><li data-pid="ygONRucc">SaaS:Software as a Service</li></ul><p data-pid="qY_fOcqy">虚拟机构建和业务代码部署是分离的.这种可变的基础架构使后续维护风险变大。</p><p class="ztext-empty-paragraph"><br></p><p data-pid="VcUZu2_g"><b>以谷歌Borg为典型的基于进程的作业调度平台：</b></p><blockquote data-pid="C9IwlxIq">google 走的是另一条路，事实证明现在是对的。</blockquote><p class="ztext-empty-paragraph"><br></p><h2><b>谷歌Borg云计算平台</b></h2><p data-pid="QuvIRcHz">[[Borg]]是Google内部用于管理公司内部所有作业的一个作业管理平台。Kubernetes的前身即为Borg。</p><p data-pid="xUmyeXd8"><b>Borg</b> is a <a href="https://en.wikipedia.org/wiki/Cluster_manager" target="_blank">cluster manager</a> used by <a href="https://en.wikipedia.org/wiki/Google" target="_blank">Google</a>.[<a href="https://en.wikipedia.org/wiki/Borg_(cluster_manager)#cite_note-1" target="_blank">1]</a>[<a href="https://en.wikipedia.org/wiki/Borg_(cluster_manager)#cite_note-2" target="_blank">2]</a> It led to widespread use of similar approaches such as <a href="https://en.wikipedia.org/wiki/Docker_(software)" target="_blank">Docker</a> and <a href="https://en.wikipedia.org/wiki/Kubernetes" target="_blank">Kubernetes</a>.[<a href="https://en.wikipedia.org/wiki/Borg_(cluster_manager)#cite_note-3" target="_blank">3]</a></p><blockquote data-pid="3ANdn-Er"><a href="https://github.com/prometheus/prometheus" target="_blank">pormetheus 也是类似</a><br><a href="https://blog.opskumu.com/borg.html" target="_blank">强烈推荐阅读 Borg 论文，云计算领域论文不多，希望有机会也能发一篇</a></blockquote><p data-pid="zNlSpUHn">Borg并没有使用虚拟化技术。它的主要实现方式是使用轻量级的作业调度。也就是说Borg调度的是进程。</p><p class="ztext-empty-paragraph"><br></p><p data-pid="ltvlx2Bu"><b>Borg本身利用了一些容器技术：</b></p><ul><li data-pid="8NOH2EmC">Cgroup技术就是Google开源给Linux的</li><li data-pid="Q2RBdWUv">Namespace的前身：<code>chroot</code>和<code>jail</code> 但这也带来了一些缺点：<br></li><ul><li data-pid="kuXgMkif">对象之间的强依赖job和task是强包含关系,不利于重组</li><li data-pid="iDriRxOI">所有容器共享IP，会导致端口冲突,隔离困难等问题</li><li data-pid="h_d2nAr5">为超级用户添加复杂逻辑，导致系统过于复杂</li></ul></ul><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>Borg主要支持的业务</b></h3><p data-pid="YbMHn5od"><b>主要支持的业务：</b></p><ol><li data-pid="X2UPXKKv"><b>Production Workload（生产业务）</b>：这类业务包括Gmail、Google Docs、Web Search等服务</li><li data-pid="RyJ70rtZ"><b>Non-prod Workload（离线作业）</b>：比如AI方向、大数据方向的批处理作业</li></ol><p class="ztext-empty-paragraph"><br></p><p data-pid="qu__XPe_"><b>Production Workload 和 Non-prod Workload的区别：</b></p><ul><li data-pid="kKQkPW93"><b>Production Workload</b> 要求高可用，要求永远在线。它对资源的开销可能并不是特别大，也不是大量地消耗计算资源的服务(除非负载特别高，但负载一般也是有波峰波谷的，不是一直高负载的)</li><li data-pid="x4omdtPS"><b>Non-prod Workload</b> 一般用于批处理作业。对资源开销的要求会比较高(比如启动一个AI训练时，会疯狂的吃CPU/GPU)。但Non-prod Workload对可用性的要求比Production Workload低。更直观的说，当你发起一个批处理作业时，你不能要求该作业马上返回结果，因为这个批处理作业本身需要时间(有可能是几分钟，几小时，几天甚至几个月)。对于Non-prod Workload的时效性要求较低。</li></ul><p data-pid="goiKm-T-"><b>Google通过把在线业务和离线业务混合部署的方式，使得整个数据中心的资源利用率有了一个本质提升。</b></p><p class="ztext-empty-paragraph"><br></p><p data-pid="UfM-5PuB">Borg <b>提供三个好处</b>：</p><ol><li data-pid="CCiUABON">向用户隐藏资源管理和故障处理的细节，用户只需专注于应用程序开发</li><li data-pid="K7GrQwGe">高可靠性和高可用性的操作，同时支持应用程序相关特性</li><li data-pid="TSTsYOeR">有效的在数以万计的机器上运行工作负载</li></ol><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic4.zhimg.com/v2-3f41654b47b8ee51cf6b33f26b33704b_r.jpg" data-caption="" data-size="normal" width="1008" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h2><b>概念</b></h2><p data-pid="BGvGtOU9">Borg 的面向用户为运行 Google 应用程序和服务的 Google 开发者和系统管理员（Google 内部称为网站高可用工程师或者简写 SRE）。用户向 Borg 以作业（ <code>jobs</code> ）的方式提交工作，每个 job 由包含着相同程序的一个或多个任务（ <code>tasks</code> ）组成。每个 job 运行在一个 Borg <code>cell</code> (一组机器集合管理单元) 上。</p><p class="ztext-empty-paragraph"><br></p><h3><b>The workload</b></h3><p data-pid="ldlkjdSh">Borg cells 包括两种类型的 workload。第一种是那些长时间运行的服务，并且对请求延迟敏感（几微秒到几百毫秒之间）。这类服务一般是直接面向终端用户的产品，如 Gmail、Google Docs 和 Web 搜索以及内部基础设施服务（如 BigTable）。另外一种是那些运行几秒或者几天即可完成的批处理作业，这类服务对短期性能波动不敏感。</p><p data-pid="RDCOD02K">一个典型的 cell，一般分配 70% CPU 资源，实际使用为 60%，分配 55% 的内存资源，实际使用为 85%。</p><p class="ztext-empty-paragraph"><br></p><h3><b>Clusters and cells</b></h3><p data-pid="NVuhPs0r">1个Cell上跑1个集群管理系统Borg</p><blockquote data-pid="YStwCZ-z">我理解Cell就是Kubernetes中的Cluster。<br>通过定义Cell可以让Borg对服务器资源进行统一抽象，作为用户就无需知道自己的应用跑在哪台机器上，也不用关心资源分配、程序安装、依赖管理、健康检查及故障恢复等</blockquote><p data-pid="-g3cFfg2">一个 cell 的机器都归属于单个集群，通过高性能的数据中心级别的光纤网络连接。一个集群部署在一个独立的数据中心建筑中，多个数据中心建筑构成一个 <code>site</code> 。一个集群通常包括一个大规模的 cell 和许多小规模的测试或者特殊目的的 cells。尽量避免单点故障。</p><p data-pid="-GTCMq3-">排除测试 cells，一个中等规模的 cell 一般由 10k 机器组成。一个 cell 中的机器规格是不同的，诸如配置（CPU、RAM、磁盘、网络），处理器型号，性能等方面。用户无需关心这些差异，Borg 确定在哪个 cell 上运行任务，分配资源，安装程序和依赖项，并监控应用运行状况以及在运行失败时重启。</p><p class="ztext-empty-paragraph"><br></p><h3><b>Jobs and tasks</b></h3><p data-pid="1afKrRhB">Task即为进程。多个Task组成1个Job。</p><blockquote data-pid="2ajAPbsm">我理解Job就是Kubernetes中的Pod；Task就是Kubernetes中的Container</blockquote><p data-pid="qdJyAsN1">一个 Borg job 的属性包括名字、属主以及 tasks 数量。通过一些约束，可以强制 Job 的 tasks 在具有特定属性的机器上运行，例如处理器架构、操作系统版本，或者额外的 IP 地址。约束是分软限制和强限制。可以指定 job 运行顺序，如一个 job 在另外一个 job 运行之后再启动。一个 job 只能运行在一个 cell 上。</p><p data-pid="diC7TjIN">每个 task 映射成一组 Linux 进程运行在一台机器的一个容器中。大部分的 Borg workload 都不是运行在虚拟机中，不想在虚拟化上花费精力是一方面。另外，设计 Borg 的时候还没有出现硬件虚拟化。task 也有拥有属性，例如资源需求等。大多数的 task 属性同它们的 job 一样，不过也可以被覆盖。如提供 task 专用的命令行参数，以及 CPU、内存、磁盘空间、磁盘 IO 大小、TCP 端口等都可以分配设置。用户通过 RPC 与 Borg 交互来操作 job，大多数是通过命令行工具完成的，其它的则通过监控系统。大部分 job 描述文件是用声明式配置语言 BCL (GCL 变体) 编写的。</p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic3.zhimg.com/v2-0b09fbd38548234a3437cfc84976e5b6_r.jpg" data-caption="" data-size="normal" width="503" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p data-pid="OSNku0f7">用户可以修改一个运行中的 job 属性值并发布到 Borg，然后 Borg 按照新的 job 配置来更新 tasks。更新通常是以滚动方式完成，并且可以对更新导致的任务中断（重新调度或者抢占）的数量进行限制，任何导致更多中断的更改都会被跳过。</p><p data-pid="TdVe4GC6">tasks 需要能够处理 Unix <code>SIGTERM</code> 信号， 以便在被强制发送 <code>SIGKILL</code> 之前，可以有时间进行清理，保存状态，完成当前执行请求，拒绝新的请求。在实践中，规定时间有 80% 的可以正常处理信号。</p><p class="ztext-empty-paragraph"><br></p><h3><b>Allocs（allocation）</b></h3><p data-pid="w4OmKMcj">Borg <code>alloc</code> 是可以运行在一个或多个 tasks 的机器上的一组预留资源。无论资源是否使用，资源仍分配。Allocs 可以被用于将来的 tasks 资源使用，在停止和启动 task 之间保留资源，并且可以将不同 jobs 的 tasks 聚集到同一台机器上。一个 alloc 的资源和机器上资源类似的方式处理，多个 tasks 运行在 alloc 上是共享资源的，如果一个 alloc 必须重新分配到另外一台主机，它的 tasks 也会同它一起重新被调度。</p><p data-pid="ftXXnO2W">一个 <code>alloc</code> 集合和 job 很像，它是一组分配在多台机器上的预留资源。一旦创建一个 alloc 集合，就可以提交一个或多个 jobs 运行在其中。为简洁起见，通常使用 "task" 引用 alloc 或者一个顶级的 task(alloc 之外的 task) 和 "job" 来引用一个 job 或者 alloc 集合。</p><p class="ztext-empty-paragraph"><br></p><h3><b>Priority, quota, and adminssion control</b></h3><p data-pid="Mtmuh7eP">优先级和配额用于防止运行的比实际能容纳多的这种负载情况。每个 job 都有一个 <code>priority</code> 优先级，一个小的正整数。高优先级的 task 可以在牺牲较低优先级的 task 来获取资源，甚至是以抢占方式。 Borg 为不同用途定义不同的优先级：监控、生产、批处理和 best effort。</p><p data-pid="NRxWakPp">针对生产级别的 jobs 是禁止 task 互相抢占的。优先级决定 jobs 在 cell 中处于运行还是等待状态。 <code>Quota</code> 配额被用于确定调度哪些 jobs。配额表示为一段时间内（通常为几个月）给定优先级的资源量（CPU、RAM、磁盘等）。这些值指定了用户的 job 在请求时间段内可以使用的最大资源量。配额检查是准入控制的一部分，配额不足情况下，job 会被拒绝调度。</p><p data-pid="BUprI4QB">高优先级的配额成本比低优先级要高。生产级别的配额仅限于 cell 中实际可用资源，因此用户提交满足生产级别 job 运行预期的资源配额。虽然不建议用户配置超买，但是很多用户都会比实际的需要配额要大，以防止后续用户增长可能造成的资源短缺。对于超买，应对方案就是超卖。</p><p data-pid="rL0dBQZm">配额分配的使用在 Borg 之外进行处理，和物理容量设计密切相关，结果反映在不同数据中心的配额价格和可用性上。Borg 通过 capability 系统，给予某些用户特殊权限，如允许管理员删除或者修改任意 cell 中的 job，或者运行用户访问受限的内核功能或者 Borg 操作，如禁用其 jobs 预算。</p><p class="ztext-empty-paragraph"><br></p><h3><b>Naming and monitoring</b></h3><p data-pid="PQuULXKj">Borg的服务发现通过BNS(Borg Name Service)来实现。</p><p data-pid="leH36gyR">例: <code>50.jfoo.ubar.cc.borg.google.com</code></p><ul><li data-pid="jibhCqww"><code>cc</code>: 表示Cell名</li><li data-pid="qnw3uGRH"><code>ubar</code>: 表示用户名</li><li data-pid="v33JJeeY"><code>jfoo</code>: 表示Job名</li><li data-pid="NL5IVJGK"><code>50</code>: 表示当前服务是Job中的第几个Task</li></ul><p data-pid="UN9ZRZx8"><b>我理解Naming就是Kubernetes中的Service。</b></p><p data-pid="5shXoH6w">在Borg上运行的每一个服务，都可以通过Naming服务来暴露其域名，以便集群外部的流量来访问该服务。在微服务架构下，Micro Service A和Micro Service B之间，就可以通过这种Naming Service来完成微服务之间的调用。</p><p data-pid="Gp2rwcUZ">综上所述，Borg其实隐含了3层含义: </p><ol><li data-pid="4v822qun">集群(计算资源)管理的概念。需要把多台机器组成一个集群(Cell)，然后交给Borg的控制平面去管理</li><li data-pid="c8EEtLBx">作业的描述和调度的概念。因此Borg是一个作业调度平台</li><li data-pid="Wjh_03U0">服务发现的概念。Naming的存在是为了解决微服务之间的调用问题，因此Borg是一个服务发现平台</li></ol><p data-pid="S3FE1n0S">只是提供创建和运行是不够的，服务客户端和相关系统需要能够访问到对应的服务，即使被重新调度到新的机器上。因此，Borg 针对每个 task 创建一个稳定的 "Borg name service" (BNS)，包括 cell 名，job 名和 task 数量。Borg 用这个名字将 task 的主机名和端口写入到 Chubby 一致且高可用的文件中，该文件用于 RPC 系统查找 task 端。BNS 名也用于 task DNS 名构成基础，如用户 ubar 在 cell cc 上执行的 job jfoo 第 50 个 task，可以通过 <code>50.jfoo.ubar.cc.borg.google.com</code> 访问。Borg 还会在发生变化的时候把 job 大小和 task 健康信息写入到 Chubby，以使得负载均衡器可以获取到请求路由指向。</p><p data-pid="wsFBC6oo">几乎所有运行在 Borg 上的 task 都包含一个内建的 HTTP server，用于发布 task 的健康信息和数千个性能指标（如 RPC 延迟）。Borg 监控健康检测 URL 并且在 tasks 无响应或者返回错误的 HTTP 码时重启。其它的数据会被监控工具追踪展示在 Dashboards 上并且在服务级别（SLO）问题时告警。</p><p data-pid="h-7O6qj_">用户可以通过一个名叫 Sigma 提供的 Web 用户界面上，检查 jobs 的状态，查看特定的 cell，或者深入查看各个 jobs 和 tasks，检测它们的资源占用，详细的日志和执行历史，以及最终的宿命。应用程序会产生大量的日志，通过日志轮转避免磁盘空间不足，并且在任务退出后保留一段时间以协助进行调试。如果一项工作没有运行，Borg 会提供一个 "有待处理的" 注释，以及如何修改 job 资源请求用以更好的适配 cell。</p><p data-pid="LF7cpxdh">Borg 记录所有 job 提交和 task 事件，详细到每个 task 资源使用信息记录在基础设施存储。这是一个可伸缩的只读数据存储，并且由 Dremel（Google 交互式数据分析系统）提供类 SQL 方式进行交互。数据被用于计费，调试 job 和系统故障以及长期的容量规划。它也提供 Google 集群工作负载跟踪数据。</p><p data-pid="zy18SFua">所有的这些特性帮助用户理解和调试 Borg 以及他们的 jobs，并且帮助我们的 SREs 每人管理数万台主机。</p><p class="ztext-empty-paragraph"><br></p><h2><b>应用高可用</b></h2><p data-pid="E2MZL4m0">高可用是在线业务的命。如果一个应用失去了高可用性，那它就完全没有办法提供稳定的在线服务，这个后果是不可承受的。现在人们之所以用Kubernetes平台，就是因为它对高可用的场景做了很丰富的支持。</p><p data-pid="IvXU3-Rz">被抢占的non-prod任务放回pending queue，等待重新调度</p><p data-pid="cwiYBZm3">在线业务应该永远保证其高可用，这是第一目标。因此当在线业务对资源有需求时，这种需求应该优先保证。所以Borg在这方面做了一些事情: <b>当在线业务有资源需求时(例如要部署一个在线业务，或者要扩容一个在线业务)，Borg就会为这个在线业务做调度。</b> 假设调度时，<b>集群中已经没有可用资源了，Borg会去杀离线业务。也就是把离线业务的资源抢过来给在线业务，让在线业务先跑。</b></p><blockquote data-pid="Nj3foiip">但是离线业务也没有直接丢弃，而是把这个离线业务放回pending queue中，等到有资源时再重新跑。</blockquote><p data-pid="aWjoO0mF">这样既保证了在线业务的高可用，又保证了离线业务的作业不会丢失，不会处于异常状态。</p><p data-pid="D1zs9G7K">多副本应用跨故障域部署。所谓故障域有大有小，比如相同机器、相同机架或者相同电源插座等，一挂全挂</p><p data-pid="2DzNjlPr">Borg 提供了一些能力，来支持跨地域的、跨故障域的部署。高可用往往通过冗余部署来实现。</p><blockquote data-pid="eTxfNu_R">举个例子，常态下1个服务只有1个副本。当这个副本出现故障时，就意味着这个服务不可用了。想要保持这个服务高可用，多部署几份，在这几份前面配个负载均衡即可。<br>10万台机器，如果被分成10个Cell，那就是10个集群，每个集群1万个节点。这样的话就把整个数据中心切割成了不同的故障域。假设其中1个Cell出现故障，其他Cell不受影响</blockquote><p data-pid="qx1G-QcJ">假设所有的冗余都部署在了同一台机器上，那么当这台机器出现故障时，冗余部署就失去了意义。因此Borg提供了一个 <b>跨故障域(包括跨节点、跨机架、跨可用区、跨数据中心等)的多副本部署能力。</b></p><p data-pid="zGS0Pas_">对于类似服务器或操作系统升级的维护操作，避免大量服务器同时进行</p><p data-pid="41gAH5SA"><b>支持幂等性，支持客户端重复操作。</b></p><blockquote data-pid="0e6RIweg"><b>幂等</b>: 针对一个程序，给定其同样的输入，让该程序运行N次，该程序返回的N个结果是一样的，则称该程序是幂等的; 若返回结果不同，则该程序就不是幂等的。<br><b>解决幂等的方式就是声明式，让机器自己去找最优解（去重）。</b></blockquote><p data-pid="l4YcimqS"><b>那如何保证幂等：</b></p><ol><li data-pid="_v7MfXJp">要有一个用于处理输入的逻辑</li><li data-pid="sX5eRn6g">输入尽可能是一个声明式的输入。所谓声明式的输入，指的是尽可能地声明它是什么，而非输入指令、动作。因为指令、动作有可能不是幂等的</li></ol><p data-pid="bm0NYZq2"><b>Borg支持声明式的输入。</b> 例如: 声明一个作业，声明时定义好该作业需要的资源、要运行的应用等信息。那么这样的一个声明式指令无论发送多少次，其最终执行的结果都是一样的。</p><p data-pid="UTbDtNNP">当服务器状态变为不可用时，要控制重新调度任务的速率。因为Borg无法区分是节点故障还是出现了短暂的网络分区。如果是网络分区，则等待网络恢复更利于保障服务的可用性</p><p data-pid="GctBJjCn">当某种 <code>任务@服务器</code> 的组合出现故障时，下次重新调度时，避免这种组合再次出现，因为极大可能会再次出现相同的故障</p><p data-pid="X_sz9Uk8">记录详细的内部信息，便于故障排查和分析</p><blockquote data-pid="NfG3qZFs">保障应用高可用的关键性设计原则: 无论何种原因，即使Borgmaster或者Borglet挂掉、失联，都不能杀掉正在运行的服务(Task)</blockquote><p class="ztext-empty-paragraph"><br></p><h3><b>Borg系统自身高可用</b></h3><ul><li data-pid="Cc0EKRWf">Borgmaster组件多副本设计<br>Borgmaster组件多副本是为了保障Borg自身的高可用。无论是数据存储的高可用，还是Borgmaster这个控制平面的高可用，Borg都要保证。</li><li data-pid="uDx-RPVx">采用一些简单和底层(low-level)的工具来部署Borg系统实例，避免引入过多的外部依赖</li><li data-pid="_W0zeKve">每个<code>Cell</code>的<code>Borg</code>均独立部署，避免不同Borg系统相互影响<br>每个Cell独立部署，这样保证了整个数据中心的高可用。1个Cell坏了其他的Cell还活着，这样故障的Cell就成为了一个局部的故障。这个故障也只影响到了坏掉的Cell所管理的节点。换言之就是通过Cell将整个数据中心划分成了不同的故障域</li></ul><p class="ztext-empty-paragraph"><br></p><h3><b>资源利用率</b></h3><p data-pid="JHFfLx2i">通过将在线任务(prod)和离线任务(non-prod Batch)混合部署：</p><ul><li data-pid="hmtM5eFS">空闲时离线任务可以充分利用计算资源</li><li data-pid="Xyt1ZY1b">繁忙时在线任务通过抢占的方式保证优先得到执行，合理地利用资源（我理解的是 Kubernetes 的调度）</li></ul><p class="ztext-empty-paragraph"><br></p><h3><b>Borg的调度原理</b></h3><p data-pid="9ME4uUhW">很多人用云平台，都会有一个理想化的、先入为主的需求。比如一个业务开发人员，他的主要目标除了写好业务逻辑外，根本的核心需求就是业务的高可用。</p><p data-pid="cytFpxLr">想要达到这个目标，</p><ul><li data-pid="E683ygwx">第一：代码要足够健壮</li><li data-pid="8GsUHgWb">第二，要为服务预留足够的资源。至于到底预留多少才算是预留了"足够"的资源，这就是一个可以深入讨论的点了。</li></ul><p data-pid="O02ztqj1">一般的做法可以先做个压测。先限网，TPS(Transactions Per Second，每秒传输的事务处理个数，即服务器每秒处理的事务数)为10，压测100次，查看资源的使用情况。那么这个资源使用情况就已经是基于10倍的请求量得出的结果了。</p><p data-pid="mE8Dtww9">之后在申请资源时，按照这个结果申请资源。因为业务高峰期时要保证资源是足够的，所以开发人员都会尽可能多地去申请资源。多申请资源就会多占用资源，但常态下业务又达不到很高的资源利用率，最终很有可能的结果是：90%的资源都浪费掉了。</p><p class="ztext-empty-paragraph"><br></p><p data-pid="MHGJaSgX">Borg实现了一种机制：允许用户申请资源，但是在任务启动后会不停地监控作业，确认作业真正使用的资源数量。如果Borg发现作业用到的资源远远小于申请时的资源，就会进行回收。</p><p data-pid="BYJE89Dq"><code>保留的资源数量 = (1 + 阈值) * 作业真实使用的资源</code></p><p data-pid="nOq_Noim">将剩余的部分(即<code>申请的资源数量 - 保留的资源数量</code>)全都回收掉。这样就有效提升了整个集群的资源利用率。</p><p data-pid="rxkQbIYL">换言之，用户可以声明很多的资源，但是当用户提交的作业达不到一定的利用率时，Borg会把用户声明的资源中的一部分回收走，交给其他作业使用。这样整个集群的资源利用率就提高了。</p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic2.zhimg.com/v2-780f20897f6192b4a6dd8b8ca1ca11e5_r.jpg" data-caption="" data-size="normal" width="2024" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>隔离性</b></h3><p data-pid="yNkkVmiO">安全性隔离: </p><blockquote data-pid="F2hWp_k-">早期使用<code>chroot</code>、<code>jail</code>，后期版本基于Namespace<br>早期的iPhone越狱，其实就是<code>chroot</code>和<code>jail</code></blockquote><p data-pid="NtZFLHmH"><b>性能隔离:</b> </p><ul><li data-pid="tLvUsAju">采用基于Cgroup的容器技术实现</li><li data-pid="mxhTJW_a"><b>在线任务(prod)是延时敏感(latency-sensitive)型的，优先级高，而离线任务(non-prod、Batch)优先级低。（确定了调度策略）</b></li><li data-pid="SwAd3U32">Borg通过不同优先级之间的抢占式调度来优先保障在线任务的性能，牺牲离线任务。<br></li></ul><p data-pid="0f2mEfWk"><b>Borg将资源分成两类:</b> </p><ul><li data-pid="_L9jzYuv"><code>compressible</code>: 可压榨的，CPU是可压榨资源，资源耗尽不会导致进程终止<br>CPU是一个分时复用的资源，对于一个给定型号的CPU，它的CPU时间片数量是固定的。CPU时间片按照调度器的策略分配，每个进程最终都会分到一些时间片。当竞争较大的时候，所有进程都按照预先分配的比率，少分配一些时间片。这样的结果是: 进程的性能会慢一些，但整个程序不会退出。</li><li data-pid="FnYlhggo"><code>non-compressible</code>: 不可压榨的，内存是不可压榨资源，资源耗尽会导致进程被终止<br>1台机器的内存大小是固定的(此处假设主板上所有的内存槽都插满了)，如果所有进程都在疯狂占用内存，那最终的结果只能是: 没有可以分配的内存了。磁盘也属于不可压榨资源。不可压榨资源在利用率上一旦到达了边界，OS就只能终止进程。</li></ul><p class="ztext-empty-paragraph"><br></p><h2><b>什么是 Kubernetes</b></h2><p data-pid="fZreyjWI">Kubernetes是谷歌开源的容器集群管理系统，是谷歌多年大规模容器管理技术Borg的开源版本，主要功能包括：</p><ul><li data-pid="-PLGjTTl">基于容器的应用部署、维护和滚动升级</li><li data-pid="v9jrYhth">负载均衡和服务发现</li><li data-pid="FZv_NZbo">跨机器和跨地区的集群调度</li><li data-pid="3vXO9nd1">自动伸缩</li><li data-pid="hjLoR-tD"><b>无状态服务</b> 和 <b>有状态服务</b></li><li data-pid="bobwTDON">插件机制保证扩展性</li></ul><p data-pid="CZmXzcYN"><b>⚠️ 深入剖析 Kubernetes 书中，我们知道 有状态应用部署要求很高。</b></p><blockquote data-pid="9y_xo_Jo">无状态应用可以有相同的解决方案，但是有状态应用应该提前部署和设计，并且专业的人去维护。<br>Kubernetes 大部分都是无状态应用。因为有状态应用可能需要领域专家去维护和设计，成本很高。</blockquote><p class="ztext-empty-paragraph"><br></p><h2><b>Kubernetes 概念</b></h2><p data-pid="5GBT8kZG">Kunbernetes遵循了声明式系统的原则。Kunbernetes是构建与声明式系统之上的一个云管理平台。Kunbernetes中所有代管的对象(计算节点、服务、作业等)全部抽象成了标准API。这之后，就把这些API作为统一的规范，和一些大厂联合背书，让大家都遵循同样的规则下场玩游戏。这样一来，这套API就成了事实标准。这意味着所有下场玩游戏的玩家，都只能向这套标准靠拢。把目光看向未来，标准已然存在，标准可以演进，但标准很难被取代。取代一个已存在的标准，这件事可以称之为"革命"。</p><p class="ztext-empty-paragraph"><br></p><h2><b>命令式(Imperative) VS 声明式(Declarative)</b></h2><p data-pid="ge57vCgD"><b>最最最熟悉的莫过于 命令式：</b></p><p data-pid="qK9gMK19">在软件工程领域，命令式系统是写出解决某个问题、完成某个任务或者达到某个目标的明确步骤。此方法明确写出系统应该执行某指令，并且期待系统返回期望结果</p><p data-pid="lRwtnyf6">命令式系统通常是微管理的系统，因为要随时观察目标的变化。发一条指令给目标，让目标按照指令去做。目标按照指令做完了之后再返回，之后再发下一条指令给目标，以此类推。</p><p data-pid="7ZIUJenR">这种系统的特性是返回较快。可以基于上一次返回的结果判断下一次做出何种指示。</p><p class="ztext-empty-paragraph"><br></p><h3><b>声明式系统该做什么</b></h3><p data-pid="3YBHo2bh">在软件工程领域，<b>声明式系统指程序代码描述系统应该做什么而不是怎么做。</b> 仅限于描述要达成什么目的，至于如何达成这个目的，交给系统解决</p><p data-pid="1Bm_LZzn">声明式系统中间有一个运转的过程。调用者(用户)只能告知系统自己想要达到的目标，对于中间执行的过程，调用者不加干涉。</p><p class="ztext-empty-paragraph"><br></p><h3><b>声明式系统规范</b></h3><p data-pid="tNYkGUoT"><b>命令式</b>: </p><ul><li data-pid="x6FIGfTD">我要你做什么，怎么做，请严格按照我说的做</li></ul><p data-pid="AuEQMUui"><b>声明式</b>: </p><ul><li data-pid="7rLWaiZL">我需要你帮我做点事，但是我只告诉你我需要你做什么，而非你应该如何做</li><li data-pid="N3Zrs8KW">直接声明: 我直接告诉你我需要什么</li><li data-pid="OjzbTCAs">间接声明: 我不直接告诉你我的需求，我会把我的需求放在特定的地方，请在方便的时候拿出来处理</li></ul><p data-pid="s1ezQ-BO"><b>幂等性</b>: </p><ul><li data-pid="aaSO_l0C">状态固定，每次我要你做的事，请给我返回相同的结果</li></ul><p data-pid="F2Ey8KcB"><b>面向对象的</b>: </p><ul><li data-pid="7hA4rOGF">把一切抽象成对象</li></ul><p data-pid="uttCcWQO">声明式系统适用于微服务架构。很多时候调用者发送一个请求给Server端时，调用者是不知道一个Server端到底要针对这个请求处理多久的。如果按照交互式的系统，那么客户端就阻塞在发送请求之后了。整个系统的并发能力就会很差。</p><p class="ztext-empty-paragraph"><br></p><h2><b>Kubernetes 架构</b></h2><ul><li data-pid="X3Q8ShwP"><a href="https://docker.nsddd.top/Cloud-Native-k8s/" target="_blank">Kubernetes 的架构请看这篇文章</a></li></ul><p data-pid="BdYIsgZt"><b>我们回过头看 Kubernetes 和 Borg 类似的架构：</b></p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic3.zhimg.com/v2-05faa4985c0a9f4c856f3fc7dd0f664a_r.jpg" data-caption="" data-size="normal" width="3719" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic1.zhimg.com/v2-e8c46c182be631a1c3e2936d3d923e84_r.jpg" data-caption="" data-size="normal" width="5565" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h2><b>Kubernetes 的主节点</b></h2><p data-pid="Q3BL3jcL">和Borg一样，假设集群中有5000个节点，选2~3台节点作为管理节点即可。管理节点上运行的就是控制平面的组件。</p><blockquote data-pid="eUYOwSE8">etcd 基于 raft 算法，保证最优 3 个节点，并且是 <b>奇数节点</b><br>etcd是CoreOS基于Raft开发的分布式key-value存储，可用于服务发现、共享配置以及一致性保障(如数据库选主、分布式锁等)</blockquote><ul><li data-pid="09n5v7c4">基本的key-value存储</li><li data-pid="1wqWuBG-">监听机制</li><li data-pid="L0OcDJZW">key的过期以及续约机制，用于监控和服务发现</li><li data-pid="8XPu_W8b">原子CAS和CAD，用于分布式锁和leader选举</li></ul><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>API Server(API服务器)</b></h3><p data-pid="5gqGmEJP">这是Kubernetes控制面板中唯一带有用户可访问API以及用户可交互的组件。API Server会暴露一个RESTful的Kubernetes API并使用JSON格式的清单文件(manifest files)</p><p class="ztext-empty-paragraph"><br></p><h3><b>Cluster Data Store(集群的数据存储)</b></h3><p data-pid="X6Ck8BBI">Kubernetes使用etcd存储数据。这是一个强大的、稳定的、高可用的键值存储，被Kubernetes用于长久储存所有的API对象</p><p class="ztext-empty-paragraph"><br></p><h3><b>Scheduler(调度器)</b></h3><p data-pid="YPd6AQcC">调度器会监控新建的pods(一组或一个容器)并将其分配给节点</p><p data-pid="eN2xszWM">其实Scheduler和Controller没有本质区别，只是它专职做调度。</p><p class="ztext-empty-paragraph"><br></p><h2><b>Kubernetes 工作节点</b></h2><h3><b>kubelet</b></h3><p data-pid="iirtzCT0">负责调度到对应节点的Pod的生命周期管理，执行任务并将Pod状态报告给主节点的渠道，通过容器运行时(拉取镜像、启动和停止容器等)来运行这些容器。它还会定期执行被请求的容器的健康探测程序</p><p class="ztext-empty-paragraph"><br></p><h3><b>kube-proxy</b></h3><p data-pid="WAzLOt2w">负责节点的网络，在主机上维护网络规则并执行连接转发。它还负责对正在服务的pods进行负载均衡。</p><p class="ztext-empty-paragraph"><br></p><p data-pid="KhS5NfLi"><b>不管是 master 节点，或者是 worker 节点，每一个组件都是非常非常复杂的。</b></p><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h2><b>ETCD</b></h2><p data-pid="bOsghpqJ">ETCD 的学习笔记，之前做的比较全面了，直接参考 <a href="https://docker.nsddd.top/Cloud-Native-k8s/24.html" target="_blank">这一篇笔记~</a></p><p class="ztext-empty-paragraph"><br></p><h2><b>API Server</b></h2><p data-pid="Wjw_krUf">Kube-APIServer是Kubernetes最重要的核心组件之一。API Server本身是一个REST Server，因此它的扩展比较简单。</p><p data-pid="zadkn4i_">和etcd不同。<b>etcd是一个有状态应用的集群。对于这种有状态应用，加减member或替换member还是有些复杂的。</b> 像etcd就需要花一些时间做配置。因为在有状态应用的集群中，每一个member都是有意义的。比如向集群(假设此时集群中有n个member)中添加一个member，那么所有member的协商对象就会发生改变。原来有n个memeber参与协商，添加后有n+1个member参与，所以etcd要去更改所有memeber的协商对象，修改协商对象的一些配置文件。</p><p data-pid="Zkov8UZa">但对于像API Server这种无状态应用的集群，横向扩展比较简单。</p><p class="ztext-empty-paragraph"><br></p><h3><b>提供集群管理的REST API接口</b></h3><p data-pid="hpyBEe3a">包括以下的功能：</p><ul><li data-pid="G1_aT9pE">认证(Authentication)</li><li data-pid="bPTCyTvf">授权(Authorization)</li><li data-pid="OAJknPp5">准入(Admission)</li></ul><p class="ztext-empty-paragraph"><br></p><p data-pid="8yOnfaoY"><b>准入(Admission) 分为两个阶段：</b></p><p data-pid="4aE9Xgkb"><b>（1）Mutating</b></p><p data-pid="bjgoIS4P">当用户要创建一个对象时，创建请求发送到了API Server。但从集群的视角看这个对象，还需要给这个对象做一些变形(比如: 增加一些属性;修改该对象的某些值等操作)。 这些操作在准入的Mutating阶段完成。在API Server接收到请求之后，直到该请求存储至etcd的路径过程中，向原始的需求中添加一些其他的属性。添加这些属性是为了后续方便做一些平台层面的操作。</p><p data-pid="KrC1yAsx"><b>（2）Validating</b></p><p data-pid="p15uFq2c">Validating阶段之前是Mutating阶段。当一个请求对象经历了Mutating阶段后，发生了变形。但变形后的请求对象不一定还是一个合法对象。Validating阶段就是负责对变形后的请求做校验的。</p><blockquote data-pid="qbBRmF2j"><b>准入阶段不通过，则整个请求不会被存储至etcd。</b></blockquote><p data-pid="S-4pNXwD"><b>结构图</b></p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic1.zhimg.com/v2-d88bc861b6a062e017b4cff8b9c3fd10_r.jpg" data-caption="" data-size="normal" width="4932" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p data-pid="oCw00nNJ">其他模块通过APIServer查询或修改数据，只有APIServer才能操作etcd</p><p class="ztext-empty-paragraph"><br></p><h3><b>提供数据的缓存</b></h3><p data-pid="GaLFewsF"><b>提供etcd数据缓存以减少集群对etcd的访问</b></p><blockquote data-pid="cR9qFNF4">API Server本身还是个缓存。</blockquote><p data-pid="uJpq0uZk">API Server是唯一和etcd通信的组件。etcd是一个分布式K-V存储服务。由于是分布式存储服务，所以性能并不会特别好。如果请求是海量的，那么etcd一定是无法及时处理的。</p><p data-pid="qNt54vfE"><b>因此API Server中维护了一份数据缓存。</b> API Server本身就会缓冲客户端对etcd的压力。对读操作而言，API Server也有缓存。如果客户端认同缓存中的内容，则这个读请求就不会发送至etcd。</p><p class="ztext-empty-paragraph"><br></p><h2><b>Controller Manager</b></h2><p data-pid="Hz6lJlZJ"><i>控制器的概念那可太多了~</i></p><p data-pid="wQaPCzEN">Controller Manager是集群的大脑，是确保整个集群动起来的关键</p><p data-pid="YUFmOR5W">Controller Manager的作用是确保Kubernetes遵循声明式系统规范，确保系统的真实状态(Actual State)与用户定义的期望状态(Desired State)一致</p><blockquote data-pid="4fTU0WOp">其实所有的控制器都遵循了同样的规范。先读取用户请求中的抽象对象，这个抽象对象中有用户的期望状态(Desired State)。读取到Desired State后，控制器就要去做真实的配置了。控制器要确保系统的真实状态(Actual State)和用户的期望状态保持一致。</blockquote><p data-pid="BTI2YRS7">Controller Manager是多个控制器的组合，每个Controller事实上都是一个control loop，负责侦听其管控的对象，当对象发生变更时完成配置</p><p data-pid="O-IUIfPD">Controller 配置失败通常会触发自动重试，整个集群会在控制器不断重试的机制下确保 <b>最终一致性(Eventual Consisitency)</b></p><p data-pid="FZpH5JbQ">如果配置出现了错误，控制器要自动重试，直到所有的请求都被满足，才放弃重试。<b>这种不断重试的机制最终要达到的目的是: 最终一致性(Eventual Consisitency)</b></p><blockquote data-pid="-3y_VZws"><b>例:</b>  用户提交了一个创建Pod的请求。在该请求中，用户描述该Pod需要4个CPU。但当前集群中已经没有任何节点能够满足该需求了，此时该Pod处于Pending的状态。即: 因为没有适合的节点，所以调度不成功。但这个调度后续还会不断重试，直到能够满足该请求的需求(可能是别的资源消失(退出)，释放了足够多的资源; 也可能是当前集群中有新的节点加入进来)，调度器会自动调用这个处于Pending状态的Pod，最终把这个Pod启动起来。</blockquote><p data-pid="B3SiVXuz">所谓 <b>Eventual Consisitency</b>，即从用户的视角看，<b>不需要明显的重试，只需告知平台用户的期望，其他的工作由平台来完成。</b></p><p data-pid="PLHTPSM4">但是从原有系统切到Kubernetes的情况下，往往会出现很多 <b>不适应性</b>。</p><blockquote data-pid="ZNYz5ho5">例如: 原有系统中，某服务要求3个实例。迁移到Kubernetes时，Kubernetes会去创建Pod(实际上是1个Pod的3个副本)，但Kubernetes并不保证一定能创建出3个能够运行的(处于Running)状态的Pod。但在原有系统中，对于申请资源是有其自己的失败机制的(比如提交申请后拿不到3个实例则判定为申请失败)。直白一点的说法就是: 原有系统有其自己的申请失败机制，和Kubernetes为确保Eventual Consisitency的重试机制相冲突</blockquote><p data-pid="gJyPNs1b">因此这种最终一致性的适应性是需要去理解的。</p><blockquote data-pid="0lUnObxo">在本例中，就可以使用超时控制的思路来解决这个问题。为该次申请设置一个超时时间(假设超时时间为T小时)，若提交申请后的T小时当Kubernetes还没有为该申请成功创建出3个处于Running状态的Pod，则报错。报错后就可以使用原有系统的申请失败机制来处理了。这样就可以与原有系统适配了。</blockquote><p class="ztext-empty-paragraph"><br></p><h3><b>工作流程</b></h3><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic4.zhimg.com/v2-31f7973f7e642969988c3adad3cfd18b_r.jpg" data-caption="" data-size="normal" width="3222" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>Informer 内部机制</b></h3><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic3.zhimg.com/v2-f9352857109ae7970da2e1c8514a6c6a_r.jpg" data-caption="" data-size="normal" width="3828" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p data-pid="f3OAHg-8">Kubernetes 中使用 http 进行通信，<b>如何不依赖中间件的情况下保证消息的实时性，可靠性和顺序性等呢</b>？答案就是利用了 Informer 机制。Informer 的机制，降低了了 Kubernetes 各个组件跟 Etcd 与 Kubernetes API Server 的通信压力。</p><blockquote data-pid="ZWHBVt6j">这么一说，可能还是不理解，雀氏，我参考收集了书籍和文档，归纳如下：<br>设计 Kubernetes 的架构是特别复杂的，这些人也都是Linux特别牛的人才。<br>我们都知道 Kubernetes 中有很多 API 对象，我们定义这些对象的时候，只需要去定义他们的数据结构。<br>数据结构创建好后，会通过 API Server 发布， 然后我们就可以查看了。<br>Kubernetes 中所有对象的 访问 都是通过 API Server 去做的~<br>Informer 就是会提供 <code>List &amp; Watch</code> 机制，启动后会发送一个长连接到 API Server。先 list 一下，后 watch 一下。<br>Reflector 通过反射机制解析 key，（swagger.json），将序列化 对象 转化为 Go语言 对象，放入 map。<br>后面是一个环状数据结构，然后我们往其中写入数据，数据满了就弹出老对象。放入 informer 中，然后就像图中说的，添加对象，同时分配 Event 到 Handler……<br>对象的信息 会 存储在本地缓存，所以我们后面读取对象的时候应该去 <code>Therad Safe Store</code> 读取，而不是去 API Server 中读取。<br>当我们需要更新对象的时候，需要去 API Server 中。<br>这样依赖 informer，降低了了 Kubernetes 各个组件跟 Etcd 与 Kubernetes API Server 的通信压力。</blockquote><p class="ztext-empty-paragraph"><br></p><p data-pid="_4-KID6s"><b>相关文章：</b></p><ul><li data-pid="AHsPO5fb"><a href="https://cloudnative.to/blog/client-go-informer-source-code/" target="_blank">深入了解 Kubernetes Informer</a></li><li data-pid="idKhqz92"><a href="https://github.com/huweihuang/kubernetes-notes" target="_blank">Kubernetes 学习笔记</a></li></ul><p data-pid="1bchA3u_"><b>这里需要对应 Kubernetes 的代码去看。该部分的代码主要位于<code>client-go</code>这个第三方包中。</b></p><ul><li data-pid="dP-8Xili"><a href="https://github.com/kubernetes/kubernetes/tree/master/staging/src/k8s.io/client-go/tools/cache" target="_blank"><span class="invisible">https://</span><span class="visible">github.com/kubernetes/k</span><span class="invisible">ubernetes/tree/master/staging/src/k8s.io/client-go/tools/cache</span><span class="ellipsis"></span></a></li></ul><blockquote data-pid="1zGrEvMm">此部分的逻辑主要位于<code>/vendor/k8s.io/client-go/tools/cache</code>包中，代码目录结构如下：</blockquote><div class="highlight"><pre><code class="language-bash"> cache
 ├── controller.go  <span class="c1"># 包含：Config、Run、processLoop、NewInformer、NewIndexerInformer</span>
 ├── delta_fifo.go  <span class="c1"># 包含：NewDeltaFIFO、DeltaFIFO、AddIfNotPresent</span>
 ├── expiration_cache.go
 ├── expiration_cache_fakes.go
 ├── fake_custom_store.go
 ├── fifo.go   <span class="c1"># 包含：Queue、FIFO、NewFIFO</span>
 ├── heap.go
 ├── index.go    <span class="c1"># 包含：Indexer、MetaNamespaceIndexFunc</span>
 ├── listers.go
 ├── listwatch.go   <span class="c1"># 包含：ListerWatcher、ListWatch、List、Watch</span>
 ├── mutation_cache.go
 ├── mutation_detector.go
 ├── reflector.go   <span class="c1"># 包含：Reflector、NewReflector、Run、ListAndWatch</span>
 ├── reflector_metrics.go
 ├── shared_informer.go  <span class="c1"># 包含：NewSharedInformer、WaitForCacheSync、Run、HasSynced</span>
 ├── store.go  <span class="c1"># 包含：Store、MetaNamespaceKeyFunc、SplitMetaNamespaceKey</span>
 ├── testing
 │   ├── fake_controller_source.go
 ├── thread_safe_store.go  <span class="c1"># 包含：ThreadSafeStore、threadSafeMap</span>
 ├── undelta_store.go</code></pre></div><p class="ztext-empty-paragraph"><br></p><p data-pid="-N_nekl7"><b>架构设计：</b></p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic4.zhimg.com/v2-359a50597b155b9778664849b1482de7_r.jpg" data-caption="" data-size="normal" width="1875" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p data-pid="5mY6RNCC">⚠️ 这张图分为两部分，黄色图标是开发者需要自行开发的部分，而其它的部分是 client-go 已经提供的，直接使用即可。</p><ol><li data-pid="-2iA2you"><b>Reflector</b>：用于 Watch 指定的 Kubernetes 资源，当 watch 的资源发生变化时，触发变更的事件，比如 Added，Updated 和 Deleted 事件，并将资源对象存放到本地缓存 DeltaFIFO；</li><li data-pid="E2A2eUzg"><b>DeltaFIFO</b>：拆开理解，FIFO 就是一个队列，拥有队列基本方法（ADD，UPDATE，DELETE，LIST，POP，CLOSE 等），Delta 是一个资源对象存储，保存存储对象的消费类型，比如 Added，Updated，Deleted，Sync 等；</li><li data-pid="74PT8cMQ"><b>Indexer</b>：Client-go 用来存储资源对象并自带索引功能的本地存储，Reflector 从 DeltaFIFO 中将消费出来的资源对象存储到 Indexer，Indexer 与 Etcd 集群中的数据完全保持一致。从而 client-go 可以本地读取，减少 Kubernetes API 和 Etcd 集群的压力。</li></ol><p class="ztext-empty-paragraph"><br></p><p data-pid="2RKpaw1c">看书本上的一个例子，想使用 Informer 的关键流程如下：</p><div class="highlight"><pre><code class="language-go"> <span class="nx">clientset</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">kubernetes</span><span class="p">.</span><span class="nf">NewForConfig</span><span class="p">(</span><span class="nx">config</span><span class="p">)</span>
 <span class="nx">stopCh</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">(</span><span class="kd">chan</span> <span class="kd">struct</span><span class="p">{})</span>
 <span class="k">defer</span> <span class="nb">close</span><span class="p">(</span><span class="nx">stopch</span><span class="p">)</span>
 <span class="nx">sharedInformers</span> <span class="o">:=</span> <span class="nx">informers</span><span class="p">.</span><span class="nf">NewSharedInformerFactory</span><span class="p">(</span><span class="nx">clientset</span><span class="p">,</span> <span class="nx">time</span><span class="p">.</span><span class="nx">Minute</span><span class="p">)</span>
 <span class="nx">informer</span> <span class="o">:=</span> <span class="nx">sharedInformer</span><span class="p">.</span><span class="nf">Core</span><span class="p">().</span><span class="nf">V1</span><span class="p">().</span><span class="nf">Pods</span><span class="p">().</span><span class="nf">Informer</span><span class="p">()</span>
 <span class="nx">informer</span><span class="p">.</span><span class="nf">AddEventHandler</span><span class="p">(</span><span class="nx">cache</span><span class="p">.</span><span class="nx">ResourceEventHandlerFuncs</span><span class="p">{</span>
   <span class="nx">AddFunc</span><span class="p">:</span> <span class="kd">func</span><span class="p">(</span><span class="nx">obj</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">{</span>
     <span class="c1">// ...
</span><span class="c1"></span>   <span class="p">},</span>
   <span class="nx">UpdateFunc</span><span class="p">:</span> <span class="kd">func</span><span class="p">(</span><span class="nx">obj</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">{</span>
     <span class="c1">// ...
</span><span class="c1"></span>   <span class="p">},</span>
   <span class="nx">DeleteFunc</span>  <span class="p">:</span> <span class="kd">func</span><span class="p">(</span><span class="nx">obj</span> <span class="kd">interface</span><span class="p">{}</span> <span class="p">{</span>
     <span class="c1">// ...
</span><span class="c1"></span>   <span class="p">})</span>
   <span class="nx">informer</span><span class="p">.</span><span class="nf">Run</span><span class="p">(</span><span class="nx">stopCh</span><span class="p">)</span>
 <span class="p">})</span>
</code></pre></div><p class="ztext-empty-paragraph"><br></p><h3><b>Deployment 协同工作原理</b></h3><p data-pid="4yJFlj7A"><b>先安装集群：</b></p><div class="highlight"><pre><code class="language-bash"> /root/workspces/sealer/_output/bin/sealer/linux_amd64/sealer run docker.io/sealerio/kubernetes:v1.22.15 --masters  192.168.137.133 --nodes 192.168.137.134 192.168.137.135 --user root --passwd <span class="m">123456</span></code></pre></div><p class="ztext-empty-paragraph"><br></p><p data-pid="7bqq1ws7"><b>在 master 节点上创建文件 <code>nginx-deploy.yaml</code></b></p><div class="highlight"><pre><code class="language-yaml"><span class="w">  </span><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">apps/v1</span><span class="w">
</span><span class="w">  </span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">Deployment</span><span class="w">
</span><span class="w">  </span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">nginx-deployment</span><span class="w">
</span><span class="w">  </span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span><span class="w">    </span><span class="nt">replicas</span><span class="p">:</span><span class="w"> </span><span class="m">1</span><span class="w">
</span><span class="w">    </span><span class="nt">selector</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">matchLabels</span><span class="p">:</span><span class="w">
</span><span class="w">        </span><span class="nt">app</span><span class="p">:</span><span class="w"> </span><span class="l">nginx</span><span class="w">
</span><span class="w">    </span><span class="nt">template</span><span class="p">:</span><span class="w">
</span><span class="w">      </span><span class="nt">metadata</span><span class="p">:</span><span class="w">
</span><span class="w">        </span><span class="nt">labels</span><span class="p">:</span><span class="w">
</span><span class="w">          </span><span class="nt">app</span><span class="p">:</span><span class="w"> </span><span class="l">nginx</span><span class="w">
</span><span class="w">      </span><span class="nt">spec</span><span class="p">:</span><span class="w">
</span><span class="w">        </span><span class="nt">containers</span><span class="p">:</span><span class="w">
</span><span class="w">          </span>- <span class="nt">name</span><span class="p">:</span><span class="w"> </span><span class="l">nginx</span><span class="w">
</span><span class="w">            </span><span class="nt">image</span><span class="p">:</span><span class="w"> </span><span class="l">nginx</span></code></pre></div><p data-pid="rQX9MPRO">Deployment对象用于描述一个无状态应用部署的对象。</p><p data-pid="tkiMwBKC">在这个yaml文件中，template部分是一个模板。用户希望在Kubernetes上部署一个应用。应用在Kubernetes集群内部，就是一个Pod.此处用户指定:</p><ul><li data-pid="Ov6z7v2C">在该Pod中使用nginx镜像(<code>spec.template.spec.containers.image</code>)</li><li data-pid="SNZ-qiMO">指定该Pod的副本数为1(<code>spec.replicas</code>)</li></ul><p class="ztext-empty-paragraph"><br></p><p data-pid="q4ZRsvX5"><b>创建Deployment对象</b></p><div class="highlight"><pre><code class="language-bash"> kubectl create -f nginx-deploy.yaml -v <span class="m">9</span></code></pre></div><ul><li data-pid="_dz_oUsX">此处选项<code>-v 9</code>表示查看创建时的日志信息.</li></ul><p class="ztext-empty-paragraph"><br></p><p data-pid="-gSBZYOH"><b>读取配置文件</b></p><div class="highlight"><pre><code class="language-bash"> I0216 15:53:28.032360 <span class="m">1045972</span> loader.go:372<span class="o">]</span> Config loaded from file:  /home/soap/.kube/config</code></pre></div><blockquote data-pid="SkSoDD4w"><code>/home/soap/.kube/config</code>即kubectl默认读取的配置文件.<br> soap@k8s-master:~$ cat /home/soap/.kube/config<br> apiVersion: v1<br> clusters:<br> - cluster:<br>     certificate-authority-data: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSUMvakNDQWVhZ0F3SUJBZ0lCQURBTkJna3Foa2lHOXcwQkFRc0ZBREFWTVJNd0VRWURWUVFERXdwcmRXSmwKY201bGRHVnpNQjRYRFRJeU1ESXdPVEE0TXpBek5Wb1hEVE15TURJd056QTRNekF6TlZvd0ZURVRNQkVHQTFVRQpBeE1LYTNWaVpYSnVaWFJsY3pDQ0FTSXdEUVlKS29aSWh2Y05BUUVCQlFBRGdnRVBBRENDQVFvQ2dnRUJBTndnCmd3S1owUTlCcFBZTXJtSXYwK21yaEZuUWg1WDJhencyV1kxbUcxWnBNM3hLVXpsYnd1eGJZTkd5MWRWMXVOVDYKZTBMdFZqckNOZHBRWGhqYUI3UHJqbDRSR1RoT1FjQkFKMTNWclMva0hFVTFpWkdiOFhsdUJsa1JFRW1ZcEttdAo0R3dLbUJNdERYcENQdXdLVW5Ya05OamV4QlByWWF1bEcya0crL1oza2dGZnhIR2JBQjNjb25TamgxZTVlSzl5CkVUZXR2REE1cVBUS0hYRWlSdy91Uy9zdkQyWXBxVGpDOHRCeENNeGhGeXh2eXpIVVdQYlFjdTg0TG9pY0d0L2UKVUFDT1N3VUpiMTlndGlWSzlVWlZnb2V1bFZaS0Y2UHh2ZzkvRHhqc01ZQ1hZTXJCWXY3bUVIRU1DbVRBMWsvMApLY2FaOEo1dmVZWWlDVXUxM3FVQ0F3RUFBYU5aTUZjd0RnWURWUjBQQVFIL0JBUURBZ0trTUE4R0ExVWRFd0VCCi93UUZNQU1CQWY4d0hRWURWUjBPQkJZRUZNR0IrQUw4UGFZbVIwM1ZDNEJZUmsyNG5zT3hNQlVHQTFVZEVRUU8KTUF5Q0NtdDFZbVZ5Ym1WMFpYTXdEUVlKS29aSWh2Y05BUUVMQlFBRGdnRUJBR1dGd3YyT0EzV3lxemlRQXRPUQpKeEY2emFGL2pTQnJoSGc3WGV0NjdhcEZuRkFDaDZFbklTam9xd3ZEQ2MyQ0U1aHBtblNiT0luNUpxaThpeE5QCitKSGYxeXFmaHVrSWc0RjVUL0VjWnJGQXBPYWNHcVhlbTMzbWlLc0k1ZU5CUUY1WXFSeHVFai82bWt4WXlSUEcKMGNhd3VWeUlRMm01VTZPa3RnUW5neUtrS3BrQk5BcWcranJRTi9CdVoxTGRZcElvVXVpMVZxbHJhSmRTbG00RQplOWk3ekhIM3VOajdEdTJTdERreXdkOWF2VGMzRjBTRXI2TXd5cTZrdVgraFB3a2ZZeHNzNTlDc1E1alp3cGFhCkp0Skw2Ni9xaDFieTREbjNZOE5UaDlNZnRlMWRoc1pXaGVkYmZta3ErWVY2TlowTWJlRC9ZZ2lmNFJKM1U5V3cKNnVFPQotLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0tCg==<br>     server: <a href="https://192.168.0.154:6443" target="_blank"><span class="invisible">https://</span><span class="visible">192.168.0.154:6443</span><span class="invisible"></span></a><br>   name: kubernetes<br> contexts:<br> - context:<br>     cluster: kubernetes<br>     user: kubernetes-admin<br>   name: kubernetes-admin@kubernetes<br> current-context: kubernetes-admin@kubernetes<br> kind: Config<br> preferences: {}<br> users:<br> - name: kubernetes-admin<br>   user:<br>     client-certificate-data: LS0tLS1CRUdJTiBDRVJUSUZJQ0FURS0tLS0tCk1JSURJVENDQWdtZ0F3SUJBZ0lJR3dSdXh4ZFFjbzR3RFFZSktvWklodmNOQVFFTEJRQXdGVEVUTUJFR0ExVUUKQXhNS2EzVmlaWEp1WlhSbGN6QWVGdzB5TWpBeU1Ea3dPRE13TXpWYUZ3MHlNekF5TURrd09ETXdNemRhTURReApGekFWQmdOVkJBb1REbk41YzNSbGJUcHRZWE4wWlhKek1Sa3dGd1lEVlFRREV4QnJkV0psY201bGRHVnpMV0ZrCmJXbHVNSUlCSWpBTkJna3Foa2lHOXcwQkFRRUZBQU9DQVE4QU1JSUJDZ0tDQVFFQTZVenhRY1BBNUowcFJTc3UKcklOMkZKNFMwZUpwOFZkRmRidXM4Q0syQzk3Snl0eG9WRXJ2c0g1U1BUWU1kdWJRdFFkRkl2UzZYTHVnNmYzZQpaa0NVNmd5bit2bEIyNDRKQU15RFlPOG1GbU5RM3dKQUhRYXhsUTBITTdkUFhBZDJqOFVoZzZNRlRheGgxMmtNCjV4OXNJdndRM0c3LzFOZ240MnhoeWpZZDhlaGNkMFduNTJkY3VhNXcwU1FPN09mY0FkMU02TkU4dG1qMHZRejQKYU10MDFteXU5R0VKQU5nRFAxZXZZeTVLYTFDd0lGbEM0UVVVRXBSc3hud3EybW04amdEN3p1RXV1TDE2eEJocgphc1ZHWXhjcEMxQUxUNjFhbGU1TURBblc3RFZXL1R4cEgxZ3ROOENhOTVONTNITVAvc0NpMGh2bjlDM1FOaXc1CkQzc2ZMd0lEQVFBQm8xWXdWREFPQmdOVkhROEJBZjhFQkFNQ0JhQXdFd1lEVlIwbEJBd3dDZ1lJS3dZQkJRVUgKQXdJd0RBWURWUjBUQVFIL0JBSXdBREFmQmdOVkhTTUVHREFXZ0JUQmdmZ0MvRDJtSmtkTjFRdUFXRVpOdUo3RApzVEFOQmdrcWhraUc5dzBCQVFzRkFBT0NBUUVBeUhwaWdjdFpOVzd5ZStIc3Z2OWF1b0JQU05DdEJKZU8wbGtPClM3YmNwcTRSaFRQdVo0VzhtK3BzNGF5QndaQUtOTDQ5MXdYbVZqWE5ETG1IQ0FXb3dObldyVGNrZHR4UGtXeTUKNmFpSHdYaVUxK2dPRFlFQzdDTGlKR3RIRHZ4dkRvM2xRb2FBZEVpNnF5TVUvUmJIajRPTmduQ1VYSHNpMFB1WQppSHNZQWUxT2VTVmlKeVhBK1RjZ3RZZlc1N0xubnJ0WThsaWJYNzZHU1RaVHBlUUtiOUcyU3ZESitkQVpWYVhPCkUrZE1rays1Q0V4d1BTZEVDNnVEcjlkMVliSGNabEE2VlRpRnYrakpHWDdYZEd2ODI1bWhmUmRKc21LVGpmTjcKSHZiVEI4SFhyNkJIQ1d3emZmOXA0OXNnWUNVRHpLRmcwaWhmdStNQVZjeGtUMHlLRVE9PQotLS0tLUVORCBDRVJUSUZJQ0FURS0tLS0tCg==<br>     client-key-data: LS0tLS1CRUdJTiBSU0EgUFJJVkFURSBLRVktLS0tLQpNSUlFb3dJQkFBS0NBUUVBNlV6eFFjUEE1SjBwUlNzdXJJTjJGSjRTMGVKcDhWZEZkYnVzOENLMkM5N0p5dHhvClZFcnZzSDVTUFRZTWR1YlF0UWRGSXZTNlhMdWc2ZjNlWmtDVTZneW4rdmxCMjQ0SkFNeURZTzhtRm1OUTN3SkEKSFFheGxRMEhNN2RQWEFkMmo4VWhnNk1GVGF4aDEya001eDlzSXZ3UTNHNy8xTmduNDJ4aHlqWWQ4ZWhjZDBXbgo1MmRjdWE1dzBTUU83T2ZjQWQxTTZORTh0bWowdlF6NGFNdDAxbXl1OUdFSkFOZ0RQMWV2WXk1S2ExQ3dJRmxDCjRRVVVFcFJzeG53cTJtbThqZ0Q3enVFdXVMMTZ4QmhyYXNWR1l4Y3BDMUFMVDYxYWxlNU1EQW5XN0RWVy9UeHAKSDFndE44Q2E5NU41M0hNUC9zQ2kwaHZuOUMzUU5pdzVEM3NmTHdJREFRQUJBb0lCQURwamFWWCtPZjU5WHVEUwp4K0doSFNKWDFYbjE0bkhtVjVuNW1IU1pHMXFwTFhPNTZkcCt6cklyUzBYS2l5QU84RmorTXMxbTFtVnpCL2pICjhxdEFxb1JSR3BGelpJb2dhQnh0RXN4bHpmQjRkcnI1Z3paQWdKMC9IM2hQL21xWDY1SmIwZUZ5SVZlcE51dUUKZlJnekF3dFdicG5jcGVhTkdwNk9kNEwyUEZSWVNxaXZIZWQrYTFmT3hOeVNOUkQ0TkVXMzB1M2Q4OGk4c1pSUApsRlFuWTRlVytqaUc2Vmx1RzduUHNobDdGdzdIM09IOUZJMjFCbURMbmt6alI5SExNZTJhYllnSS96RWFtOGJXCkZObjFSVnpIVXNHYnRYZmpMTy8zT2lmVTY4MUdHZ1FSbU5GZ09NK1NrTjh4VEs4Rzd4QjBMdExVQ2RMVDVuTW0KZndtQ3VRRUNnWUVBNmF6MHQ2UEdOR0JEUXJoNHdWNGNZNlNuOTMzWDc3bEdEcmVhWWNDOVBnRHBJUGxkSUVJQwp1UThTaHNTOFRUSWsya05MK1FyWlorZUNRVmE5MEFXbHY4S0NiRXg3NzFkcS9BUDM4YkVsOXZ5eS9sZktXQjNlCng4OVFVNjlQUWdialJXaGF5VTJTS0ZtRzVlRE9iaVcxMEt5SWNmSXNCZ0hpUzJSR1hsdlpKY0VDZ1lFQS81YlEKVWhXc3lic2ZRTVlPUXkwQjVCYzRvZWF5K2ltc2RoRHF1azhZWFQ3TDZtTUNJYjF2MmhnZVErb1A5cU9LUEtpOApKbnoyY3N2czhZWUJ4UXFZeWc2U1JXMWhDNmQza00xRldKckhmdERiZXdFMS9VNlQ1L29XMWVJd3ZTRTVtMDEzClFqQTNURUwzM2RSSEQ2UlQ5Skd4V2JCcHpReTFNZno5OHl5NDRPOENnWUE3RjRiSERiNW9ybE0wQXl4ZVVldEIKODNpYWFKTjd4dEdGbFQ2UUs4cHZiSkdIeWllWHFibkFqS1ExdW5pWDJPOWkxcFBXeGJ5V3Z2KzhnQy85OC8rbgpUNHZsMFMyaUord2hFT3ZaamQrNDVzeG83MUIzR2c2bFhyTEVodGUzTGNDNVk1dFp2cWtRVlJ0ODlHMmZneC9JClJtazJ6M1A4ak90cC8xQ2dPZi9ld1FLQmdRRGxoYVM4SWhUUjhBVm40TFFNSlUzT2JBQUNmQzc3c2hMYXorUksKdlI3UEZjWi9UTHdzV25jb3JvSDNVU2xXdnBRMFZ2N252VTUvMXB1SVpXUVBjNjJ6dmhRaTNzL0liSEpXQ2RDZAplaGx1eTlaZGhyL2FJd2QxeWNOWi9VN3hlUFhIZm5CN2N0c2wwL25OTG9WR0NiY1BLUXJQMVRtZDF5eWNvR25aClI2OGE1d0tCZ0dmUmdqSEUzTWdKZkIrL09BR1lNYlhSMzZuQmYvVWozNktTZ1JYK2ZQRnRpWndDNXpIZ1FydHYKejI4N0lEWERIWlVxeEhrZkVJN1k2eld4aHpLVStwdnFpOFB5NzhRb3FmbkprdDBpVDM2bFRic0dUZHJvZW56Kwp2VEhYUjJEbk9yUDRjNHZYVEFGRzNiUUNsS0w1SUxaMHI1YjlmZGozRGJDRlJzNktBU1JJCi0tLS0tRU5EIFJTQSBQUklWQVRFIEtFWS0tLS0tCg== <br>可以看到配置文件中有APIServer的地址和用于用户认证的身份信息</blockquote><p data-pid="h4KmoaiG">有了这些信息之后,kubectl就把请求发送到了APIServer的地址</p><div class="highlight"><pre><code class="language-bash"> I0216 15:53:28.033943 <span class="m">1045972</span> round_trippers.go:466<span class="o">]</span> curl -v -XGET  -H <span class="s2">"Accept: application/com.github.proto-openapi.spec.v2@v1.0+protobuf"</span> -H <span class="s2">"User-Agent: kubectl/v1.23.3 (linux/amd64) kubernetes/816c97a"</span> <span class="s1">'https://192.168.0.154:6443/openapi/v2?timeout=32s'</span>
 soap@k8s-master:~$ kubectl get rs
 NAME                          DESIRED   CURRENT   READY   AGE
 ...
 nginx-deployment-6799fc88d8   <span class="m">1</span>         <span class="m">1</span>         <span class="m">1</span>       20m
 ...</code></pre></div><p class="ztext-empty-paragraph"><br></p><h3><b>控制器工作</b></h3><p data-pid="U6l25Z1R">APIServer在完成认证、鉴权、准入的步骤后，将请求存储至etcd。存储完毕后控制器开始工作。</p><p data-pid="PoQcnQuP">本例中我们创建的是一个 Deployment 对象，因此是由 Deployment Controller来完成这项工作.。Deployment对象有其语义，Deployment对象表示用户希望创建一个Pod(本例中创建的是只有1个副本的Pod).</p><p data-pid="kW8CG4n6">Deployment Controller会去解析Deployment对象，并创建ReplicaSet对象(副本集对象)。相当于Deployment Controller告知APIServer：Deployment Controller要创建一个ReplicaSet对象，并将模板(yaml文件中的template部分)发送给APIServer.</p><p data-pid="rg0t7Nd6">ReplicaSet对象同样经过认证、鉴权、准入的步骤后，被存储至了etcd.之后ReplicaSet Controller会Watch APIServer,监听ReplicaSet对象。当ReplicaSet Controller监听到ReplicaSet对象被创建后，同样会去解析该ReplicaSet对象。通过解析得知副本数量、Pod模板等信息后，ReplicaSet Controller就可以完成Pod的创建了。</p><p data-pid="VjxaVx7F">创建Pod这一操作同样也作为一个请求被发送到了APIServer。该Pod在创建时没有经过调度。</p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic1.zhimg.com/v2-003bcecbdaeebfb717c36304aae114f4_r.jpg" data-caption="" data-size="normal" width="2024" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><blockquote data-pid="xOZMaNsQ"><b>可以看到 deployment 并不是直接控制 pod ，而是 通过 创建 ReplicaSer 间接的控制 / 创建 Pod ，但是 deployment 只是负责水平迁移。所以是一个 双层控制器 实现故障转移和 HA（通过滚动升级实现）~</b></blockquote><p data-pid="WAq4Yep6"><b>最后节点的 kubelet 就开始干活了，kubelet 监听绑定至本节点的 pod，然后去查一查，这个 pod 有没有 run。</b></p><p data-pid="dkGuOLxf">init pod actions：</p><p data-pid="nuwOlR2D">Kubernetes 在启动 docker 的时候，只是启动 runtime，然后调用 网络插件 CNI。</p><p data-pid="4u_swhNY">如果需要存储，就有 CSI。</p><p class="ztext-empty-paragraph"><br></p><h3><b>Scheduler</b></h3><p data-pid="JnJJEI0m">特殊的Controller，工作原理与其他控制器并无差别。</p><p data-pid="gpnhjUB7">Scheduler的特殊职责：监控当前集群中所有未调度的Pod，并且获取当前集群所有节点的健康状况和资源使用情况，为待调度的Pod选择最佳计算节点，完成调度。</p><p class="ztext-empty-paragraph"><br></p><h3><b>调度阶段</b></h3><ul><li data-pid="-_pMP0tg">Predict<br>过滤不能满足业务需求的节点，如资源不足、端口冲突等。</li><li data-pid="2azztExd">Priority<br>按既定要素将满足调度需求的节点评分，选择最佳节点（调度算法）。</li><li data-pid="bEs5p6mN">Bind<br>将计算节点与Pod绑定，完成调度。</li></ul><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic2.zhimg.com/v2-63ed846df4ccabf68872915163495435_r.jpg" data-caption="" data-size="normal" width="1266" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>Kubelet</b></h3><p data-pid="ouk3QZrS">Kubernetes的初始化系统(init system)</p><p data-pid="cRvjLbJb">很重要的组件，负责启动 pod，职责也是非常复杂的。</p><p data-pid="BqWyv4nn">从不同源获取Pod清单，并按需求启停Pod核心组件</p><ul><li data-pid="I0sDtD9Y">Pod清单可以从本地文件目录、给定的HTTPServer、Kuber-APIServer等源头获取</li><li data-pid="uMRL275h">Kubelet将运行时（runtime），网络和存储抽象成了CRI、CNI和CSI</li></ul><p data-pid="tI5WbWDr"><b>负责汇报当前节点的资源信息和健康状态</b></p><p data-pid="4khkLnV8">负责Pod的健康检查和状态汇报。</p><blockquote data-pid="LvOdcGtp">调度阶段完成后，目标节点上的kubelet会发现该Pod和当前节点存在绑定关系，kubelet会调用CRI、CNI和CSI来启动这个容器。</blockquote><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic2.zhimg.com/v2-c6b58fe0c71bf4619eb1d994e7bf00e5_r.jpg" data-caption="" data-size="normal" width="1645" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>Kube-proxy</b></h3><p data-pid="ZnCMwzQF">kube-proxy 也是在每个节点上都运行的。它是实现Kubernetes Service 机制的重要组件。毫无意外，kube-proxy 也是一个“控制器”。<b>它也从API Server 监听Service 和Endpoint对象的变化，并根据Endpoint 对象的信息设置Service 到后端Pod 的路由，维护网络规则，执行TCP、UDP 和SCTP 流转发。</b></p><p data-pid="n-iNUkJc">监控集群中用户发布的服务，并完成<b>负载均衡</b>的配置。</p><p data-pid="X54q6NTJ">每个节点的 Kube-proxy 都会配置相同的负载均衡策略，使得整个集群的服务发现建立在分布式负载均衡器之上，服务调用无需经过额外的网络跳转(Network Hop)</p><p data-pid="lSdACcao">负载均衡配置基于不同的插件实现 userspace</p><p data-pid="TA8PNqgC">OS网络协议栈不同的Hooks点和插件:</p><ul><li data-pid="T4x8_Eye">iptabes</li><li data-pid="w2vm4M31">ipvs</li></ul><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic2.zhimg.com/v2-a14e91d0a9fe0e7511ea53aa4052ee75_r.jpg" data-caption="" data-size="normal" width="2208" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h2><b>Add-ons</b></h2><p data-pid="kCPog0Lf">以上都是Kubernetes的核心组件，Kubernetes还有一些 Add-on.</p><blockquote data-pid="gPZv_C7F">以下服务之所以以<code>Add-on</code>的形式提供应用，是因为没有以上所讲的核心组件，整个集群是跑不起来的。但集群能够跑起来了(换言之核心组件都有了)剩下的应用就可以以附件的形式(或者说以普通用户（non root \ rootless)的形式)，创建一个Pod来搭载应用。</blockquote><p class="ztext-empty-paragraph"><br></p><p data-pid="gPxdUC39"><b>当然，核心的组件，和 Add-ons 的装法是不一样的，核心组件是通过二进制方式，启动。 </b></p><p class="ztext-empty-paragraph"><br></p><h3><b>推荐的 Add-ons</b></h3><ul><li data-pid="fmbEBYZI">kube-dns：负责为整个集群提供 DNS 服务；</li><li data-pid="4ylYDC41">Ingress Controller：为服务提供外网入口；</li><li data-pid="v2cUQsqx">MetricsServer：提供资源监控；</li><li data-pid="EEA6aZ19">Dashboard：提供 GUI；</li><li data-pid="d1wJAtsW">Fluentd-Elasticsearch：提供集群日志采集、存储与查询。</li></ul><p class="ztext-empty-paragraph"><br></p><h2><b>了解 Kubectl</b></h2><h3><b>Kubectl 和 Kubeconfig</b></h3><p data-pid="wLCk8kbO">kubectl 是一个 Kubernetes 的命令行工具，它允许Kubernetes 用户以命令行的方式与 Kubernetes 交互，其默认读取配置文件 <code>~/.kube/config</code>。</p><ul><li data-pid="g7VAr9Nv">kubectl 会将接收到的用户请求转化为 rest 调用以 rest client 的形式与 apiserver 通讯。</li><li data-pid="Dt1vfxHx">apiserver 的地址，用户信息等配置在 kubeconfig。</li></ul><p data-pid="G6-B6-_5">通过 <code>-v</code> 参数打印日志以查看 <code>kubectl</code> 具体执行流程：</p><div class="highlight"><pre><code class="language-bash">❯ kubectl get po -v <span class="m">9</span>
I0303 09:04:45.314593  <span class="m">137729</span> loader.go:372<span class="o">]</span> Config loaded from file:  /root/.kube/config
I0303 09:04:45.360723  <span class="m">137729</span> round_trippers.go:435<span class="o">]</span> curl -v -XGET  -H <span class="s2">"Accept: application/json;as=Table;v=v1;g=meta.k8s.io,application/json;as=Table;v=v1beta1;g=meta.k8s.io,application/json"</span> -H <span class="s2">"User-Agent: kubectl/v1.22.15 (linux/amd64) kubernetes/1d79bc3"</span> <span class="s1">'https://apiserver.cluster.local:6443/api/v1/namespaces/default/pods?limit=500'</span>
I0303 09:04:45.393763  <span class="m">137729</span> round_trippers.go:454<span class="o">]</span> GET https://apiserver.cluster.local:6443/api/v1/namespaces/default/pods?limit<span class="o">=</span><span class="m">500</span> <span class="m">200</span> OK in <span class="m">32</span> milliseconds
....</code></pre></div><p data-pid="UCJQzkke"><b>可以看到 kubectl 是对 API 的封装。</b></p><p data-pid="0ZocybS9">我们看一下配置文件有什么：</p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic1.zhimg.com/v2-d1c81f0e169ce976fab5524be04f11dc_r.jpg" data-caption="" data-size="normal" width="2323" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p data-pid="JPXbdsYD">我们可以看一下所有的命令都会读取 kubectl 配置文件</p><ul><li data-pid="PLyzPz2K">contexts：我们用哪个用户去链接</li><li data-pid="lpGnQ7pT">current-context：如果我们不指定 context，那么使用的是哪个（默认）</li><li data-pid="YZbYkYgp">用户的 Key 和 Secret</li></ul><p class="ztext-empty-paragraph"><br></p><h3><b>常用命令</b></h3><div class="highlight"><pre><code class="language-bash">kubectl get po –o yaml -w</code></pre></div><ul><li data-pid="uZOmVHLO"><code>-o yaml</code> ：输出详细信息为 yaml 格式。</li><li data-pid="_Wn67IRu"><code>-w</code> ：watch 该对象的后续变化。</li><li data-pid="Tt3Tqpnh"><code>-o wide</code> ：以详细列表的格式查看对象。</li></ul><blockquote data-pid="VRJK6mia"><code>-o yaml</code> 不是很常用，我们更多的时候可以用 <code>kubectl get po -owide</code> 多输出几个字段。</blockquote><p data-pid="zWNn8j-a"><code>kubectl describe</code> 展示资源的详细信息和相关 Event</p><p data-pid="HLXqnyaa"><code>kubectl exec</code> 提供进入运行容器的通道，可以进入容器进行 debug 操作。</p><p data-pid="NZbYfutm"><code>kubectl logs</code> 可查看 pod 的标准输入（stdout, stderr），与 tail 用法类似</p><p data-pid="WQZN3fZQ"><code>kubectl api-resources</code> 可以查看 Kubernetes 为我们提供的对象，有长名和短名字。</p><p class="ztext-empty-paragraph"><br></p><p data-pid="M6E6tH4V"><b>获取命名空间：</b></p><div class="highlight"><pre><code class="language-bash">❯ k get ns
NAME              STATUS   AGE
default           Active   10m
kube-node-lease   Active   10m
kube-public       Active   10m
kube-system       Active   10m</code></pre></div><p class="ztext-empty-paragraph"><br></p><h2><b>K8s 设计理念</b></h2><p data-pid="qAKMoyST"><b>可扩展性：</b></p><ul><li data-pid="96ADtcKx">基于CRD的扩展</li><li data-pid="PRBfeD4x">插件化的生态系统</li></ul><p data-pid="Wo576RRv"><b>高可用：</b></p><ul><li data-pid="0TqYGtnb">基于 replicaset，statefulset 的应用高可用</li><li data-pid="Er1gNb9i">Kubernetes 组件本身高可用</li></ul><p data-pid="yFMvvWZI"><b>可移植性：</b></p><ul><li data-pid="F6N7y4Hi">多种 host Os 选择</li><li data-pid="4iUMwNtw">多种基础架构的选择</li><li data-pid="3RAQPLXz">多云和混合云</li></ul><p data-pid="Nox7fbn4"><b>安全：</b></p><ul><li data-pid="pQq4S6Nu">基于 TLS 提供服务</li><li data-pid="c9VyNdvp">Serviceaccount 和 user</li><li data-pid="LlIwK1Zg">基于 Namespace 的隔离</li><li data-pid="pKkwL2H-">secret</li><li data-pid="CYK3_zeV">Taints，psp， networkpolicy</li></ul><p class="ztext-empty-paragraph"><br></p><h3><b>分层架构</b></h3><p data-pid="WCX-j1Tf"><b>核心层</b>：Kubernetes 最核心的功能，对外提供 API 构建高层的应用，对内提供插件式应用执行环境。</p><p data-pid="nsq1H72r"><b>应用层</b>：部署（无状态应用、有状态应用、批处理任务、集群应用等）和路由（服务发现、DNS 解析等）。</p><p data-pid="MwRLPvUd"><b>管理层</b>：系统度量（如基础设施、容器和网络的度量）、自动化（如自动扩展、动态 Provision 等）、策略管理（RBAC、Quota、PSP、NetworkPolicy 等）。</p><p data-pid="5SSLYsFj"><b>接口层</b>：Kubectl 命令行工具、客户端 SDK 以及集群联邦。</p><p data-pid="XClGHhMF"><b>生态系统</b>：在接口层之上的庞大容器集群管理调度的生态系统，可以划分为两个范畴：</p><ul><li data-pid="cdmnxI2v"><b>Kubernetes 外部</b>：日志、监控、配置管理、CI、CD、Workflow、FaaS、OTS 应用、ChatOps 等；</li><li data-pid="ihepHav8"><b>Kubernetes 内部</b>：CRI、CNI、CVI、镜像仓库、Cloud Provider、集群自身的配置和管理等。</li></ul><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic2.zhimg.com/v2-898016461b4740c31cc58599d38845b1_r.jpg" data-caption="" data-size="normal" width="1634" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic2.zhimg.com/v2-033c208307b3978dd2a2e78f0e23e985_r.jpg" data-caption="" data-size="normal" width="2024" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><blockquote data-pid="39oR5zXH">如果你一定要分类的话，Kubernetes 和 docker 是和 paas 相关的。</blockquote><p data-pid="VWCVhbvO"><b>分为两个视角：分别是集群管理员的视角和应用开发者的视角：</b></p><p data-pid="FpGXXjSr"><b>同样的分为两个平面：</b></p><ul><li data-pid="ZY0qftQ_">数据平面： pod、PVC、Service、Ingress</li><li data-pid="LWZNVTq4">控制平面：核心组件、插件、用户空间控制器、Assertion</li></ul><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic3.zhimg.com/v2-71b08635a05b537de611e82080a27cca_r.jpg" data-caption="" data-size="normal" width="720" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><blockquote data-pid="l2Cg44J6">Kubernetes 本身也是有分层架构，这保证了他的可扩展性。</blockquote><p class="ztext-empty-paragraph"><br></p><h2><b>API 设计理念</b></h2><p data-pid="Stci9X0A"><b>所有 API 都应是声明式的：</b></p><ul><li data-pid="DP9TwAte">相对于命令式操作，声明式操作对于重复操作的效果是稳定的，这对于容易出现数据丢失或重复的分布式环境来说是很重要的。</li><li data-pid="PA7ndJF-">声明式操作更易被用户使用，可以使系统向用户隐藏实现的细节，同时也保留了系统未来持续优化的可能性。</li><li data-pid="VZjtoSTW">此外，声明式的 API 还隐含了所有的 API 对象都是名词性质的，例如 Service、Volume 这些 API 都是名词，这些名词描述了用户所期望得到的一个目标对象。</li></ul><p class="ztext-empty-paragraph"><br></p><p data-pid="BrZYbt_J"><b>API 对象是彼此互补而且可组合的：</b></p><ul><li data-pid="Pq4McObC">这实际上鼓励 API 对象尽量实现面向对象设计时的要求，即“高内聚，松耦合”，对业务相关的概念有一个合适的分解，提高分解出来的对象的可重用性。</li></ul><blockquote data-pid="941snfuJ"><b>要在云原生基础上实现功能，先抽象出 API，即对象设计。</b></blockquote><p class="ztext-empty-paragraph"><br></p><p data-pid="JpYlxHtR"><b>高层 API 以操作意图为基础设计：</b></p><ul><li data-pid="qu90LCsB">如何能够设计好 API，跟如何能用面向对象的方法设计好应用系统有相通的地方，高层设计一定是从业务出发，而不是过早的从技术实现出发。</li><li data-pid="DEf2Zea-">因此，针对 Kubernetes 的高层 API 设计，一定是以 Kubernetes 的业务为基础出发，也就是以系统调度管理容器的操作意图为基础设计。</li></ul><p class="ztext-empty-paragraph"><br></p><p data-pid="Qf89u7aP"><b>低层 API 根据高层 API 的控制需要设计：</b></p><ul><li data-pid="xHwM51ql">设计实现低层 API 的目的，是为了被高层 API 使用，考虑减少冗余、提高重用性的目的，低层 API 的设计也要以需求为基础，要尽量抵抗受技术实现影响的诱惑。</li></ul><p class="ztext-empty-paragraph"><br></p><p data-pid="fURZft8a"><b>尽量避免简单封装，不要有在外部 API 无法显式知道的内部隐藏的机制：</b></p><ul><li data-pid="6PY8-5vm">简单的封装，实际没有提供新的功能，反而增加了对所封装 API 的依赖性。</li><li data-pid="-2aZZHxH">例如 StatefulSet 和 ReplicaSet，本来就是两种 Pod 集合，那么 Kubernetes 就用不同 API 对象来定义它们，而不会说只用同一个 ReplicaSet，内部通过特殊的算法再来区分这个 ReplicaSet 是有状态的还是无状态。</li></ul><p class="ztext-empty-paragraph"><br></p><p data-pid="WhuVpnx-"><b>API 操作复杂度与对象数量成正比：</b></p><ul><li data-pid="r0oqSy28">API 的操作复杂度不能超过 O(N)，否则系统就不具备水平伸缩性了。</li></ul><p class="ztext-empty-paragraph"><br></p><p data-pid="G92O90aF"><b>API 对象状态不能依赖于网络连接状态：</b></p><ul><li data-pid="SqE1ZNck">由于众所周知，在分布式环境下，网络连接断开是经常发生的事情，因此要保证 API 对象状态能应对网络的不稳定，API 对象的状态就不能依赖于网络连接状态。</li></ul><p class="ztext-empty-paragraph"><br></p><p data-pid="HV1ml412"><b>尽量避免让操作机制依赖于全局状态：</b></p><ul><li data-pid="RMKtqbMp">因为在分布式系统中要保证全局状态的同步是非常困难的。</li></ul><p class="ztext-empty-paragraph"><br></p><h3><b>Kubernetes 如何通过对象的组合完成业务描述</b></h3><p data-pid="TA_9Hz27"><b>我们知道 Kubernetes 中组合也是很重要的，Kubernetes 是如何使用组合的：</b></p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic3.zhimg.com/v2-9121f0d91a1270dab25ed8b63480a56a_r.jpg" data-caption="" data-size="normal" width="1608" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p data-pid="bwHoyGNe">通过一个<code>deployment</code>创建一次业务部署这样的对象，<code>deployment control</code>会去建<code>replicaset</code>，<code>replicaset</code>会去建<code>pod</code>，<code>pod</code>会被调度器产生绑定关系，这是业务部署描述的部分，还有涉及的对象就是业务要发布的时候，我要去定义一个<code>service</code>，<code>service</code>创建之后<code>kube-proxy</code>会为它配置各种负载均衡的配置以及<code>dns</code>会为它配置域名服务，要将服务发布出去我要去定义一个<code>service</code>对象，<b><code>service</code>又可以通过<code>ingress</code>一个流量入口来发布到整个集群数据面API网关里面。</b></p><p data-pid="eEh2SaSK">所以通过各种对象的组合来完成整个业务部署的描述。</p><blockquote data-pid="RGtTYPs5">注意<a href="https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/names/" target="_blank">命名规范</a>的业务逻辑和基于标签的业务逻辑。<br><b>deployment 是根据 HASH 决定创建的 Replicaset 的名字，如果我们程序的 bug 导致Hash 算法变了，那么就会产生严重的程序漏洞。</b></blockquote><p data-pid="oJaxKFk_">集群中的每一个对象都有一个<b><a href="https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/names/#names" target="_blank">名称</a></b>来标识在同类资源中的唯一性。</p><p data-pid="JryvpE7_">每个 Kubernetes 对象也有一个 <b><a href="https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/names/#uids" target="_blank">UID</a></b> 来标识在整个集群中的唯一性。</p><p data-pid="Km1GxpV7">比如，在同一个<a href="https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/namespaces/" target="_blank">名字空间</a> 中只能有一个名为 <code>myapp-1234</code> 的 Pod，但是可以命名一个 Pod 和一个 Deployment 同为 <code>myapp-1234</code>。</p><p data-pid="q3u8wSGK">对于用户提供的非唯一性的属性，Kubernetes 提供了<a href="https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/labels/" target="_blank">标签（Label）</a>和 <a href="https://kubernetes.io/zh-cn/docs/concepts/overview/working-with-objects/annotations/" target="_blank">注解（Annotation）</a>机制。</p><p class="ztext-empty-paragraph"><br></p><h3><b>架构设计原则</b></h3><ul><li data-pid="ScDKWxrn">只有 APIServer 可以直接访问 etcd 存储，其他服务必须通过 Kubernetes API 来访问集群状态；</li><li data-pid="0fDf7zrq">单节点故障不应该影响集群的状态；</li><li data-pid="RNd-UEzV">在没有新请求的情况下，所有组件应该在故障恢复后继续执行上次最后收到的请求（比如网络分区或服务重启等）；</li><li data-pid="ppNOkgL8">所有组件都应该在内存中保持所需要的状态，APIServer 将状态写入 etcd 存储，而其他组件则通过 APIServer 更新并监听所有的变化；</li><li data-pid="11IFRGxG">优先使用事件监听而不是轮询。</li></ul><blockquote data-pid="KTdNCfz0"><b>通俗易懂解释轮询，侦听和回调区别：</b></blockquote><ul><li data-pid="751im5fe"><b>轮询</b>：过10分钟就到女朋友宿舍前面去看她有没有回来、没回来我就再去打游戏。</li><li data-pid="RFzod0b1"><b>监听</b>：我搬个凳子坐到她宿舍前、直到她回来。</li><li data-pid="_RTyB86g"><b>回调</b>：在她门口贴个条子：回来后请打电话至011 。</li></ul><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>引导（Bootstrapping）原则</b></h3><blockquote data-pid="WZsYrMR5">k8s 安装、引导原则</blockquote><ul><li data-pid="47KcvqBU"><code>Self-hosting</code> 是目标。</li><li data-pid="EqQfM6-F">减少依赖，特别是稳态运行的依赖。</li><li data-pid="0SUanN4g">通过分层的原则管理依赖。</li></ul><p class="ztext-empty-paragraph"><br></p><p data-pid="tmSaDoEP"><b>Self-hosting：</b></p><blockquote data-pid="4HMIRlxN">Kubernetes 可用性是第一原则，HA。<br>第二保证控制平面也是高可用的，如果我们把 Kubernetes 的控制平面组件也容器化了，那么是不是可以让 Kubernetes 自己管自己了。</blockquote><figure data-size="normal"><img src="https://pic2.zhimg.com/v2-46a232798f6c42a7344db7e796f0943d_r.jpg" data-caption="" data-size="normal" width="1761" referrerpolicy="no-referrer"></figure><p data-pid="XxthakI_">，但是没有<code>kebelet</code>，因为 <code>kubelet</code> 需要启动 pod 是 Kubernetes 的初始化（init) 系统，所以不是以容器的形式。</p><p class="ztext-empty-paragraph"><br></p><p data-pid="OK4E7WWD"><b>Kubelet 拉取机制：</b></p><p data-pid="OOcQsShd">监听 API Server~</p><p data-pid="xVy4reot">查看 Kubelet 配置：</p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic1.zhimg.com/v2-83b54cb772bbda2abf6bde050de5cc4c_r.jpg" data-caption="" data-size="normal" width="2345" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><div class="highlight"><pre><code class="language-bash">cat /var/lib/kubelet/config.yaml</code></pre></div><blockquote data-pid="wZeobI1G">可以发现有一个 <code>staticPodPath</code> ，kubelet 会一直扫描 staticPodPath 目录中的文件，只要我们把任意一个 pod 丢进去， kubelet 就认为你会启动这个。<br>❯ ls /etc/kubernetes/manifests<br>etcd.yaml  kube-apiserver.yaml  kube-controller-manager.yaml  kube-scheduler.yaml<br>❯ cat /etc/kubernetes/manifests/kube-scheduler.yaml<br><b>kubelet  是一个 普通的进程~</b></blockquote><p class="ztext-empty-paragraph"><br></p><p data-pid="3vOlXCyB"><b>循环依赖问题的原则</b>：</p><ul><li data-pid="cBoBCFZi">同时还接受其他方式的数据输入（比如本地文件等），这样在其他服务不可用时还可以手动配置引导服务；</li><li data-pid="NjDMKTr0">状态应该是可恢复或可重新发现的；</li><li data-pid="BCPKK4hd">支持简单的启动临时实例来创建稳态运行所需要的状态，使用分布式锁或文件锁等来协调不同状态的切换（通常称为 pivoting 技术）；</li><li data-pid="iYvpjF7Z">自动重启异常退出的服务，比如副本或者进程管理器等。</li></ul><p class="ztext-empty-paragraph"><br></p><h3><b>核心技术概念和 API 对象</b></h3><blockquote data-pid="lt5s9cnV">云计算相关标准(抽象)的定义，保证了 k8s 处于不败之地。<br>因为当前所有云厂商都认可了 k8s 这套标准，后续就算有新的技术出现也必定遵循这套标准，否则云厂商肯定不会认可。</blockquote><p data-pid="LbNmRpss">API 对象是 Kubernetes 集群中的管理操作单元。</p><p data-pid="bhb8U5vL">Kubernetes 集群系统每支持一项新功能，引入一项新技术，一定会新引入对应的 API 对象，支持对该功能的管理操作。</p><p data-pid="RoVSj2LN">每个 API 对象都有四大类属性：</p><ul><li data-pid="bsxWrPSm">TypeMeta：定义的对象是什么</li><li data-pid="sX2W0OMj">MetaData：定义的对象名字和标签等基础属性</li><li data-pid="NYnfeJjZ">Spec：用户的期望值是什么</li><li data-pid="165TFWrm">Status：由系统的控制器实现的，用户无需关心（默认）</li></ul><p class="ztext-empty-paragraph"><br></p><h3><b>TypeMeta</b></h3><p data-pid="6d24ShjU">Kubernetes对象的最基本定义，它通过引入<b>GKV（Group，Kind，Version）</b>模型定义了一个对象的类型。</p><p data-pid="WlHlkAiP"><b>1. Group</b></p><p data-pid="TKt5n20A">Kubernetes 定义了非常多的对象，如何将这些对象进行归类是一门学问，<b>将对象依据其功能范围归入不同的分组，比如把支撑最基本功能的对象归入 core 组，把与应用部署有关的对象归入 apps 组</b>，会使这些对象的可维护性和可理解性更高。</p><p data-pid="gxeSghP8"><b>2. Kind</b></p><p data-pid="jZvCzsGf">定义一个对象的基本类型，比如 Node、Pod、Deployment 等。</p><p data-pid="GlyTB9D6"><b>3. Version</b></p><p data-pid="T8JvnQEH">社区每个季度会推出一个 Kubernetes 版本，随着 Kubernetes 版本的演进，对象从创建之初到能够完全生产化就绪的版本是不断变化的。与软件版本类似，通常社区提出一个模型定义以后，随着该对象不断成熟，其版本可能会从 v1alpha1 到 v1alpha2，或者到 v1beta1，最终变成生产就绪版本 v1。</p><p class="ztext-empty-paragraph"><br></p><h3><b>MetaData</b></h3><p data-pid="5Z2hbHAo">Metadata 中有两个最重要的属性：<b>Namespace和Name</b>，分别定义了对象的Namespace 归属及名字，<b>这两个属性唯一定义了某个对象实例</b>。</p><p class="ztext-empty-paragraph"><br></p><p data-pid="-7RFNF5w"><b>1. Label</b></p><p data-pid="lwfiMh48">顾名思义就是给对象打标签，<b>一个对象可以有任意对标签，其存在形式是键值对</b>。Label 定义了对象的可识别属性，Kubernetes API 支持以 Label 作为过滤条件查询对象。</p><ul><li data-pid="Dc_0Acc6">Label 是识别 Kubernetes 对象的标签，以 key/value 的方式附加到对象上。</li><li data-pid="GFQj9OoH">key 最长不能超过 63 字节，value 可以为空，也可以是不超过 253 字节的字符串。</li><li data-pid="4aCaFACe">Label 不提供唯一性，并且实际上经常是很多对象（如 Pods）都使用相同的 label 来标志具体的应用。</li><li data-pid="BFclEZKB">Label 定义好后其他对象可以使用 Label Selector 来选择一组相同 label 的对象</li><li data-pid="GTDj-A3x">Label Selector 支持以下几种方式：<br></li><ul><li data-pid="zooD14iB">等式，如 app=nginx 和 env!=production；</li><li data-pid="9qfnP_PI">集合，如 env in (production, qa)；</li><li data-pid="NeuZQ97f">多个 label（它们之间是 AND 关系），如 app=nginx,env=test。</li></ul></ul><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><p data-pid="2K-HaUCj"><b>2. Annotation</b></p><p data-pid="F1LiJ41U">Annotation 与 Label 一样用键值对来定义，但 Annotation 是作为属性扩展，更多面向于系统管理员和开发人员，因此需要像其他属性一样做合理归类。</p><ul><li data-pid="wkiHtGnX">Annotations 是 key/value 形式附加于对象的注解。</li><li data-pid="EMRMjXca">不同于 Labels 用于标志和选择对象，Annotations 则是用来记录一些附加信息，用来辅助应用部署、安全策略以及调度策略等。</li><li data-pid="g1JyZvcw">比如 deployment 使用 annotations 来记录 rolling update 的状态。</li></ul><p class="ztext-empty-paragraph"><br></p><p data-pid="rgzvrj1b"><b>3. Finalizer</b></p><p data-pid="e5l5vY0n">Finalizer 本质上是一个资源锁，Kubernetes 在接收某对象的删除请求时，会检查 Finalizer 是否为空，如果不为空则只对其做逻辑删除，即只会更新对象中的 <code>metadata.deletionTimestamp</code> 字段。</p><p class="ztext-empty-paragraph"><br></p><p data-pid="R96g0kOk"><b>4. ResourceVersion</b></p><p data-pid="aX8bUGCO"><b>ResourceVersion 可以被看作一种乐观锁</b>，每个对象在任意时刻都有其 ResourceVersion，当 Kubernetes 对象被客户端读取以后，ResourceVersion 信息也被一并读取。此机制确保了分布式系统中任意多线程能够无锁并发访问对象，极大提升了系统的整体效率。</p><div class="highlight"><pre><code class="language-bash"> <span class="o">[</span>root@dev ~<span class="o">]</span><span class="c1"># kubectl get ns kube-system -oyaml</span>
 apiVersion: v1
 kind: Namespace
 metadata:
   creationTimestamp: <span class="s2">"2023-03-03T11:44:55Z"</span>
   labels:
     kubernetes.io/metadata.name: kube-system
   name: kube-system
   resourceVersion: <span class="s2">"5"</span>
   uid: d0c7cf7a-7430-4d7f-a9fe-5fb2e66e0e0a
 spec:
   finalizers:
   - kubernetes
 status:
   phase: Active</code></pre></div><p class="ztext-empty-paragraph"><br></p><h3><b>Spec 和 Status</b></h3><p data-pid="Nj8Ghc9v">Spec 和 Status 才是对象的核心。</p><ul><li data-pid="YaPcuKpb">Spec 是用户的期望状态，由创建对象的用户端来定义。</li><li data-pid="6eZAk1Te">Status 是对象的实际状态，由对应的控制器收集实际状态并更新。</li><li data-pid="qMHrERGr">与 TypeMeta 和 Metadata 等通用属性不同，Spec 和 Status 是每个对象独有的。</li></ul><p class="ztext-empty-paragraph"><br></p><h3><b>常用对象及其分组</b></h3><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic1.zhimg.com/v2-b1ba78dfcffbcfe1a8c2c451787a9ea0_r.jpg" data-caption="" data-size="normal" width="706" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>核心对象概览</b></h3><h3><b>Node</b></h3><ul><li data-pid="XTF_JBJF">Node 是 Pod 真正运行的主机，可以物理机，也可以是虚拟机。</li><li data-pid="ThfGv-Ku">为了管理 Pod，每个 Node 节点上至少要运行 container runtime（比如 Docker 或者 Rkt）、Kubelet 和 Kube-proxy 服务。</li><li data-pid="3j8QUnHX">是一个计算节点的对象</li></ul><p class="ztext-empty-paragraph"><br></p><h3><b>Namespace</b></h3><p data-pid="TzxKqQh6"><b>Namespace 是对一组资源和对象的抽象集合</b>，比如可以用来将系统内部的对象划分为不同的项目组或用户组。</p><blockquote data-pid="iH38fXLc">docker 中也提到过，我们可以建不同个 虚拟目录 然后将不同项目和不同组织项目放在一起。</blockquote><p data-pid="yDgsAjFI">常见的 <code>pods</code>, <code>services</code>, <code>replication</code> <code>controllers</code> 和 <code>deployments</code> 等都是属于某一个 Namespace 的（默认是 default），而 <code>Node</code>, <code>persistentVolumes</code>等则不属于任何 Namespace。</p><blockquote data-pid="TRVkJ53o">创建的时候不加 namespace，那么默认是：default<br> kubectl create -f nginx-deploy.yaml --namespace kube-system<br><b>相同名称的对象可以放入到不同的namespaces，同名文件可以放入不同目录。</b></blockquote><p class="ztext-empty-paragraph"><br></p><h3><b>Pod</b></h3><ul><li data-pid="qV8IfD4V">Pod 是一组紧密关联的容器集合，它们共享 PID、IPC、Network 和 UTS namespace，<b>是 Kubernetes 调度的基本单位。</b></li><li data-pid="7DMvvDhQ">Pod 的设计理念是支持多个容器在一个 Pod 中共享网络和文件系统，可以通过进程间通信和文件共享这种简单高效的方式组合完成服务。</li><li data-pid="1npCwHuh">同一个 Pod 中的不同容器可共享资源：<br></li><ul><li data-pid="knYFTjh6">共享网络 <code>Namespace</code>；</li><li data-pid="xZGDH3E4">可通过挂载存储卷共享存储；</li><li data-pid="8X5k8NjE">共享 Security Context。</li></ul></ul><p class="ztext-empty-paragraph"><br></p><p data-pid="C_94BlsL"><b>存储卷</b></p><p data-pid="U01dugO7">通过存储卷可以将外挂存储挂载到 Pod 内部使用。</p><p data-pid="ffgSAKD7">存储卷定义包括两个部分: Volume 和 VolumeMounts。</p><ul><li data-pid="NEtqnVA4">Volume：定义 Pod 可以使用的存储卷来源；</li><li data-pid="rSfQRJFD">VolumeMounts：定义存储卷如何 Mount 到容器内部</li></ul><p class="ztext-empty-paragraph"><br></p><p data-pid="rm2PCHYT"><b>Pod 网络</b></p><p data-pid="uGHdcIGs">Pod的多个容器是共享网络 Namespace 的，这意味着：</p><ul><li data-pid="rpSArstx">同一个 Pod 中的不同容器可以彼此通过 Loopback 地址访问：<br></li><ul><li data-pid="miGKLpuM">在第一个容器中起了一个服务 <a href="http://127.0.0.1/" target="_blank">http://127.0.0.1</a> 。</li><li data-pid="rHe4t1_N">在第二个容器内，是可以通过 <code>http Get http://172.0.0.1</code>访问到该地址的。</li></ul></ul><p class="ztext-empty-paragraph"><br></p><ul><li data-pid="rlLfKpze">这种方法常用于不同容器的互相协作。</li></ul><p class="ztext-empty-paragraph"><br></p><h3><b>资源限制</b></h3><p data-pid="V5hyRPeg">Kubernetes 通过 Cgroups 提供容器资源管理的功能，可以限制每个容器的 CPU 和内存使用，比如对于刚才创建的 deployment，可以通过下面的命令限制nginx 容器最多只用 50% 的 CPU 和 128MB 的内存：</p><div class="highlight"><pre><code class="language-bash"> $ kubectl <span class="nb">set</span> resources deployment nginx-app -c<span class="o">=</span>nginx --limits<span class="o">=</span><span class="nv">cpu</span><span class="o">=</span>500m,memory<span class="o">=</span>128Mi 
 ​
 deployment <span class="s2">"nginx"</span> resource requirements updated</code></pre></div><p data-pid="a0kkPAMC">等同于在每个 Pod 中设置 resources limits。</p><p class="ztext-empty-paragraph"><br></p><h3><b>健康检查</b></h3><p data-pid="eD5Cvpu_">Kubernetes 作为一个面向应用的集群管理工具，需要确保容器在部署后确实处在正常的运行状态。</p><p data-pid="BnwrDoJF"><b>1. 探针类型：</b></p><ul><li data-pid="iBk7UVTM">LivenessProbe<br></li><ul><li data-pid="_CxyiGc-">探测应用是否处于健康状态，如果不健康则删除并重新创建容器。</li></ul></ul><p class="ztext-empty-paragraph"><br></p><ul><li data-pid="51qG12nY">ReadinessProbe<br></li><ul><li data-pid="PA-rIN_T">探测应用是否就绪并且处于正常服务状态，如果不正常则不会接收来自 Kubernetes Service 的流量。</li></ul></ul><p class="ztext-empty-paragraph"><br></p><ul><li data-pid="E5WPX0u_">StartupProbe<br></li><ul><li data-pid="h4A395yx">探测应用是否启动完成，如果在 <code>failureThreshold*periodSeconds</code> 周期内未就绪，则会应用进程会被重启。</li></ul></ul><p class="ztext-empty-paragraph"><br></p><p data-pid="KEHDrNjR"><b>2. 探活方式：</b></p><ul><li data-pid="fzD4jqW3">Exec</li><li data-pid="bHDHXzpb">TCP socket</li><li data-pid="1qgKmKqK">HTTP</li></ul><p class="ztext-empty-paragraph"><br></p><h3><b>ConfigMap</b></h3><ul><li data-pid="bJwOKqfc">ConfigMap 用来将非机密性的数据保存到键值对中。</li><li data-pid="UWnV_GPq">使用时， Pods 可以将其用作环境变量、命令行参数或者存储卷中的配置文件。</li><li data-pid="VyEnZ-DK">ConfigMap 将环境配置信息和 容器镜像解耦，便于应用配置的修改。</li></ul><p class="ztext-empty-paragraph"><br></p><h3><b>Secret</b></h3><ul><li data-pid="Gz8bB474">Secret 是用来保存和传递密码、密钥、认证凭证这些敏感信息的对象。</li><li data-pid="J8Ep0jvv">使用 Secret 的好处是可以避免把敏感信息明文写在配置文件里。</li><li data-pid="XA7D8TWy">Kubernetes 集群中配置和使用服务不可避免的要用到各种敏感信息实现登录、认证等功能，例如访问 AWS 存储的用户名密码。</li><li data-pid="SxC7I8Q1">为了避免将类似的敏感信息明文写在所有需要使用的配置文件中，可以将这些信息存入一个 Secret 对象，而在配置文件中通过 Secret 对象引用这些敏感信息。</li><li data-pid="SUcX0U5u">这种方式的好处包括：意图明确，避免重复，减少暴漏机会。</li></ul><p class="ztext-empty-paragraph"><br></p><h3><b>用户（User Account）&amp; 服务帐户（Service Account）</b></h3><p data-pid="S4vJ9hNE">顾名思义，用户帐户为人提供账户标识，而服务账户为计算机进程和 Kubernetes 集群中运行的 Pod 提供账户标识。</p><p data-pid="xGIS4hut"><b>用户帐户和服务帐户的一个区别是作用范围</b>：</p><ul><li data-pid="qJkc9yBs"><b>用户帐户对应的是人的身份，人的身份与服务的 Namespace 无关，所以用户账户是跨 Namespace 的；</b></li><li data-pid="RwDGXp8k">而服务帐户对应的是一个运行中程序的身份，与特定 Namespace 是相关的。</li></ul><p class="ztext-empty-paragraph"><br></p><h3><b>Service</b></h3><p data-pid="Ps052I7I">Service 是应用服务的抽象，通过 labels 为应用提供负载均衡和服务发现。匹 配 labels 的 Pod IP 和端口列表组成 endpoints，由 Kube-proxy 负责将服务IP 负载均衡到这些 endpoints 上。</p><p data-pid="l_8cYy9C">每个 Service 都会自动分配一个 cluster IP（仅在集群内部可访问的虚拟地址） 和 DNS 名，其他容器可以通过该地址或 DNS 来访问服务，而不需要了解后端容器的运行。</p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic2.zhimg.com/v2-6847a4145833016ea0c1a34e7645e2a9_r.jpg" data-caption="" data-size="normal" width="2044" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>Replica Set</b></h3><ul><li data-pid="zpyTck-M">Pod 只是单个应用实例的抽象，要构建高可用应用，通常需要构建多个同样的副本，提供同一个服务。</li><li data-pid="9s6MOZYy">Kubernetes 为此抽象出副本集 ReplicaSet，其允许用户定义 Pod 的副本数，每一个 Pod 都会被当作一个无状态的成员进行管理，Kubernetes 保证总是有用户期望的数量的 Pod 正常运行。</li><li data-pid="-CIymyHH">当某个副本宕机以后，控制器将会创建一个新的副本。</li><li data-pid="s10Z_22G">当因业务负载发生变更而需要调整扩缩容时，可以方便地调整副本数量。</li></ul><p class="ztext-empty-paragraph"><br></p><h3><b>Deployment</b></h3><ul><li data-pid="Ji5UOQ0T">部署表示用户对 Kubernetes 集群的一次更新操作。</li><li data-pid="r_gPd9FV">部署是一个比 RS 应用模式更广的 API 对象，可以是创建一个新的服务，更新一个新的服务，也可以是滚动升级一个服务。</li><li data-pid="xmOCoiuJ">滚动升级一个服务，实际是创建一个新的 RS，然后逐渐将新 RS 中副本数增加到理想状态，将旧 RS 中的副本数减小到 0 的复合操作。</li><li data-pid="KFGNdbCY">这样一个复合操作用一个 RS 是不太好描述的，所以用一个更通用的 Deployment 来描述。</li><li data-pid="j2OVXtV7">以 Kubernetes 的发展方向，未来对所有长期伺服型的的业务的管理，都会通过 Deployment 来管理。</li></ul><p class="ztext-empty-paragraph"><br></p><h3><b>StatefulSet（有状态服务集）</b></h3><ul><li data-pid="UK5-_1w0">对于 StatefulSet 中的 Pod，每个 Pod 挂载自己独立的存储，如果一个 Pod 出现故障，从其他节点启动一个同样名字的Pod，要挂载上原来 Pod 的存储继续以它的状态提供服务。</li><li data-pid="CkM-vULj">适合于 StatefulSet 的业务包括数据库服务 MySQL 和 PostgreSQL，集群化管理服务 ZooKeeper、etcd 等有状态服务。</li><li data-pid="HOA2xM7v">使用 StatefulSet，Pod 仍然可以通过漂移到不同节点提供高可用，而存储也可以通过外挂的存储来提供高可靠性，StatefulSet 做的只是将确定的 Pod 与确定的存储关联起来保证状态的连续性。</li></ul><blockquote data-pid="MXX7IBr9">有状态服务比较复杂~</blockquote><p class="ztext-empty-paragraph"><br></p><p data-pid="7el9_kJI"><b>Statefulset 与 Deployment 的差异</b></p><p data-pid="NzHRIj-t">身份标识</p><ul><li data-pid="sl3-MT3W">StatefulSet Controller 为每个 Pod 编号，序号从0开始。</li></ul><p data-pid="BbI0FPjC">数据存储</p><ul><li data-pid="R97kV4Nb">StatefulSet 允许用户定义 volumeClaimTemplates，Pod 被创建的同时，Kubernetes 会以volumeClaimTemplates 中定义的模板创建存储卷，并挂载给 Pod。</li></ul><p data-pid="yx1swaIm"><b>StatefulSet 的升级策略不同：</b></p><ul><li data-pid="y7_c8mg_">onDelete</li><li data-pid="8RSROfEu">滚动升级</li><li data-pid="ef5FBkb1">分片升级</li></ul><p class="ztext-empty-paragraph"><br></p><h3><b>Job</b></h3><ul><li data-pid="pu-o_mc9">Job 是 Kubernetes 用来控制批处理型任务的 API 对象。</li><li data-pid="QlV-2QO1">Job 管理的 Pod 根据用户的设置把任务成功完成后就自动退出。</li><li data-pid="Ek36ar7Y">成功完成的标志根据不同的 spec.completions 策略而不同：<br></li><ul><li data-pid="BIdVHsFH">单 Pod 型任务有一个 Pod 成功就标志完成；</li><li data-pid="Ew4ecVtt">定数成功型任务保证有 N 个任务全部成功；</li><li data-pid="YGApAfUe">工作队列型任务根据应用确认的全局成功而标志成功。</li></ul></ul><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>DaemonSet</b></h3><ul><li data-pid="O33DXJXb">长期伺服型和批处理型服务的核心在业务应用，可能有些节点运行多个同类业务的 Pod，有些节点上又没有这类 Pod 运行；</li><li data-pid="j5te2W6u">而后台支撑型服务的核心关注点在 Kubernetes 集群中的节点（物理机或虚拟机），要保证每个节点上都有一个此类 Pod 运行。</li><li data-pid="Qjr52XDo">节点可能是所有集群节点也可能是通过 nodeSelector 选定的一些特定节点。</li><li data-pid="DjAF4N2L">典型的后台支撑型服务包括存储、日志和监控等在每个节点上支撑 Kubernetes 集群运行的服务。</li></ul><p class="ztext-empty-paragraph"><br></p><h3><b>存储 PV 和 PVC</b></h3><ul><li data-pid="ezKcTzf9">PersistentVolume（PV）是集群中的一块存储卷，可以由管理员手动设置，或当用户创建 PersistentVolumeClaim（PVC）时根据 StorageClass 动态设置。</li><li data-pid="RqcUXgQO">PV 和 PVC 与 Pod 生命周期无关。也就是说，当 Pod 中的容器重新启动、Pod 重新调度或者删除时，PV 和 PVC 不会受到影响，Pod 存储于 PV 里的数据得以保留。</li><li data-pid="ihNyxjdW">对于不同的使用场景，用户通常需要不同属性（例如性能、访问模式等）的 PV。</li></ul><p class="ztext-empty-paragraph"><br></p><h3><b>CustomResourceDefinition</b></h3><ul><li data-pid="xF-1IHAO">CRD 就像数据库的开放式表结构，允许用户自定义 Schema。</li><li data-pid="Px5fR_8r">有了这种开放式设计，用户可以基于 CRD 定义一切需要的模型，满足不同业务的需求。</li><li data-pid="2M7plTdI">社区鼓励基于 CRD 的业务抽象，众多主流的扩展应用都是基于 CRD 构建的，比如 Istio、Knative。</li><li data-pid="umPlb8ac">甚至基于 CRD 推出了 Operator Mode 和 Operator SDK，可以以极低的开发成本定义新对象，并构建新对象的控制器。</li></ul><p class="ztext-empty-paragraph"><br></p><h2><b>END 链接</b>​</h2><ul><li data-pid="XsSlJ7IB"><a href="typora://app/README.md" target="_blank">Ⓜ️回到目录 </a></li><li data-pid="u4b4shVo"><b><a href="https://nsddd.top/archives/contributors" target="_blank"> 参与贡献 ❤️‍  </a></b>)</li><li data-pid="9BfxtdS7">✴️版权声明 © ：本书所有内容遵循<a href="http://zh.wikipedia.org/wiki/Wikipedia:CC-by-sa-3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank">CC-BY-SA 3.0协议（署名-相同方式共享）©</a> </li></ul><p></p></div> </details> 
 <hr /> 

 #### - [深入剖析 Docker 底层（全）](https://zhuanlan.zhihu.com/p/610939386) 
 <details><summary>توضیحات</summary> <p><img src="https://picx.zhimg.com/v2-bf90afb98f714c1a3aa29e0e04f7fd37_720w.jpg?source=d16d100b"></p><div><ul><li data-pid="8LZZyIBI"><a href="https://github.com/cubxxw" target="_blank">author</a></li></ul><h2><b>第46节 深挖容器底层技术</b></h2><blockquote data-pid="K962ub2t">❤️  新时代拥抱云原生，云原生具有环境统一、按需付费、即开即用、稳定性强特点。Myblog: <a href="http://nsddd.top/" target="_blank">https://nsddd.top</a></blockquote><h2><b>linux kernel 中 namespace 的实现</b></h2><ul><li data-pid="2LzXCWlT"><a href="https://github.com/torvalds/linux/tree/master/kernel" target="_blank">Linux kernel source code address for github</a></li></ul><p class="ztext-empty-paragraph"><br></p><h3><b>进程数据结构</b></h3><div class="highlight"><pre><code class="language-c"> <span class="k">struct</span> <span class="n">task_struct</span> <span class="p">{</span>
     <span class="p">...</span>
     <span class="o">/</span> <span class="o">*</span> <span class="n">namespaces</span> <span class="err">*/</span>
     <span class="k">struct</span> <span class="n">nsproxy</span> <span class="o">*</span><span class="n">nsproxy</span><span class="p">;</span>
     <span class="p">...</span>
 <span class="p">}</span></code></pre></div><p data-pid="gFH7Xt6Y"><b>Linux Namespce 是一种 Linux Kernel 提供的资源隔离方案：</b></p><ul><li data-pid="p3wYmD38">系统可以为不同进程分配不同的 Namespace</li><li data-pid="LpPzIYb5">系统可以保证不同的 Namespaces 资源独立分配，进程彼此隔离，即不同的 Namespace 下进程互不干扰。</li></ul><p data-pid="8chGvwlO"><b>即使是在 Kubernetes 中，任何进程运行都是需要一个 namespaces</b></p><p class="ztext-empty-paragraph"><br></p><h3><b>namespace 数据结构</b></h3><ul><li data-pid="eu61t8t9"><a href="https://github.com/torvalds/linux/blob/master/include/linux/sched.h#L737" target="_blank"><span class="invisible">https://</span><span class="visible">github.com/torvalds/lin</span><span class="invisible">ux/blob/master/include/linux/sched.h#L737</span><span class="ellipsis"></span></a></li></ul><p class="ztext-empty-paragraph"><br></p><p data-pid="DiRdG3pJ"><b>具体细节不展开，之前写过很多关于 namespces 的文章（<a href="https://docker.nsddd.top/" target="_blank">https://docker.nsddd.top</a>)</b></p><div class="highlight"><pre><code class="language-c"> <span class="cm">/*
</span><span class="cm">  * A structure to contain pointers to all per-process
</span><span class="cm">  * namespaces - fs (mount), uts, network, sysvipc, etc.
</span><span class="cm">  *
</span><span class="cm">  * The pid namespace is an exception -- it's accessed using
</span><span class="cm">  * task_active_pid_ns.  The pid namespace here is the
</span><span class="cm">  * namespace that children will use.
</span><span class="cm">  *
</span><span class="cm">  * 'count' is the number of tasks holding a reference.
</span><span class="cm">  * The count for each namespace, then, will be the number
</span><span class="cm">  * of nsproxies pointing to it, not the number of tasks.
</span><span class="cm">  *
</span><span class="cm">  * The nsproxy is shared by tasks which share all namespaces.
</span><span class="cm">  * As soon as a single namespace is cloned or unshared, the
</span><span class="cm">  * nsproxy is copied.
</span><span class="cm">  */</span>
 <span class="k">struct</span> <span class="n">nsproxy</span> <span class="p">{</span>
     <span class="n">atomic_t</span> <span class="n">count</span><span class="p">;</span>
     <span class="k">struct</span> <span class="n">uts_namespace</span> <span class="o">*</span><span class="n">uts_ns</span><span class="p">;</span>
     <span class="k">struct</span> <span class="n">ipc_namespace</span> <span class="o">*</span><span class="n">ipc_ns</span><span class="p">;</span>
     <span class="k">struct</span> <span class="n">mnt_namespace</span> <span class="o">*</span><span class="n">mnt_ns</span><span class="p">;</span>
     <span class="k">struct</span> <span class="n">pid_namespace</span> <span class="o">*</span><span class="n">pid_ns_for_children</span><span class="p">;</span>
     <span class="k">struct</span> <span class="n">net</span>       <span class="o">*</span><span class="n">net_ns</span><span class="p">;</span>
     <span class="k">struct</span> <span class="n">time_namespace</span> <span class="o">*</span><span class="n">time_ns</span><span class="p">;</span>
     <span class="k">struct</span> <span class="n">time_namespace</span> <span class="o">*</span><span class="n">time_ns_for_children</span><span class="p">;</span>
     <span class="k">struct</span> <span class="n">cgroup_namespace</span> <span class="o">*</span><span class="n">cgroup_ns</span><span class="p">;</span>
 <span class="p">};</span>
 <span class="k">extern</span> <span class="k">struct</span> <span class="n">nsproxy</span> <span class="n">init_nsproxy</span><span class="p">;</span></code></pre></div><p data-pid="N5CqZ2Bc"><b>我们会以 namespces 为例，即使是其他的，比如说 联合文件系统，我们之前写过一篇文章讲过，<a href="https://docker.nsddd.top/markdown/50.html" target="_blank">可以参考那篇文章</a></b></p><p class="ztext-empty-paragraph"><br></p><p data-pid="o2eNQhYk"><b>我在网上找到了不同 kernel 版本对应的 namespace ，作为参考</b></p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic4.zhimg.com/v2-8904e7714904b72f21c05c398a131cf7_r.jpg" data-caption="" data-size="normal" width="2001" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>查看和操控主机的  Namespace</b></h3><p data-pid="5VdW2VVE"><b>查看当前系统的 namespace：</b></p><div class="highlight"><pre><code class="language-bash"> lsns -t &lt;type&gt;</code></pre></div><ul><li data-pid="6lgG-De8"><code>-t</code>选项:只查看给定类型的Namespace</li></ul><p class="ztext-empty-paragraph"><br></p><p data-pid="xYf1DVtg"><b>查看某一个进程的 namespace：</b></p><div class="highlight"><pre><code class="language-bash"> ls -al /proc/&lt;pid&gt;/ns/</code></pre></div><p class="ztext-empty-paragraph"><br></p><p data-pid="69b3nrYQ"><b>进入某一个 namespace 运行命令：</b></p><div class="highlight"><pre><code class="language-bash"> nsenter -t &lt;pid&gt; -n ip addr</code></pre></div><ul><li data-pid="mEM9GTdh"><code>nsenter</code>:可以在指定进程的Namespace下运行指定程序的命令</li><li data-pid="ilpAlUwW"><code>-t</code>选项:指定被进入命名空间的目标进程的pid</li><li data-pid="VyknHdZ2"><code>-m</code>选项:进入mnt Namespace</li><li data-pid="pfbzrqXz"><code>-u</code>选项:进入uts Namespace</li><li data-pid="Phn5hQnp"><code>-i</code>选项:进入ipc Namespace</li><li data-pid="oBcbicbN"><code>-n</code>选项:进入net Namespace</li><li data-pid="w6WLCZ3H"><code>-p</code>选项:进入pid Namespace</li><li data-pid="lfWaiL4g"><code>-U</code>选项:进入user Namespace</li><li data-pid="VnXt5VPo"><code>-G</code>选项:设置运行程序的gid</li><li data-pid="J6U5ArP9"><code>-S</code>选项:设置运行程序的uid</li><li data-pid="PmGqpYH0"><code>-r</code>选项:设置根目录</li><li data-pid="X47y89KD"><code>-w</code>选项:设置工作目录</li></ul><p class="ztext-empty-paragraph"><br></p><p data-pid="iWU_s3LA"><a href="https://github.com/torvalds/linux/blob/master/tools/perf/util/setns.c#L7:5" target="_blank">setns</a></p><div class="highlight"><pre><code class="language-text">  int setns(int fd, int nstype)</code></pre></div><p data-pid="gf4P5E9f">该系统调用可以让调用进程加入某个已经存在的Namespace中.</p><p class="ztext-empty-paragraph"><br></p><p data-pid="NjI-GS0z"><b><code>setns</code>可以调整一个已经存在的进程,将该进程切换到另一个Namespace中.</b></p><ul><li data-pid="ZpycBNYw">unshare<br>该系统调用可以将调用进程移动到新的Namespace下:<br>  int unshare(int flags)</li></ul><p class="ztext-empty-paragraph"><br></p><h3><b>案例</b></h3><p data-pid="BcfvDDIK">查找 主进程 的 namespace：</p><div class="highlight"><pre><code class="language-bash"> ❯ lsns -t net
         NS TYPE NPROCS PID USER    NETNSID NSFS                      COMMAND
 <span class="m">4026531992</span> net     <span class="m">270</span>   <span class="m">1</span> root unassigned /run/docker/netns/default /sbin/init text
 ❯ ls -al /proc/1/ns
 total <span class="m">0</span>
 dr-x--x--x <span class="m">2</span> root root <span class="m">0</span> Mar  <span class="m">2</span> 07:47 .
 dr-xr-xr-x <span class="m">9</span> root root <span class="m">0</span> Feb <span class="m">26</span> 05:15 ..
 lrwxrwxrwx <span class="m">1</span> root root <span class="m">0</span> Mar  <span class="m">2</span> 08:06 cgroup -&gt; <span class="s1">'cgroup:[4026531835]'</span>
 lrwxrwxrwx <span class="m">1</span> root root <span class="m">0</span> Mar  <span class="m">2</span> 08:06 ipc -&gt; <span class="s1">'ipc:[4026531839]'</span>
 lrwxrwxrwx <span class="m">1</span> root root <span class="m">0</span> Mar  <span class="m">2</span> 08:06 mnt -&gt; <span class="s1">'mnt:[4026531840]'</span>
 lrwxrwxrwx <span class="m">1</span> root root <span class="m">0</span> Mar  <span class="m">2</span> 08:06 net -&gt; <span class="s1">'net:[4026531992]'</span>
 lrwxrwxrwx <span class="m">1</span> root root <span class="m">0</span> Mar  <span class="m">2</span> 07:47 pid -&gt; <span class="s1">'pid:[4026531836]'</span>
 lrwxrwxrwx <span class="m">1</span> root root <span class="m">0</span> Mar  <span class="m">2</span> 08:06 pid_for_children -&gt; <span class="s1">'pid:[4026531836]'</span>
 lrwxrwxrwx <span class="m">1</span> root root <span class="m">0</span> Mar  <span class="m">2</span> 08:06 user -&gt; <span class="s1">'user:[4026531837]'</span>
 lrwxrwxrwx <span class="m">1</span> root root <span class="m">0</span> Mar  <span class="m">2</span> 08:06 uts -&gt; <span class="s1">'uts:[4026531838]'</span></code></pre></div><p class="ztext-empty-paragraph"><br></p><p data-pid="GCeI8Fp1"><b>在我们使用 docker 的时候，我们可以用 docker run / exec 进入一个容器，当然也可以用 nsenter，不过我们用的是 PID(0） system init 主进程测试的：</b></p><blockquote data-pid="U5Lm5DYh">聪明的你应该猜到了，主进程的话，那必然也是一样的（因为我平常不用 docker 了，所以只是将 docker 作为 runtime），如下：</blockquote><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic4.zhimg.com/v2-e205c5a0163e6e9afc61787cc219a94b_r.jpg" data-caption="" data-size="normal" width="1757" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><p data-pid="wg8kROfS"><b>这和我们进入 容器 中，在输入 <code>ip addr</code> 结果是一样的，网络隔离的效果一样。</b></p><p data-pid="0wN9h7vx">我们后面 Kubernetes 调试容器也是经常用到的。</p><p class="ztext-empty-paragraph"><br></p><p data-pid="_lA8o2C0"><b>我以网络为例，其他的 namespace 也是一样的：</b></p><ul><li data-pid="7x_5xOFe"><code>ipc Namespace</code><br></li><ul><li data-pid="ebfPJ8_r">容器中进程交互还是采用Linux常见的进程间交互(interprocess communication - IPC)方法,包括常见的信号量、消息队列和共享内存</li><li data-pid="E2tnvA4c">容器的进程间交互,实际上还是宿主机上在同一个Pid namespace中的进程间交互,因此需要在IPC资源申请时加入namespace信息.每个IPC资源有一个唯一的32位ID</li></ul></ul><p data-pid="HJZbgC3I">如果需要进程间通信(比如要发送信号量、要共享内存),这种场景就需要通过IPC通信来完成.2个进程想要进行IPC通信,必须处于同一个ipc namespace中.</p><ul><li data-pid="hZNZt5Wd"><code>mnt Namespace</code><br></li><ul><li data-pid="8_G7NEdc">mnt Namespace允许不同namespace的进程看到不同的文件结构,这样每个namespace中的进程所看到的文件目录就被隔离开了</li></ul></ul><p data-pid="TZZheZdl">每个进程都有自己的文件系统.从代码的角度来看,结构体<code>task_struct</code>中有如下几个字段:<br></p><ul><ul><li data-pid="-hix_C_Y"><code>struct mm_struct *mm, *active_mm;</code></li><li data-pid="NkcmNaZl"><code>struct fs_struct *fs;</code>(文件系统信息)</li><li data-pid="7f7u0blx"><code>struct files_struct *files;</code>(打开文件信息)</li><li data-pid="_MECjpAK"><code>struct signal_struct *signal</code>(信号量信息)</li><li data-pid="xlqe_XLk"><code>struct sighand_struct *sighand;</code>(信号处理对象)</li></ul></ul><p data-pid="SMqLjITE">mnt Namespace决定了<code>task_struct</code>的实例(也就是1个进程)能够看到的文件系统.因此每个进程能够看到的文件系统也是不同的.</p><ul><li data-pid="JDBcUInp"><code>UTS Namespace</code><br></li><ul><li data-pid="WkfcRZH6">UTS(UNIX Time-sharing System) Namespace允许每个容器拥有独立的hostname和domain name,使其在网络上可以被视作一个独立的节点,而非宿主机上的一个进程.</li></ul></ul><p data-pid="ystGjBfP">UTS Namespace决定了每个进程可以有其专属的主机域名.配合net Namespace,每个进程就拥有了自己独立的主机域名和IP地址</p><ul><li data-pid="iMB_rbN0"><code>user Namespace</code><br></li><ul><li data-pid="d_sVZQ9C">每个容器可以有不同的user和group id,也就是说可以在容器内部,以容器内部用户的角色执行程序.而非以宿主机上的用户角色来执行容器内的程序.</li></ul></ul><p data-pid="OIFNMrhq">user Namespace用于让每个进程可以有自己的用户管理系统.</p><blockquote data-pid="0zAG_Mh0">⚠️ 我还是想提醒一下，或许你看过我的文章，或许你可以去 Wiki 上面看，因为 namespace 出现时间不一样，所以不能一概而论。</blockquote><p class="ztext-empty-paragraph"><br></p><h3><b>unshare</b></h3><p data-pid="uB3AAJF-">好熟悉的地方不是吗，或许你看过我<a href="https://docker.nsddd.top/Cloud-Native/27.html" target="_blank">以前的文章，里面提到过</a></p><ul><li data-pid="pWA7WulU"><code>unshare</code>: unshare 允许进程在运行时创建和隔离新的命名空间。例如，可以使用 unshare 创建一个新的 PID 命名空间，从而使一个进程在新的命名空间中运行，并且与原来的命名空间隔离。</li><li data-pid="CI71wOnY"><code>newuidmap</code>: newuidmap 工具用于在容器中控制用户 ID 映射，这是实现容器的必要步骤。在容器中，需要在主机和容器间进行用户 ID 的映射，以便使容器中的进程具有访问文件系统的权限。</li></ul><p class="ztext-empty-paragraph"><br></p><p data-pid="KY9nhAjT"><b>create a new PID:</b></p><p data-pid="ue_fjnke">也就是说这条命令的含义是:启动一个进程<code>sleep</code>,并切换该进程的net Namespace</p><div class="highlight"><pre><code class="language-bash"> ❯ unshare -fn sleep <span class="m">60</span></code></pre></div><p data-pid="Mhab6-3h"><b>test:</b></p><div class="highlight"><pre><code class="language-bash"> unshare -U bash</code></pre></div><ul><li data-pid="_W0TatbV"><code>-f</code>:切换Namespace</li><li data-pid="QffSvGLX"><code>-n</code>:指定切换net Namespace</li></ul><p class="ztext-empty-paragraph"><br></p><p data-pid="Ov6fKfVm"><b>ok，我们来测试一下这个 简单的一个案例如下：</b></p><div class="highlight"><pre><code class="language-bash"> ❯ unshare -n bash
 root@cubmaster01:/# lsns -t net
         NS TYPE NPROCS    PID USER    NETNSID NSFS                      COMMAND
 <span class="m">4026531992</span> net     <span class="m">266</span>      <span class="m">1</span> root unassigned /run/docker/netns/default /sbin/init text
 <span class="m">4026532657</span> net       <span class="m">2</span> <span class="m">948916</span> root unassigned                           bash
 root@cubmaster01:/# ls -al /proc/948916/ns
 total <span class="m">0</span>
 dr-x--x--x <span class="m">2</span> root root <span class="m">0</span> Mar  <span class="m">2</span> 08:16 .
 dr-xr-xr-x <span class="m">9</span> root root <span class="m">0</span> Mar  <span class="m">2</span> 08:16 ..
 lrwxrwxrwx <span class="m">1</span> root root <span class="m">0</span> Mar  <span class="m">2</span> 08:16 cgroup -&gt; <span class="s1">'cgroup:[4026531835]'</span>
 lrwxrwxrwx <span class="m">1</span> root root <span class="m">0</span> Mar  <span class="m">2</span> 08:16 ipc -&gt; <span class="s1">'ipc:[4026531839]'</span>
 lrwxrwxrwx <span class="m">1</span> root root <span class="m">0</span> Mar  <span class="m">2</span> 08:16 mnt -&gt; <span class="s1">'mnt:[4026531840]'</span>
 lrwxrwxrwx <span class="m">1</span> root root <span class="m">0</span> Mar  <span class="m">2</span> 08:16 net -&gt; <span class="s1">'net:[4026532657]'</span>
 lrwxrwxrwx <span class="m">1</span> root root <span class="m">0</span> Mar  <span class="m">2</span> 08:16 pid -&gt; <span class="s1">'pid:[4026531836]'</span>
 lrwxrwxrwx <span class="m">1</span> root root <span class="m">0</span> Mar  <span class="m">2</span> 08:16 pid_for_children -&gt; <span class="s1">'pid:[4026531836]'</span>
 lrwxrwxrwx <span class="m">1</span> root root <span class="m">0</span> Mar  <span class="m">2</span> 08:16 user -&gt; <span class="s1">'user:[4026531837]'</span>
 lrwxrwxrwx <span class="m">1</span> root root <span class="m">0</span> Mar  <span class="m">2</span> 08:16 uts -&gt; <span class="s1">'uts:[4026531838]'</span>
 root@cubmaster01:/# ns
 nscd      nsenter   nslookup  nstat     nsupdate  
 root@cubmaster01:/# nsenter -t <span class="m">948916</span> -n ip a
 1: lo: &lt;LOOPBACK&gt; mtu <span class="m">65536</span> qdisc noop state DOWN group default qlen <span class="m">1000</span>
     link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
 root@cubmaster01:/# ip a
 1: lo: &lt;LOOPBACK&gt; mtu <span class="m">65536</span> qdisc noop state DOWN group default qlen <span class="m">1000</span>
     link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
 ​
 root@cubmaster01:/# <span class="nb">exit</span>
 <span class="nb">exit</span>
 ​
 root@cubmaster01 / 2m 15s                                                                                         08:18:01
 ❯ </code></pre></div><blockquote data-pid="0Q5rEe0R"> ⚠️ <b>关于Kubernetes namespace 的通信问题以及 Linux namespace 通信问题，我写过一篇文章，<a href="https://docker.nsddd.top/Cloud-Native-k8s/45.html" target="_blank">请移步到这里</a></b></blockquote><p class="ztext-empty-paragraph"><br></p><h2><b>Cgroups</b></h2><ul><li data-pid="_xJmkAYz"><a href="https://docker.nsddd.top/markdown/47.html#control-groups" target="_blank">我们在这篇文章中也写过</a></li></ul><p data-pid="JePwkRyp"><b>但是我们今天进一步学习，刨析它的底层实现：</b></p><ul><li data-pid="hq1cA7Ek">Cgroups(Control Groups)是Linux下用于对一个或一组进程进行资源控制和监控的机制</li><li data-pid="Qewi2yv4">可以对诸如CPU使用时间、内存、磁盘I/O等进程所需资源进行限制</li><li data-pid="BD-lGWfF">不同资源的具体管理工作由相应的Cgroup子系统(Subsystem)来实现</li><li data-pid="Z3zL5aeM">针对不同类型的资源限制,只要将限制策略在不同的子系统上进行关联即可</li><li data-pid="UgeyJmZu">Cgroups在不同的系统资源管理子系统中,以层级树(Hierarchy)的方式来组织管理:每个Cgroup都可以包含其他的子Cgroup,因此子Cgroup能使用的资源除了受本Cgroup配置的资源参数限制外,还受到父Cgroup设置的资源限制</li></ul><p data-pid="r4uGUHJU">Cgroups用于对Linux中的进程做统一的监控和资源管理.</p><p data-pid="ol9cSXAI">Cgroups也分为不同的子系统,不同的子系统会控制不同的资源.一个进程所需的资源大约可以分为:CPU、内存、Disk I/O.这些资源都可以被Cgroups管理起来.这些资源在Cgroups中被称为Subsystem.</p><p data-pid="CLErBS8z">进程是一个树状结构.Cgroups也采用了类似的结构,叫做Hierarchy.</p><p class="ztext-empty-paragraph"><br></p><h3><b>进程数据结构</b></h3><ul><li data-pid="vRJnYPJ1"><a href="https://github.com/torvalds/linux/blob/master/include/linux/sched.h#L1208" target="_blank">进程数据结构</a></li></ul><div class="highlight"><pre><code class="language-c"> <span class="k">struct</span> <span class="n">task_struct</span> <span class="p">{</span>
     <span class="p">...</span>
 <span class="cp">#ifdef CONFIG_CGROUPS
</span><span class="cp"></span>     <span class="cm">/* Control Group info protected by css_set_lock: */</span>
     <span class="k">struct</span> <span class="n">css_set</span> <span class="n">__rcu</span>        <span class="o">*</span><span class="n">cgroups</span><span class="p">;</span>
     <span class="cm">/* cg_list protected by css_set_lock and tsk-&gt;alloc_lock: */</span>
     <span class="k">struct</span> <span class="n">list_head</span>        <span class="n">cg_list</span><span class="p">;</span>
 <span class="cp">#endif
</span><span class="cp"></span>     <span class="p">...</span>
 <span class="p">}</span></code></pre></div><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>css_set 数据结构</b></h3><ul><li data-pid="wnb95sYX"><a href="https://github.com/torvalds/linux/blob/master/include/linux/cgroup-defs.h#L212" target="_blank"><span class="invisible">https://</span><span class="visible">github.com/torvalds/lin</span><span class="invisible">ux/blob/master/include/linux/cgroup-defs.h#L212</span><span class="ellipsis"></span></a></li></ul><p data-pid="uS7O8Iwe"><b>css_set 是 cgroup_subsys_state 对象的集合数据结构</b></p><div class="highlight"><pre><code class="language-c"> <span class="cm">/*
</span><span class="cm">  * A css_set is a structure holding pointers to a set of
</span><span class="cm">  * cgroup_subsys_state objects. This saves space in the task struct
</span><span class="cm">  * object and speeds up fork()/exit(), since a single inc/dec and a
</span><span class="cm">  * list_add()/del() can bump the reference count on the entire cgroup
</span><span class="cm">  * set for a task.
</span><span class="cm">  */</span>
 <span class="k">struct</span> <span class="n">css_set</span> <span class="p">{</span>
     <span class="cm">/*
</span><span class="cm">      * Set of subsystem states, one for each subsystem. This array is
</span><span class="cm">      * immutable after creation apart from the init_css_set during
</span><span class="cm">      * subsystem registration (at boot time).
</span><span class="cm">      */</span>
     <span class="k">struct</span> <span class="n">cgroup_subsys_state</span> <span class="o">*</span><span class="n">subsys</span><span class="p">[</span><span class="n">CGROUP_SUBSYS_COUNT</span><span class="p">];</span>
 <span class="err">​</span>
     <span class="cm">/* reference count */</span>
     <span class="n">refcount_t</span> <span class="n">refcount</span><span class="p">;</span>
 <span class="err">​</span>
     <span class="cm">/*
</span><span class="cm">      * For a domain cgroup, the following points to self.  If threaded,
</span><span class="cm">      * to the matching cset of the nearest domain ancestor.  The
</span><span class="cm">      * dom_cset provides access to the domain cgroup and its csses to
</span><span class="cm">      * which domain level resource consumptions should be charged.
</span><span class="cm">      */</span>
     <span class="k">struct</span> <span class="n">css_set</span> <span class="o">*</span><span class="n">dom_cset</span><span class="p">;</span>
 <span class="err">​</span>
     <span class="cm">/* the default cgroup associated with this css_set */</span>
     <span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">dfl_cgrp</span><span class="p">;</span>
 <span class="err">​</span>
     <span class="cm">/* internal task count, protected by css_set_lock */</span>
     <span class="kt">int</span> <span class="n">nr_tasks</span><span class="p">;</span>
 <span class="err">​</span>
     <span class="cm">/*
</span><span class="cm">      * Lists running through all tasks using this cgroup group.
</span><span class="cm">      * mg_tasks lists tasks which belong to this cset but are in the
</span><span class="cm">      * process of being migrated out or in.  Protected by
</span><span class="cm">      * css_set_rwsem, but, during migration, once tasks are moved to
</span><span class="cm">      * mg_tasks, it can be read safely while holding cgroup_mutex.
</span><span class="cm">      */</span>
     <span class="k">struct</span> <span class="n">list_head</span> <span class="n">tasks</span><span class="p">;</span>
     <span class="k">struct</span> <span class="n">list_head</span> <span class="n">mg_tasks</span><span class="p">;</span>
     <span class="k">struct</span> <span class="n">list_head</span> <span class="n">dying_tasks</span><span class="p">;</span>
 <span class="err">​</span>
     <span class="cm">/* all css_task_iters currently walking this cset */</span>
     <span class="k">struct</span> <span class="n">list_head</span> <span class="n">task_iters</span><span class="p">;</span>
 <span class="err">​</span>
     <span class="cm">/*
</span><span class="cm">      * On the default hierarchy, -&gt;subsys[ssid] may point to a css
</span><span class="cm">      * attached to an ancestor instead of the cgroup this css_set is
</span><span class="cm">      * associated with.  The following node is anchored at
</span><span class="cm">      * -&gt;subsys[ssid]-&gt;cgroup-&gt;e_csets[ssid] and provides a way to
</span><span class="cm">      * iterate through all css's attached to a given cgroup.
</span><span class="cm">      */</span>
     <span class="k">struct</span> <span class="n">list_head</span> <span class="n">e_cset_node</span><span class="p">[</span><span class="n">CGROUP_SUBSYS_COUNT</span><span class="p">];</span>
 <span class="err">​</span>
     <span class="cm">/* all threaded csets whose -&gt;dom_cset points to this cset */</span>
     <span class="k">struct</span> <span class="n">list_head</span> <span class="n">threaded_csets</span><span class="p">;</span>
     <span class="k">struct</span> <span class="n">list_head</span> <span class="n">threaded_csets_node</span><span class="p">;</span>
 <span class="err">​</span>
     <span class="cm">/*
</span><span class="cm">      * List running through all cgroup groups in the same hash
</span><span class="cm">      * slot. Protected by css_set_lock
</span><span class="cm">      */</span>
     <span class="k">struct</span> <span class="n">hlist_node</span> <span class="n">hlist</span><span class="p">;</span>
 <span class="err">​</span>
     <span class="cm">/*
</span><span class="cm">      * List of cgrp_cset_links pointing at cgroups referenced from this
</span><span class="cm">      * css_set.  Protected by css_set_lock.
</span><span class="cm">      */</span>
     <span class="k">struct</span> <span class="n">list_head</span> <span class="n">cgrp_links</span><span class="p">;</span>
 <span class="err">​</span>
     <span class="cm">/*
</span><span class="cm">      * List of csets participating in the on-going migration either as
</span><span class="cm">      * source or destination.  Protected by cgroup_mutex.
</span><span class="cm">      */</span>
     <span class="k">struct</span> <span class="n">list_head</span> <span class="n">mg_src_preload_node</span><span class="p">;</span>
     <span class="k">struct</span> <span class="n">list_head</span> <span class="n">mg_dst_preload_node</span><span class="p">;</span>
     <span class="k">struct</span> <span class="n">list_head</span> <span class="n">mg_node</span><span class="p">;</span>
 <span class="err">​</span>
     <span class="cm">/*
</span><span class="cm">      * If this cset is acting as the source of migration the following
</span><span class="cm">      * two fields are set.  mg_src_cgrp and mg_dst_cgrp are
</span><span class="cm">      * respectively the source and destination cgroups of the on-going
</span><span class="cm">      * migration.  mg_dst_cset is the destination cset the target tasks
</span><span class="cm">      * on this cset should be migrated to.  Protected by cgroup_mutex.
</span><span class="cm">      */</span>
     <span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">mg_src_cgrp</span><span class="p">;</span>
     <span class="k">struct</span> <span class="n">cgroup</span> <span class="o">*</span><span class="n">mg_dst_cgrp</span><span class="p">;</span>
     <span class="k">struct</span> <span class="n">css_set</span> <span class="o">*</span><span class="n">mg_dst_cset</span><span class="p">;</span>
 <span class="err">​</span>
     <span class="cm">/* dead and being drained, ignore for migration */</span>
     <span class="kt">bool</span> <span class="n">dead</span><span class="p">;</span>
 <span class="err">​</span>
     <span class="cm">/* For RCU-protected deletion */</span>
     <span class="k">struct</span> <span class="n">rcu_head</span> <span class="n">rcu_head</span><span class="p">;</span>
 <span class="p">};</span></code></pre></div><p data-pid="HHKYvb1W">Tip：</p><blockquote data-pid="9mW38h1S">cgroup 主要隔离的是 CPU 资源，我们知道即使是在 Kubernetes 中，参考 《深入剖析kubernetes》 这本书的 L 314 <br>Kubernetes 对 CPU 和 内存资源限额的设计，也是参考了 Borg 动态资源定义 调度的。使用 requests + limits 做法。</blockquote><p class="ztext-empty-paragraph"><br></p><h3><b>cgroups实现了对资源的配额和度量</b></h3><ul><li data-pid="qCv_uILB">blkio:该子系统用于限制每个块设备的输入输出控制.如:磁盘、光盘以及USB等</li><li data-pid="e8lG5Oka">cpu:该子系统通过调度程序为cgroup任务提供CPU访问</li><li data-pid="pu9KI8sE">cpuacct:产生cgroup任务的CPU资源报告</li><li data-pid="kxdyS282">cpuset:如果是多核心的CPU,该子系统为cgroup任务分配单独的CPU和内存</li><li data-pid="7Tga7ywP">divices:允许或拒绝cgroup任务对设备的访问</li><li data-pid="fuAgSlqp">freezer:暂停和恢复cgroup任务</li><li data-pid="N1f4NndO">memory:设置每个cgroup的内存限制以及产生内存资源报告</li><li data-pid="lquoN4El">net_cls:标记每个网络包以供cgroup方便使用</li><li data-pid="SPXX7I9G">ns:命名空间子系统</li><li data-pid="qqdTgYQj">pid:进程标识子系统</li></ul><p data-pid="ERXadWgY">blkio:即block IO.该子系统用于控制读写磁盘的速度</p><p data-pid="CmDzffae">cpu:设置为该进程分配多少CPU的时间片</p><p data-pid="7IJllWk8">cpuacct:用于汇报CPU的状态</p><p data-pid="XvaIjaza">cpuset:用于在多CPU场景下,将某个进程绑定在某个CPU核心上.其目的是为了高效.1个进程的生命周期就和1个CPU核心绑定,对于CPU核心来讲不需要做进程切换,提高效率(比如CPU本地的cache,TLB表等都是可以复用的,减少进程切换的开销).</p><p data-pid="cXDxRbTU">memory:控制一个进程可使用的内存大小</p><blockquote data-pid="ty0y_OAE"><a href="https://github.com/rayallen20/cloudNativeExercise/blob/master/note/module3-Docker%20core%20technology/class3-Docker%E7%9A%84%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF(%E4%B8%80)/class3-Docker%E7%9A%84%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF(%E4%B8%80).md#L583" target="_blank">更多详细的参考这篇文章~</a></blockquote><p class="ztext-empty-paragraph"><br></p><h3><b>CPU 子系统</b></h3><ul><li data-pid="RMxXhgJZ"><code>cpu.shares</code>:可出让的能获得CPU使用时间的相对值</li><li data-pid="pDCqVKeL"><code>cpu.cfs_period_us</code>:<code>cfs_period_us</code>用于配置时间周期长度,单位为μs(微秒)</li><li data-pid="83cbsrNC"><code>cpu.cfs_quota_us</code>:<code>cfs_quota_us</code>用于配置当前Cgroup在<code>cfs_period_us</code>时间内最多能使用的CPU时间数,单位为μs(微秒)</li><li data-pid="VWa--vof"><code>cpu.stat</code>:Cgroup内的进程使用的CPU时间统计</li><li data-pid="8td7vHrl"><code>nr_periods</code>:经过<code>cpu.cfs_period_us</code>的时间周期数量</li><li data-pid="JTVUQv_B"><code>nr_throttled</code>:在经过的周期内,有多少次因为进程在指定的时间周期内用光了配额时间而受到限制</li><li data-pid="7-bSHvzm"><code>throttled_time</code>:Cgroup中的进程被限制使用CPU的总用时,单位为ns(纳秒)</li></ul><p data-pid="fYKllH1w">CPU子系统用于控制1个进程能占用多少CPU.通过2种手段控制:</p><ol><li data-pid="e2SB88M_"><code>cpu.shares</code>:相对时间</li><li data-pid="LFAENS_1"><code>cpu.cfs_period_us</code>:绝对时间</li></ol><p data-pid="9h0Cf6Nw">用于控制进程占用CPU的文件:</p><div class="highlight"><pre><code class="language-bash"> ❯  tree -L <span class="m">1</span> /sys/fs/cgroup/cpu
 /sys/fs/cgroup/cpu
 ├── cgroup.clone_children
 ├── cgroup.procs
 ├── cgroup.sane_behavior
 ├── cpuacct.stat
 ├── cpuacct.usage
 ├── cpuacct.usage_all
 ├── cpuacct.usage_percpu
 ├── cpuacct.usage_percpu_sys
 ├── cpuacct.usage_percpu_user
 ├── cpuacct.usage_sys
 ├── cpuacct.usage_user
 ├── cpu.cfs_period_us
 ├── cpu.cfs_quota_us
 ├── cpudemo
 ├── cpu.shares
 ├── cpu.stat
 ├── init.scope
 ├── kubepods.slice
 ├── notify_on_release
 ├── release_agent
 ├── system.slice
 ├── tasks
 └── user.slice
 ​
 <span class="m">5</span> directories, <span class="m">18</span> files</code></pre></div><p class="ztext-empty-paragraph"><br></p><h3><b><code>cpu.shares</code></b></h3><p data-pid="aWtc-7Fr"><b>shares顾名思义就是占比,是一个相对值</b>。</p><p data-pid="jLdZLHjs">设现有3个CPU，2个CGroup(我们将它命名为Cgroup1和Cgroup2)，2个进程(我们将它命名为进程A和进程B).</p><p data-pid="o3_Du5IB">将进程A放在CGroup1中，将进程B放在CGroup2中，此时进程和CGroup就产生关联关系了.</p><p data-pid="KP-b-g4f">将CGroup1的<code>cpu.shares</code>设置为512,将CGroup2的<code>cpu.shares</code>设置为<code>1024.512:1024=1:2.</code>这表示OS在调用这2个进程时,会按照1:2的比例分配CPU时间片.因此说shares是一个相对值.</p><p class="ztext-empty-paragraph"><br></p><h3><b><code>cpu.cfs_periods_us</code></b></h3><p data-pid="BS1upfue">这种方式是控制进程对CPU占用的绝对时间.需要2个文件来控制.</p><ol><li data-pid="WigFHzJq"><code>cpu.cfs_periods_us</code>:配置时间周期的长度.</li><li data-pid="mKTS3KC_"><code>cpu.cfs_quota_us</code>:配置在<code>cpu.cfs_periods_us</code>所定义的时间长度内,进程最多可以占用CPU的时长.</li></ol><p class="ztext-empty-paragraph"><br></p><h3><b>二者区别</b></h3><p data-pid="WjfNPvvS"><code>cpu.shares</code>定义的是一个相对值.如果在多个进程竞争CPU资源的场景下,按照其定义的百分比划分CPU占用时长.如果没有竞争,则该进程可以一直占用CPU.</p><p data-pid="9yhbweK6"><code>cpu.cfs_periods_us</code>是绝对时间.无论是否存在其他进程与该进程竞争CPU资源,按照上文举的例子来讲,每100000μs中,该进程都只能占用40000μs的CPU.</p><p class="ztext-empty-paragraph"><br></p><h3><b>Linux 调度器</b></h3><p data-pid="dZUgh9xQ">内核默认提供了 5 个调度器，Linux 内核使用 <code>struct sched_class</code> 来对调度器进行抽象，关于 Linux 内核调度器的研究，我也曾经 <a href="https://github.com/cubxxw/awesome-cs-course/blob/master/excerpt/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3Linux%20Kernel%E8%B0%83%E5%BA%A6%E5%99%A8%E7%9A%84%E8%BA%AB%E4%B8%96%E4%B9%8B%E8%B0%9C%20-%20%E6%96%87%E7%AB%A0%E8%AF%A6%E6%83%85.md" target="_blank">摘抄过一篇文章</a></p><ul><li data-pid="fJf-dJRG">Stop调度器,<code>stop_sched_class</code>:优先级最高的调度类,可以抢占其他所有进程,不能被其他进程抢占</li><li data-pid="Zrguz_Yt">Deadline调度器,<code>dl_sched_class</code>:使用红黑树,把进程按照绝对截止期限进行排序,选择最小进程进行调度运行</li><li data-pid="N5ObDh2b">RT调度器,<code>rt_sched_class</code>:实时调度器,为每个优先级维护一个队列</li><li data-pid="VhpUTcMp">CFS调度器,<code>cfs_sched_class</code>:完全公平调度器,采用完全公平调度算法,引入虚拟运行时间的概念</li><li data-pid="Ci7vDCOa">IDLE-Task调度器,<code>idle_sched_class</code>:空闲调度器,每个CPU都会有1个idle线程,当没有其他进程可以调度时,调度运行idle线程</li></ul><p data-pid="3PnFXdo4">Linux中提供多个调度器.最高优先级的是RT(Real Time)调度器.这个调度器是轮询的.假设有多个进程使用RT调度器来调度,那么RT调度器将使用轮询的策略来调度这些进程.这样是为了保证时效性</p><p data-pid="pjAIArRC">优先级上其次是CFS(Completely Fair Scheduler,完全公平调度器)调度器.通常普通用户进程都是使用CFS调度器来调度的.CFS引入了一个vruntime(虚拟运行时间)的概念,是平时遇到的最多的调度器</p><p data-pid="Jkq6qn6t">其中，CFS 调度器， 对应 <code>cfs_sched_class</code> : 完全公平调度器，采用完全公平调度算法，<b>引入虚拟运行时间概念（vruntime)</b></p><p data-pid="TmZwHNWs"><b>CFS 调度没有将进程维护在运行</b></p><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>CFS调度器原理</b></h3><ul><li data-pid="hBhi0VP9">CFS是Completely Fair Scheduler的简写,即完全公平调度器</li><li data-pid="EAMj3YFw">CFS实现的主要思想是维护为任务提供处理器时间方面的平衡,这意味着应该给进程分配相当数量的处理器</li><li data-pid="9TBJCthm">分给某个任务的时间失去平衡时,应该给失去平衡的任务分配时间,以便让该任务执行</li><li data-pid="hwKmKMnG">CFS通过vruntime(虚拟运行时间)来实现平衡,维护提供给某个任务的时间量<br></li><ul><li data-pid="D7mbQrNt">vruntime = 实际运行时间 * 1024 / 进程权重</li></ul></ul><p class="ztext-empty-paragraph"><br></p><ul><li data-pid="RWui9i8s">进程按照各自不同的速率在物理时钟节拍内前进,优先级高则权重大,其虚拟时钟比真实时钟跑得慢,但获得比较多的运行时间</li></ul><p data-pid="Gja7Aaza">也就是说,一个进程的权重越大,那么该进程的虚拟时钟(vruntime)跑的越慢,就能够获得越长的运行时间.</p><p class="ztext-empty-paragraph"><br></p><h3><b>runtime红黑树</b></h3><p data-pid="Lo0w6oqB">CFS调度器并没有将进程维护在运行队列中,而是维护了一个以虚拟运行时间为顺序的红黑树.红黑树的主要持有点有:</p><ol><li data-pid="yOHEMO2h">自平衡,树上没有任何一条路径,会比其他路径长出2倍</li><li data-pid="wCs-vtBT">O(log n)时间复杂度,能够在树上进行快读高效地插入或删除操作</li></ol><p class="ztext-empty-paragraph"><br></p><h3><b>CFS进程调度</b></h3><ul><li data-pid="cFNDHpby">在时钟周期开始时,调度器用<code>__schedule()</code>函数来开始调度的运行</li><li data-pid="LVrQNWfT"><code>__schedule()</code>函数调用<code>pick_next_task()</code>让进程调度器从就绪队列中选择一个最合适的进程<code>next</code>,即红黑树最左边的节点(也就是vruntime最小的进程)</li><li data-pid="GcMtQ6Vc">通过<code>context_switch()</code>切换到新的地址空间,从而保证让<code>next</code>进程运行</li><li data-pid="JPbDQkyr">在时钟周期结束时,调度器调用<br> entity_tick()<br>函数来更新进程负载、进程状态以及vruntime(当前vruntime + 该时钟周期内运行的时间)<br></li><ul><li data-pid="x2e-Wniq">在这个时钟周期内,有的进程运行了,而有的进程没有运行.那此时需要更新vruntime,然后根据更新后的vruntime做一个顺序上的调整(也就是红黑树通过插入和反转等操作进行重新排序),调整后会把一个更紧迫的进程放在红黑树的最左侧.</li><li data-pid="e_k-PVRs">进程优先级越高的进程,按照公式<code>vruntime = 实际运行时间 * 1024 / 进程权重</code>,其vruntime值越小.vruntime值越小说明该进程越紧迫,即该进程可以占用更多的时间.这样vruntime和<code>cpu.shares</code>就产生了一个关联关系:<code>cpu.shares</code>占比越大的进程,能占有CPU的时间就越长</li></ul></ul><p class="ztext-empty-paragraph"><br></p><ul><li data-pid="rjh8e6og">最后将该进程的虚拟时间与就绪队列红黑树最左边的调度实体的虚拟时间作比较,如果小于最左边的时间,则不用触发调度,继续调度当前调度实体</li></ul><p data-pid="v_l4slbS">……</p><blockquote data-pid="ESBYmeYt">更多的，我们可以深挖 Kubernetes 调度器，以及 Linux 调度器问题，我们介绍表面层。<br></blockquote><ul><li data-pid="rZvUTBZs">关于 深挖 Linux  CPU 调度器，我<a href="https://github.com/cubxxw/awesome-cs-course/blob/master/excerpt/%E4%B8%87%E5%AD%97%E9%95%BF%E6%96%87%EF%BC%8C%E9%94%A4%E5%AE%83%EF%BC%81%E6%8F%AD%E7%A7%98Linux%E8%BF%9B%E7%A8%8B%E8%B0%83%E5%BA%A6%E5%99%A8-51CTO.COM.md" target="_blank">也摘抄过一篇文章</a></li></ul><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>案例</b></h3><p data-pid="f6jMqNXo">在<code>/sys/fs/cgroup/cpu</code>下,创建目录<code>cpudemo</code>并进入：</p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic2.zhimg.com/v2-0916aa6b8d168e66ecc99a0776c68255_r.jpg" data-caption="" data-size="normal" width="1969" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><blockquote data-pid="2wPN03x6">惊讶的发现：可以看到控制文件被自动创建出来了</blockquote><p class="ztext-empty-paragraph"><br></p><p data-pid="jtHuL92Y">我们继续：创建一个<code>go</code>文件,在该<code>go</code>文件中,启动2个死循环,1个死循环跑在主线程上,另一个跑在子线程上</p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic3.zhimg.com/v2-d2474d1e868e333fae1109a11f3c10d6_r.jpg" data-caption="" data-size="normal" width="1557" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><p data-pid="3cWqKFiC">继续：编译并运行该程序.运行的同时再起一个连接执行<code>top</code>命令</p><div class="highlight"><pre><code class="language-go"> <span class="err">❯</span> <span class="k">go</span> <span class="nx">build</span> <span class="nx">busyloop</span><span class="p">.</span><span class="k">go</span>
 <span class="err">❯</span> <span class="p">.</span><span class="o">/</span><span class="nx">busyloop</span>
</code></pre></div><blockquote data-pid="l_7mMe8D">可以 用 top 看到我们的资源都被占用了<br></blockquote><figure data-size="normal"><img src="https://pic1.zhimg.com/v2-9988e98a852558402bdf1f8441400a18_r.jpg" data-caption="" data-size="normal" width="1697" referrerpolicy="no-referrer"></figure><p data-pid="UKDmfo0e"><br>可以看到<code>busyloop</code>进程吃满了2个CPU，记住PID为<code>978527</code><br> </p><p data-pid="Rar1eo9a">继续：将该进程加入到CGroups的管理中</p><div class="highlight"><pre><code class="language-bash"> ❯ <span class="nb">cd</span> /sys/fs/cgroup/cpu/cpudemo/<span class="p">;</span> 
 <span class="nb">echo</span> <span class="m">978527</span> &gt; cgroup.procs<span class="p">;</span>ls<span class="p">;</span>
 cat cgroup.procs</code></pre></div><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic4.zhimg.com/v2-4ffd75c1ef174a027f6caabd5ab2f713_r.jpg" data-caption="" data-size="normal" width="1801" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p data-pid="B_dByUZ3">此时还没改,只是纳入管理.所以<code>top</code>查看还是200%</p><p data-pid="wvTG39Hr">继续: 查看<code>cpu.shares</code>和<code>cpu.cfs_period_us</code> <code>cpu.cfs_quota_us</code>：</p><div class="highlight"><pre><code class="language-bash"> ❯ cat cpu.shares<span class="p">;</span>cat cpu.cfs_period_us <span class="p">;</span>cat cpu.cfs_quota_us
 <span class="m">1024</span>
 <span class="m">100000</span>
 -1</code></pre></div><p data-pid="uUu2PIgF">此处<code>-1</code>表示不限制，我们需要改它阿：</p><p data-pid="ivjrO7mc">通过修改绝对时间,控制该进程对CPU的占用时长</p><div class="highlight"><pre><code class="language-bash"> ❯ <span class="nb">echo</span> <span class="m">100000</span> &gt; cpu.cfs_quota_us <span class="o">&amp;&amp;</span> cat cpu.cfs_quota_us
 <span class="m">100000</span></code></pre></div><p data-pid="n7Hxd6Gz">此时<code>quota</code>值和<code>period</code>值是相同的.说明只能给该进程1个CPU.</p><p class="ztext-empty-paragraph"><br></p><p data-pid="_RJza5A-">最后：我们可以执行<code>top</code>命令查看：</p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic2.zhimg.com/v2-b0ceb3e7227bf814f7d43fc9792d3d79_r.jpg" data-caption="" data-size="normal" width="1745" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><blockquote data-pid="lIPyvdxY">可以看到该进程现在只能占用1个CPU了.</blockquote><p class="ztext-empty-paragraph"><br></p><p data-pid="VE6Smt3V">补充：将<code>quota</code>限制为50000,再<code>top</code>查看</p><div class="highlight"><pre><code class="language-bash"> ❯ <span class="nb">echo</span> <span class="m">50000</span> &gt; cpu.cfs_quota_us <span class="p">;</span>cat cpu.cfs_quota_us
 <span class="m">50000</span></code></pre></div><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic1.zhimg.com/v2-4e1dd705d76d724f4e376530ada0e8cc_r.jpg" data-caption="" data-size="normal" width="1619" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><blockquote data-pid="vGcTgUgp">则此时只能占用1个CPU的50%了.</blockquote><p class="ztext-empty-paragraph"><br></p><h3><b>cpuacct子系统</b></h3><p data-pid="1FCHJpH-">用于统计Cgroup及其子Cgroup下进程的CPU使用情况</p><ul><li data-pid="fbmaFati"><code>cpuacct.usage</code><br></li><ul><li data-pid="N0zsbIcx">包含该Cgroup及其子Cgroup下进程使用CPU时间,单位是ns(纳秒)</li></ul></ul><p class="ztext-empty-paragraph"><br></p><ul><li data-pid="tH4kcoms"><code>cpuacct.stat</code><br></li><ul><li data-pid="XWvXlIBJ">包含该Cgroup及其子Cgroup下进程使用CPU时间,以及用户态和内核态的时间</li></ul></ul><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b> Memory子系统</b></h3><ul><li data-pid="bY487v6g"><code>memory.usage_in_bytes</code><br></li><ul><li data-pid="gaDwJki4">cgoup下进程使用的内存,包含cgroup及其子cgroup下的进程使用的内存</li></ul></ul><p class="ztext-empty-paragraph"><br></p><ul><li data-pid="8Cl5ql1k"><code>memory.max_usage_in_bytes</code><br></li><ul><li data-pid="aSi6pOSm">cgroup下进程使用内存的最大值,包含子cgroup的内存使用量</li></ul></ul><p class="ztext-empty-paragraph"><br></p><ul><li data-pid="rrbRVYtP"><code>memory.limit_in_bytes</code><br></li><ul><li data-pid="CCbKasfJ">设置cgroup下进程最多能使用的内存.如果设置为-1,表示对该cgroup的内存使用不做限制</li></ul></ul><p class="ztext-empty-paragraph"><br></p><ul><li data-pid="6VIVnMqb"><code>memory.oom_control</code><br></li><ul><li data-pid="wxeeZ-fP">设置是否在cgroup中使用OOM(Out of Memory) Killer,默认为使用.当属于该cgroup的进程使用的内存超过最大限定值(<code>memory.max_usage_in_bytes</code>)时,会立刻被OOM Killer处理</li></ul></ul><p class="ztext-empty-paragraph"><br></p><p data-pid="uC_ACsU7"><code>memory.limit_in_bytes</code>:相当于控制进程可以用多少内存开销的限制.<code>-1</code>表示不限制</p><p data-pid="sf9i_14Q">可压缩资源:比如CPU.压制一个进程可使用的CPU资源,不会导致该进程的死亡,只是会让这个进程运行速度变慢.</p><p data-pid="f7W649ov">但内存不属于可压缩资源.因为内存一旦被限制,就不能再申请新的内存了.此时OS就会kill掉这个进程.</p><p class="ztext-empty-paragraph"><br></p><h3><b>Cgroup dirver</b></h3><ul><li data-pid="DM8wgIZS">当OS使用systemd作为init system时,初始化进程生成一个根cgroup目录结构并作为cgroup管理器</li><li data-pid="yzerqZGZ">systemd与cgroup紧密结合,并且为每个systemd unit分配cgroup</li><li data-pid="4JcHOHFd">cgroupfs<br></li><ul><li data-pid="xnY7FnXp">docker默认用cgroupfs作为cgroup驱动</li></ul></ul><p class="ztext-empty-paragraph"><br></p><p data-pid="Gsg2kceF"><b>存在问题:</b></p><ul><li data-pid="kBMc_Y6c">因此,在systemd作为init system的系统中,默认并存着2套groupdriver</li><li data-pid="rNlScBcl">这会使得系统中docker和kubelet管理的进程被cgroupfs管理;而systemd拉起的服务由systemd驱动管理.让cgroup管理混乱且容易在资源紧张时引发问题</li><li data-pid="TzfOxNu2"><b>因此kubelet会默认<code>--cgroup-dirver=systemd</code>,若运行时cgroup不一致,kubelet会报错</b></li></ul><p class="ztext-empty-paragraph"><br></p><h2><b>Memory子系统案例</b></h2><p data-pid="2CXlMaKw">现有一个GO程序如下:</p><div class="highlight"><pre><code class="language-bash"> ❯ <span class="nb">cd</span> /tmp<span class="p">;</span> mkdir memory<span class="p">;</span><span class="nb">cd</span> memory<span class="p">;</span>touch malloc.go malloc.c Makefile<span class="p">;</span>ls
 Makefile  malloc.c  malloc.go
 ​
 ❯ go mod init memory<span class="p">;</span>tree
 go: creating new go.mod: module memory
 go: to add module requirements and sums:
         go mod tidy
 .
 ├── go.mod
 ├── Makefile
 ├── malloc.c
 └── malloc.go
 ​
 <span class="m">0</span> directories, <span class="m">4</span> files</code></pre></div><p data-pid="duU0cc-H"><b>文件内容如下：</b></p><div class="highlight"><pre><code class="language-bash"> ❯ cat Makefile malloc.c malloc.go</code></pre></div><p data-pid="GR8yvgNv"><b>Makefile:</b></p><div class="highlight"><pre><code class="language-text"> ❯ cat Makefile
 build:
         CGO_ENABLED=1 GOOS=linux CGO_LDFLAGS="-static" go build</code></pre></div><p data-pid="5dKs6ahb"><b>malloc.c:</b></p><div class="highlight"><pre><code class="language-c"> <span class="err">❯</span> <span class="n">cat</span> <span class="n">malloc</span><span class="p">.</span><span class="n">c</span>
 <span class="cp">#include</span> <span class="cpf">&lt;stdlib.h&gt;</span><span class="cp">
</span><span class="cp"></span> <span class="cp">#include</span> <span class="cpf">&lt;stdio.h&gt;</span><span class="cp">
</span><span class="cp"></span> <span class="cp">#include</span> <span class="cpf">&lt;string.h&gt;</span><span class="cp">
</span><span class="cp"></span> <span class="err">​</span>
 <span class="cp">#define BLOCK_SIZE (100*1024*1024)
</span><span class="cp"></span> <span class="kt">char</span><span class="o">*</span> <span class="n">allocMemory</span><span class="p">()</span> <span class="p">{</span>
     <span class="kt">char</span><span class="o">*</span> <span class="n">out</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">malloc</span><span class="p">(</span><span class="n">BLOCK_SIZE</span><span class="p">);</span>
     <span class="n">memset</span><span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="sc">'A'</span><span class="p">,</span> <span class="n">BLOCK_SIZE</span><span class="p">);</span>
     <span class="k">return</span> <span class="n">out</span><span class="p">;</span>
 <span class="p">}</span></code></pre></div><p data-pid="tL5_Fj2R"><b>malloc.go:</b></p><div class="highlight"><pre><code class="language-go"> <span class="err">❯</span> <span class="nx">cat</span> <span class="nx">malloc</span><span class="p">.</span><span class="k">go</span>
 <span class="kn">package</span> <span class="nx">main</span>
 <span class="err">​</span>
 <span class="c1">//#cgo LDFLAGS:
</span><span class="c1"></span> <span class="c1">//char* allocMemory();
</span><span class="c1"></span> <span class="kn">import</span> <span class="s">"C"</span>
 <span class="kn">import</span> <span class="p">(</span>
         <span class="s">"fmt"</span>
         <span class="s">"time"</span>
 <span class="p">)</span>
 <span class="err">​</span>
 <span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
         <span class="c1">// only loop 10 times to avoid exhausting the host memory
</span><span class="c1"></span>         <span class="nx">holder</span> <span class="o">:=</span> <span class="p">[]</span><span class="o">*</span><span class="nx">C</span><span class="p">.</span><span class="nx">char</span><span class="p">{}</span>
         <span class="k">for</span> <span class="nx">i</span> <span class="o">:=</span> <span class="mi">1</span><span class="p">;</span> <span class="nx">i</span> <span class="o">&lt;=</span> <span class="mi">10</span><span class="p">;</span> <span class="nx">i</span><span class="o">++</span> <span class="p">{</span>
                 <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">"Allocating %dMb memory, raw memory is %d\n"</span><span class="p">,</span> <span class="nx">i</span><span class="o">*</span><span class="mi">100</span><span class="p">,</span> <span class="nx">i</span><span class="o">*</span><span class="mi">100</span><span class="o">*</span><span class="mi">1024</span><span class="o">*</span><span class="mi">1025</span><span class="p">)</span>
                 <span class="c1">// hold the memory, otherwise it will be freed by GC
</span><span class="c1"></span>                 <span class="nx">holder</span> <span class="p">=</span> <span class="nb">append</span><span class="p">(</span><span class="nx">holder</span><span class="p">,</span> <span class="p">(</span><span class="o">*</span><span class="nx">C</span><span class="p">.</span><span class="nx">char</span><span class="p">)(</span><span class="nx">C</span><span class="p">.</span><span class="nf">allocMemory</span><span class="p">()))</span>
                 <span class="nx">time</span><span class="p">.</span><span class="nf">Sleep</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nx">Minute</span><span class="p">)</span>
         <span class="p">}</span>
 <span class="p">}</span>
</code></pre></div><p class="ztext-empty-paragraph"><br></p><h3><b>编译 &amp; 运行</b></h3><p data-pid="I-4qOPSu">  编译结果如下：</p><div class="highlight"><pre><code class="language-text"> ❯ make build
 CGO_ENABLED=1 GOOS=linux CGO_LDFLAGS="-static" go build
 ❯ 
 ❯ tree ./
 ./
 ├── go.mod
 ├── Makefile
 ├── malloc.c
 ├── malloc.go
 └── memory
 ​
 0 directories, 5 files</code></pre></div><p data-pid="EtPPKaMl">运行：</p><div class="highlight"><pre><code class="language-text"> ❯ ./memory
 Allocating 100Mb memory, raw memory is 104960000
 ​</code></pre></div><blockquote data-pid="DUIyGAEi">注意:此时时hang在这的</blockquote><p class="ztext-empty-paragraph"><br></p><p data-pid="Ny5BDOR2"><b>再起一个窗口,查看该进程的内存占用情况</b></p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic4.zhimg.com/v2-31640d4672dccb8d042d0e5349ec307f_r.jpg" data-caption="" data-size="normal" width="1994" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><p data-pid="3LiVIGtL"><b>在<code>/sys/fs/cgroup/memory/</code>下创建目录<code>memorydemo1</code></b></p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic2.zhimg.com/v2-50d4f9ac3d522ad1ca54b7b8045cbf71_r.jpg" data-caption="" data-size="normal" width="1988" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><p data-pid="fcfZb8n6"><b>查看<code>memory</code>进程的PID</b></p><div class="highlight"><pre><code class="language-text"> ❯ ps -ef|grep memory|grep -v grep|awk '{print $2}'
 992008</code></pre></div><p class="ztext-empty-paragraph"><br></p><p data-pid="ijad6V8Y"><b>将进程添加到cgroup配置组</b></p><div class="highlight"><pre><code class="language-bash"> ❯  <span class="nb">echo</span> <span class="m">992008</span> &gt; cgroup.procs <span class="p">|</span> cat
 <span class="m">992008</span></code></pre></div><p class="ztext-empty-paragraph"><br></p><p data-pid="LINYlgiI"><b>end：设置<code>memory.limit_in_bytes</code></b></p><div class="highlight"><pre><code class="language-bash"> ❯  <span class="nb">echo</span> <span class="m">104960000</span> &gt; memory.limit_in_bytes <span class="p">|</span> cat
 <span class="m">104960000</span></code></pre></div><blockquote data-pid="EHxetPJf">此时运行<code>memory</code>程序的窗口中,该进程已经被kill了.</blockquote><p class="ztext-empty-paragraph"><br></p><h2><b>文件系统</b></h2><ul><li data-pid="8vUEVlj4"><a href="https://docker.nsddd.top/markdown/50.html" target="_blank">之前做的一些关于 Union FS 笔记</a></li></ul><p class="ztext-empty-paragraph"><br></p><h3><b>Union FS</b></h3><p data-pid="6EvFA5JX">  docker中namespace是创新点嘛，不是的，<b>docker的创新点准确来说是并不是 runtime，而是在文件系统中(Union FS)。</b></p><ul><li data-pid="LOglYhKv">将不同目录挂载到同一个虚拟文件系统下的文件系统(unite several directories into a single virtual filesystem)</li><li data-pid="NwBG6ebi">支持为每一个成员目录(类似Git Branch)设定<code>readonly</code>、<code>readwirte</code>和<code>write-able</code>权限</li><li data-pid="NjjqlC8b">文件系统分层,对readonly权限的branch可以逻辑上进行修改(增量地,不影响readonly部分的)</li><li data-pid="u1Nj40mO">通常Union FS有2个用途:<br></li><ul><li data-pid="EDXYuD5y">可以将多个disk挂到同一个目录下</li><li data-pid="TnnE5Ih9">将一个readonly的branch和一个writeable的branch联合在一起</li></ul></ul><p class="ztext-empty-paragraph"><br></p><p data-pid="klSEjE0n">Union FS:通过一些技术手段,将不同的目录mount到同一个虚拟目录中.每个目录在虚拟目录中可以有独立的权限(readonly、readwirte、write-able).</p><p data-pid="CkyDOEgo">通过这种方式,可以将多个不同来源的子目录模拟成一个完整的OS.</p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic4.zhimg.com/v2-010b817ad76dd506586e810f1d2b5a7b_r.jpg" data-caption="" data-size="normal" width="2372" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p data-pid="3jpy2QCh">  <b>对上面的解释</b>：</p><p data-pid="v4rg_QAm">我们可以看到 两个 dockerfile 是不一样的，但是前两条指令是一样的，也就是说在一个层。</p><p data-pid="Fg97i645">但是后面两个层是不一样的，所以说后面两个 就开始判断。</p><p data-pid="E6NWeXZQ"><b>所以这些地方是复用的。</b></p><p data-pid="BmFA5nwj">docker pull 的时候会拉取并且判断，上面的话基础层是一样的，也就不会重复。</p><blockquote data-pid="c7H1-rvP"><b>我们之前的学习 大致 止步于原理上，但是底层和源码实现还是缺少一部分的。</b></blockquote><p class="ztext-empty-paragraph"><br></p><h3><b>docker 文件系统</b></h3><p data-pid="GxObzdhr">一般1个Linux会分为2个主要组成部分:</p><ol><li data-pid="aUm8HJJR">Bootfs(boot file system)<br></li></ol><ul><li data-pid="FVvk0non"><code>Bootloader</code>:引导加载kernel</li><li data-pid="EAarRMS9"><code>Kernel</code>:当kernel被加载到内存中后,umount bootfs</li></ul><p class="ztext-empty-paragraph"><br></p><ol><li data-pid="nMdWiSdd">rootfs(root file system)<br></li></ol><ul><li data-pid="Gts_qiCk"><code>/dev</code>,<code>/proc</code>,<code>/bin</code>,<code>/etc</code>等标准目录和文件</li><li data-pid="8vCyj5A1">对于不同的Linux发行版,bootfs基本是一致的,但rootfs会有差别</li></ul><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>Docker的启动</b></h3><p data-pid="8BZAL6gg"><b>Linux的启动:</b></p><ul><li data-pid="rlv0X4WY">在启动后,首先将rootfs设置为<code>readonly</code> （只读层）,进行一系列检查,然后将其切换为"readwrite"供用户使用</li></ul><p data-pid="v_k12s_O"><b>Docker的启动:</b></p><ul><li data-pid="VOxy8mEn">初始化时也是将rootfs以<code>readonly</code>方式加载并检查,但接下来使用<code>union mount</code>的方式将一个<code>readwrite</code>的文件系统挂载在<code>readonly</code>的rootfs之上</li><li data-pid="q727BpDv">允许再次将下层的<code>FS(file system)</code>设定为<code>readonly</code>并且向上叠加</li><li data-pid="PXYWHHIi">这样一组<code>readonly</code>和一个<code>writeable</code>的结构，构成了一个<code>container</code>的运行时态,每一个FS被称为一个FS层</li></ul><p data-pid="tVJyH-4K">最上方的一层为<code>readwrite</code>,在它之下的层都是<code>readonly</code>。所有用户的修改都被记录在了顶层(即 <code>readwrite</code>的层)中,不会涉及到下方的层.</p><p class="ztext-empty-paragraph"><br></p><h3><b>写操作</b></h3><p data-pid="Ij7fq4gl">由于镜像具有共享特性,所以对容器的可写层的操作需要依赖存储驱动提供的 <b>写时复制和用时分配机制</b>，以此来支持对容器可写层的修改,进而提高对存储和内存资源的利用率。</p><h3><b>写时复制</b></h3><p data-pid="ZgbPxeCH"><b>写时复制</b>：即<code>Copy-on-Write</code> 。1个镜像可以被多个容器使用,但是不需要在内存和磁盘上做多拷贝，在需要对镜像提供的文件进行修改时。该文件才会从镜像的文件系统被复制到容器的可写层文件系统,然后进行修改。而镜像中的文件不会改变。不同容器对文件的修改都相互独立、互不影响。</p><p data-pid="d71MbJgr">1个镜像是可以被不同的容器使用的 1 个镜像中的不同层也是被多个镜像共享的。因此有了写时复制技术，就可以确保下方的基础镜像层不会被修改.无论通过该基础镜像启动了多少个容器,这些容器的底层基础镜像都是一致的。换言之，N个使用了同一个基础镜像的容器,是共享了1个基础镜像层的文件,而非每个容器各持有一份基础镜像层文件的拷贝。</p><p data-pid="4JmYtOqy">当需要修改基础镜像层时,是在位于该层上方的可写层中对基础层的文件做修改,最终结果相当于在上方的文件层中对下方的基础层做覆盖的操作。</p><h3><b>用时分配</b></h3><p data-pid="ev74HUGM">按需分配空间,而非提前分配,即当一个文件被创建出来后,才会分配空间</p><p class="ztext-empty-paragraph"><br></p><h3><b>容器存储驱动优缺点比较以及应用</b></h3><p data-pid="3Vj4KN_B">写时复制的行为需要容器的存储驱动来支持：</p><table data-draft-node="block" data-draft-type="table" data-size="normal" data-row-style="normal"><tbody><tr><th>存储驱动</th><th>Docker</th><th>Containerd</th></tr><tr><td>AUFS</td><td>在Ubuntu或Debian上支持</td><td>不支持</td></tr><tr><td>OverlayFS</td><td>支持</td><td>支持</td></tr><tr><td>Device Mapper</td><td>支持</td><td>支持</td></tr><tr><td>BtrFS</td><td>社区版本在Ubuntu或Debian上支持,企业版本在SLES上支持</td><td>支持</td></tr><tr><td>ZFS</td><td>支持</td><td>不支持</td></tr></tbody></table><p data-pid="joPt-_HJ">为什么用 OverlayFS</p><table data-draft-node="block" data-draft-type="table" data-size="normal" data-row-style="normal"><tbody><tr><th>存储驱动</th><th>优点</th><th>缺点</th><th>应用场景</th></tr><tr><td>AUFS</td><td>Docker最早支持的驱动类型,稳定性高</td><td>并未进入主线的内核,因此只能在有限的场合下使用.另外在实现上具有多层结构,在层比较多的场景下,做写时复制有时会需要比较长的时间</td><td>少I/O的场景</td></tr><tr><td>OverlayFS</td><td>并入主线内核,可以在目前几乎所有发行版本上使用.实现只有2层,因此性能比AUFS高</td><td>写时复制机制需要复制整个文件,而不能只针对修改的部分进行复制,因此大文件操作会需要比较长的时间.其中Overlay在Docker的后续版本中被移除</td><td>少I/O的场景</td></tr><tr><td>Device Mapper</td><td>并入主线内核,针对块操作,性能比较高.修改文件时只需复制需要修改的块,效率高</td><td>不同容器之间不能共享缓存。在Dokcer的后续版本中会被移除</td><td>I/O密集场景</td></tr><tr><td>BtrFS</td><td>并入主线内核,虽然是文件级操作系统,但是可以对块进行操作</td><td>需要消耗比较多的内存,稳定性相对比较差</td><td>需要支持Snapshot等比较特殊的场景</td></tr><tr><td>ZFS</td><td>不同的容器之间可以共享缓存,多个容器访问相同的文件能够共享一个单一的Page Cache</td><td>在频繁写操作的场景下,会产生比较严重的磁盘碎片.需要消耗比较多的内存,另外稳定性相对比较差</td><td>容器高密度部署的场景</td></tr></tbody></table><p class="ztext-empty-paragraph"><br></p><h3><b>OverlayFS</b></h3><p data-pid="xRfjzoyN">OverlayFS 也是一种与AUFS类似的联合文件系统，同样属于文件级的存储驱动，包含了最初的Overlay和更新更稳定的 OverlayFS2.</p><p data-pid="PUVrrFip"><b>Overlay只有2层：upper层和lower层</b></p><ul><li data-pid="EvT7ka-F"><code>lower</code>层代表镜像层</li><li data-pid="MsDdPEq4"><code>upper</code>层代表容器可写层</li></ul><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic2.zhimg.com/v2-4ff0b9ca727262e4c84c041c670eadd5_r.jpg" data-caption="" data-size="normal" width="1809" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><p data-pid="VJeJtAzx"><b>由此可见，如果一个文件在上层或者是在下层，那么他们在合并层是可见的。</b></p><p data-pid="KD95RprQ"><b>如果一个文件在上下层都存在，那么就会出现在上层。</b></p><p data-pid="K24R_ipy">所以基础镜像是下层，每一次都叠加一次，最终看到的操作系统就是上层的。</p><p class="ztext-empty-paragraph"><br></p><h3><b>OverlayFS文件系统演示</b></h3><p data-pid="GStuU-gf"><b>之前我们一直都没做镜像，我用 centos 镜像测试：</b></p><div class="highlight"><pre><code class="language-bash"> docker run -it --name centos2 centos
 docker <span class="nb">exec</span> -it daddac4c0706 bash</code></pre></div><p class="ztext-empty-paragraph"><br></p><p data-pid="3EoOkKkj"><b>在容器内创建目录：</b></p><div class="highlight"><pre><code class="language-bash"> <span class="o">[</span>root@daddac4c0706 /<span class="o">]</span><span class="c1"># ls </span>
 bin  dev  etc  home  lib  lib64  lost+found  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var
 <span class="o">[</span>root@daddac4c0706 /<span class="o">]</span><span class="c1"># mkdir upper lower merged work;ls</span>
 bin  etc   lib    lost+found  media   mnt  proc  run   srv  tmp    usr  work
 dev  home  lib64  lower       merged  opt  root  sbin  sys  upper  var</code></pre></div><p class="ztext-empty-paragraph"><br></p><p data-pid="koiOEw92"><b>分别创建不同的文件：</b></p><div class="highlight"><pre><code class="language-bash"> <span class="nb">echo</span> <span class="s2">"from lower"</span> &gt; lower/in_lower.txt
 <span class="nb">echo</span> <span class="s2">"from upper"</span> &gt; upper/in_upper.txt
 <span class="nb">echo</span> <span class="s2">"from lower"</span> &gt; lower/in_both.txt
 <span class="nb">echo</span> <span class="s2">"from upper"</span> &gt; upper/in_both.txt</code></pre></div><blockquote data-pid="lU9qsgyg">接下来要演示的是:将<code>upper</code>目录和<code>lower</code>目录整合到一起后,文件的内容会有什么样的</blockquote><p class="ztext-empty-paragraph"><br></p><p data-pid="ehqUSl2Z"><b>挂载一个OverlayFS文件系统：</b></p><div class="highlight"><pre><code class="language-bash"> <span class="o">[</span>root@daddac4c0706 /<span class="o">]</span><span class="c1"># exit</span>
 <span class="nb">exit</span>
 <span class="o">[</span>root@dev workspces<span class="o">]</span><span class="c1"># mkdir -p /tmp/overlayfs; cd /tmp/overlayfs</span>
 <span class="o">[</span>root@dev overlayfs<span class="o">]</span><span class="c1">#  mkdir upper lower merged work;ls</span>
 lower  merged  upper  work
 <span class="o">[</span>root@dev overlayfs<span class="o">]</span><span class="c1"># echo "from lower" &gt; lower/in_lower.txt</span>
 <span class="o">[</span>root@dev overlayfs<span class="o">]</span><span class="c1"># echo "from upper" &gt; upper/in_upper.txt</span>
 <span class="o">[</span>root@dev overlayfs<span class="o">]</span><span class="c1"># echo "from lower" &gt; lower/in_both.txt</span>
 <span class="o">[</span>root@dev overlayfs<span class="o">]</span><span class="c1"># echo "from upper" &gt; upper/in_both.txt</span>
 <span class="o">[</span>root@dev overlayfs<span class="o">]</span><span class="c1"># sudo mount -t overlay overlay -o lowerdir=`pwd`/lower,upperdir=`pwd`/upper,workdir=`pwd`/work `pwd`/merged</span></code></pre></div><p data-pid="x-7VSiFX"><b>目录结构：</b></p><div class="highlight"><pre><code class="language-bash"> <span class="o">[</span>root@dev overlayfs2<span class="o">]</span><span class="c1"># tree</span>
 .
 ├── lower
 │   ├── in_both.txt
 │   └── in_lower.txt
 ├── merged
 │   ├── in_both.txt    <span class="c1"># delete</span>
 │   ├── in_lower.txt
 │   └── in_upper.txt
 ├── upper
 │   ├── in_both.txt
 │   └── in_upper.txt
 └── work
     └── work</code></pre></div><p class="ztext-empty-paragraph"><br></p><p data-pid="D-XAZnGc"><b>挂载指令解析：</b></p><div class="highlight"><pre><code class="language-bash"> sudo mount -t overlay overlay -o <span class="nv">lowerdir</span><span class="o">=</span><span class="sb">`</span><span class="nb">pwd</span><span class="sb">`</span>/lower,upperdir<span class="o">=</span><span class="sb">`</span><span class="nb">pwd</span><span class="sb">`</span>/upper,workdir<span class="o">=</span><span class="sb">`</span><span class="nb">pwd</span><span class="sb">`</span>/work <span class="sb">`</span><span class="nb">pwd</span><span class="sb">`</span>/merged</code></pre></div><ul><li data-pid="ijLUcLCA"><code>-t</code>:指定文件系统类型</li><li data-pid="8YRmudvL"><code>lowerdir</code>:指定用户要挂载的lower层目录</li><li data-pid="Xo_ltWVy"><code>upperdir</code>:指定用户要挂载的upper层目录</li><li data-pid="Pgtd1zgA"><code>workdir</code>:指定文件系统的工作基础目录.挂载后该目录会被清空,且在使用过程中其内容对用户不可见</li><li data-pid="Xz1_C2HQ"><code>pwd/merged</code>:这并不是参数,而是指定最终挂载的目录</li></ul><p class="ztext-empty-paragraph"><br></p><p data-pid="uSBPUyTC"><b>查看<code>./merged</code>目录中的内容</b></p><div class="highlight"><pre><code class="language-bash"> <span class="o">[</span>root@dev overlayfs2<span class="o">]</span><span class="c1"># cd merged/</span>
 <span class="o">[</span>root@dev merged<span class="o">]</span><span class="c1"># cat in_both.txt in_lower.txt in_upper.txt</span>
 from upper
 from lower
 from upper</code></pre></div><blockquote data-pid="ejmlmv2E">这是合并后的层</blockquote><p data-pid="vOPYDw3w">可以看到，当把2(多)个目录通过<code>overlay</code>的形式<code>mount</code>到一个虚拟目录时，在这个新的虚拟目录中，会整合来自上层和下层的文件。最终这个虚拟目录中会整合多个目录中的文件，如果遇到同名文件，则上层的文件会覆盖下层的文件。</p><p data-pid="QJaeSDmG">回到容器镜像上，基础镜像层就相当于演示中的lower层。</p><p data-pid="W_BJXGW5">若需要在这个基础镜像层中添加一些内容，则在这个基础镜像层上再加一个新的容器层,然后通过<code>overlayFS</code>的形式将这个新的容器层<code>mount</code>进去即可.</p><p data-pid="Ki9PCH9d">若需要在这个基础镜像层中做一些修改,也不需要去修改lower层,只需在上方堆叠一个同名文件即可。新的文件会覆盖掉下层中已存在的文件.</p><p data-pid="XKjO_iCm"><b>在<code>./merged</code>中删除文件：</b></p><div class="highlight"><pre><code class="language-bash"> <span class="o">[</span>root@dev merged<span class="o">]</span><span class="c1">#  rm -f ./in_both.txt;tree ../</span>
 ../
 ├── lower
 │   ├── in_both.txt
 │   └── in_lower.txt
 ├── merged
 │   ├── in_lower.txt
 │   └── in_upper.txt
 ├── upper
 │   ├── in_both.txt
 │   └── in_upper.txt
 └── work
     └── work
 ​</code></pre></div><p data-pid="A0suQQLX">我们删除掉了 合并层 <code>in_both.txt</code> 文件，看看有没有影响到 </p><div class="highlight"><pre><code class="language-bash"> <span class="o">[</span>root@dev merged<span class="o">]</span><span class="c1"># cat ../upper/in_both.txt</span>
 cat: ../upper/in_both.txt: No such device or address
 <span class="o">[</span>root@dev merged<span class="o">]</span><span class="c1"># cat ../lower/in_both.txt </span>
 from lower</code></pre></div><p data-pid="gj5iYisQ"> 可以看到，<code>upper/in_both.txt</code>被删除了。但<code>lower/in_both.txt</code>没有受到删除操作的影响。</p><blockquote data-pid="jsSn1ZOb">对比到 docker ，容器层被删除了，但是 镜像（只读层没变化）</blockquote><p data-pid="TfVMZDlh"><b>删除<code>in_lower.txt</code>（镜像）</b></p><div class="highlight"><pre><code class="language-bash"> <span class="o">[</span>root@dev merged<span class="o">]</span><span class="c1"># rm -f ./in_lower.txt;tree ../</span>
 ../
 ├── lower
 │   ├── in_both.txt
 │   └── in_lower.txt
 ├── merged
 │   └── in_upper.txt
 ├── upper
 │   ├── in_both.txt
 │   ├── in_lower.txt
 │   └── in_upper.txt
 └── work
     └── work
 ​
 <span class="m">5</span> directories, <span class="m">6</span> files
 ​
 <span class="o">[</span>root@dev merged<span class="o">]</span><span class="c1"># cat ../upper/in_lower.txt </span>
 cat: ../upper/in_lower.txt: No such device or address
 ​
 <span class="o">[</span>root@dev merged<span class="o">]</span><span class="c1"># cat ../lower/in_lower.txt </span>
 from lower</code></pre></div><p data-pid="QtduTkap">可以看到，<code>upper/</code>目录中多了一个文件<code>in_lower.txt</code>。但这个文件是不存在的。但<code>lower/in_lower.txt</code>没有受到删除操作的影响.</p><div class="highlight"><pre><code class="language-bash"> <span class="o">[</span>root@dev merged<span class="o">]</span><span class="c1"># cd ..;ls -al upper</span>
 total <span class="m">12</span>
 drwxr-xr-x <span class="m">2</span> root root <span class="m">4096</span> Mar  <span class="m">2</span> 20:16 .
 drwxr-xr-x <span class="m">6</span> root root <span class="m">4096</span> Mar  <span class="m">2</span> 20:06 ..
 c--------- <span class="m">1</span> root root 0, <span class="m">0</span> Mar  <span class="m">2</span> 20:11 in_both.txt
 c--------- <span class="m">1</span> root root 0, <span class="m">0</span> Mar  <span class="m">2</span> 20:16 in_lower.txt
 -rw-r--r-- <span class="m">1</span> root root   <span class="m">11</span> Mar  <span class="m">2</span> 20:06 in_upper.txt</code></pre></div><blockquote data-pid="GEuKnc1u">注:<code>c---------</code>中的<code>c</code>表示字符设备文件</blockquote><p class="ztext-empty-paragraph"><br></p><p data-pid="s7rPqw_f"><b>删除<code>in_upper.txt</code></b></p><div class="highlight"><pre><code class="language-text"> [root@dev overlayfs2]# rm ./merged/in_upper.txt -f
 [root@dev overlayfs2]# tree
 .
 ├── lower
 │   ├── in_both.txt
 │   └── in_lower.txt
 ├── merged
 ├── upper
 │   ├── in_both.txt
 │   └── in_lower.txt
 └── work
     └── work
 ​</code></pre></div><p data-pid="4_0zc8YZ">可以看到： <code>upper/in_upper.txt</code>确实被删除了.</p><p class="ztext-empty-paragraph"><br></p><h3><b>inspect</b></h3><div class="highlight"><pre><code class="language-text"> # docker inspect daddac4c0706
 ​
 ```bash
         "Image": "sha256:5d0da3dc976460b72c77d94c8a1ad043720b0416bfc16c52c45d4847e53fadb6",
         "ResolvConfPath": "/var/lib/docker/containers/daddac4c07067978995724d650ed8a6f0f8d8edfc979f13c9883f1a6971b904a/resolv.conf",
         "HostnamePath": "/var/lib/docker/containers/daddac4c07067978995724d650ed8a6f0f8d8edfc979f13c9883f1a6971b904a/hostname",
         "HostsPath": "/var/lib/docker/containers/daddac4c07067978995724d650ed8a6f0f8d8edfc979f13c9883f1a6971b904a/hosts",
         "LogPath": "",
 ```</code></pre></div><p class="ztext-empty-paragraph"><br></p><h3><b>docker 引擎架构</b></h3><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic2.zhimg.com/v2-9a48d78b39b9d4b8939ea5e983fbd6a1_r.jpg" data-caption="" data-size="normal" width="2024" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><ul><li data-pid="_PdrSgqc"><code>Docker daemon</code>：Docker后台的服务端，事实上是一套 REST API</li><li data-pid="EMCSV_FR"><code>Docker command</code>：命令行.可以把docker的命令作为一个请求发送给 Docker daemon</li><li data-pid="Kji4D1q2"><code>containerd</code>：用于控制运行时进程的组件，Docker daemon接收到该请求后，通过GRPC的调用，把请求转发到<code>containerd</code>上</li><li data-pid="jJVFGArX"><code>shim</code>进程：<code>containerd</code>收到请求后，启动一个<code>shim</code>进程。<code>shim</code>进程通过<code>runc</code>(底层运行时的一个接口)启动容器进程</li></ul><p data-pid="4Hr_H3pR"><b>shim的作用</b>：在早期,containerd和shim是不存在的.那个时代,当你通过docker命令去运行一个容器进程时,这个容器进程是由docker daemon直接拉起的。</p><p data-pid="ajcjABih"><b>这样设计的问题</b>：docker daemon成为了所有容器进程的父进程.当你升级或重启docker时,父进程就不存在了，子进程也会被重启.这导致的问题是:你无法轻易升级docker.对于早期的docker来讲,这是一个致命问题。</p><p data-pid="xhhdNtmn"><code>containerd</code>启动了一个<code>shim</code>进程后，会将该shim交给OS的<code>init system</code>(比如systemd)。这样 containerd下面是不挂任何进程的，可以随意升级或重启。即：<b>把控制组件和数据面组件分离</b></p><blockquote data-pid="fwK_U_Lo">docker 结构图 我们都知道，我们开始学 docker 的时候第一件事就是看架构，不管什么项目，始于架构，也忠于架构。<br></blockquote><ul><li data-pid="YQiCW-Da"><a href="https://docker.nsddd.top/markdown/2.html" target="_blank">docker 系统架构笔记</a></li></ul><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h2><b>网络</b></h2><p data-pid="48tXJ6_G"><b>  终于到了 网络 部分了，docker 网络是可以有 独立的 namespace ，但是也并不是这么简单的，接下来该好好研究网络了。</b></p><ul><li data-pid="RZTGfRXQ"><a href="https://docker.nsddd.top/markdown/30.html" target="_blank">关于 docker 网络的基础，入门级别使用篇，请看这一篇我写的笔记</a></li></ul><p class="ztext-empty-paragraph"><br></p><p data-pid="cx2qXHv6"><b>docker网络的几种模式：</b></p><ul><li data-pid="Y9DxWe9Q">bridge模式（默认）：使用<code>--network bridge</code>指定，默认使用<code>docker0</code></li><li data-pid="v4TkTaf-">host模式：使用<code>--network host</code>指定</li><li data-pid="uSvZxQQd">none模式：使用<code>--network none</code>指定（Kubernetes需要）</li><li data-pid="WCmoqSXq">container模式：使用<code>--network container:NAME</code>或者容器ID指定（复用其他容器的网络）</li></ul><p data-pid="UoaR5k21">看到 docker0 就有一种神秘的亲切感，Kubernetes 的网络设计也是参考 docker~</p><blockquote data-pid="Rza0KbLA">你可以把 docker0 理解为一个交换机~<br>如果上层有Kubernetes这种编排系统,Kubernetes希望通过自己的网络插件来配置网络,此时就应该使用Null模式来创建一个镜像<br>⚠️ 注意，虽然什么都不做，但是用户希望全权处理容器的网络配置时使用 nono，Docker不为用户做任何配置，但是会为用户把网络的namespace创建出来.</blockquote><p class="ztext-empty-paragraph"><br></p><h3><b>跨主机的网络模式</b></h3><p data-pid="Xka1Ss9b"><b>Remote(work with remote dirvers)</b></p><ul><li data-pid="99x_1a9t"><code>Underlay</code>:<br></li><ul><li data-pid="6q-qSk34">使用现有底层网络，为每一个容器配置可路由的网络IP</li><li data-pid="9FvtqRlA">这种模式容器网络和主机网络是一样的.容器的IP段在主机层面知道如何路由.这样一来容器的数据包就可以自由传输.</li><li data-pid="I-njQ1G-">这种模式的局限性:容器网络和主机网络共用,但容器网络对IP的消耗是巨大的.所以如果采用这种模式实现跨主机的容器间通信,需要提前规划好网段(比如有多大的网段分给容器,有多大的网段分给基础架构)</li></ul></ul><p class="ztext-empty-paragraph"><br></p><ul><li data-pid="-xP5MRps"><code>Overlay</code>:<br></li><ul><li data-pid="IJNMay9A">通过网络封包实现</li><li data-pid="ENpPqZ15">通常容器网络和底层基础架构网络是两套网络。容器有自己的子网，这个子网在底层网络中是不能路由的。也就是说,容器网络中的网络请求是不能在基础网络中传输的,数据包是传不过去的。</li><li data-pid="C-6SkzI1">想要实现跨主机的容器间互联互通，就需要基于Overlay技术。当容器发出的数据包要通过主机向外传输时，在主机层面再封装一层。在原始数据包的基础上通过各种协议再加一层包头，这个包头会把当前主机地址作为原地址，把对端主机地址作为目标地址。封装好的数据包就可以在基础架构网络中传输了</li><li data-pid="TmseG6Bx">数据包到达对端主机后，对端主机解包.解开主机一层包头后,剩下的就是容器的数据包头。这样一来数据包就可以到达对端主机上的容器了</li></ul></ul><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>单节点的容器网络模式</b></h3><p data-pid="nOKhNQ-3"><b>我们上面说过 NONO 是一个空实现</b></p><ul><li data-pid="Tswa8VqP">Null模式是一个空实现</li><li data-pid="MehA07hm">可以通过Null模式启动容器并在宿主机上通过命令为容器配置网络</li></ul><p class="ztext-empty-paragraph"><br></p><h3><b>案例</b></h3><p data-pid="Grim56Sb">创建一个网络模式为Null的容器,并为该容器配置网络</p><p class="ztext-empty-paragraph"><br></p><p data-pid="32NJaCMh"><b>运行一个nginx的容器,并且将网络模式设置成Null</b></p><div class="highlight"><pre><code class="language-bash"> <span class="o">[</span>root@dev workspces<span class="o">]</span><span class="c1"># docker run --network=none -d nginx</span>
 9dcdea440a927d7b7c60c0df3dab06b2b3cd3258507b07de339b31bd10c92d92
 ​
 <span class="o">[</span>root@dev workspces<span class="o">]</span><span class="c1"># docker ps</span>
 CONTAINER ID        IMAGE                          COMMAND                  CREATED              STATUS                       PORTS                    NAMES
 9dcdea440a92        nginx                          <span class="s2">"/docker-entrypoin..."</span>   About a minute ago   Up <span class="m">57</span> seconds                                         loving_nightingale</code></pre></div><p class="ztext-empty-paragraph"><br></p><p data-pid="NDW_hDNZ"><b>检查该容器进程的pid：</b></p><div class="highlight"><pre><code class="language-bash"> <span class="o">[</span>root@dev workspces<span class="o">]</span><span class="c1"># docker inspect 9dcde|grep -i pid</span>
             <span class="s2">"Pid"</span>: 9737,
             <span class="s2">"PidMode"</span>: <span class="s2">""</span>,
             <span class="s2">"PidsLimit"</span>: 0,</code></pre></div><p class="ztext-empty-paragraph"><br></p><p data-pid="YyYgSNTe"><b>在宿主机上查看容器进程的网络情况</b></p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic2.zhimg.com/v2-ce20c8b476b856e3d62b285adc43d41d_r.jpg" data-caption="" data-size="normal" width="1535" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p data-pid="ySgN0Rux">可以看到只有loopback地址,没有其他网络配置。也就是说现在是无法通过外部的网络调用来访问这个服务的，但是该进程的 <code>network namespace</code> 是已经被建立了.</p><p data-pid="4wEC0Td4"><b>创建容器进程的network namespace</b></p><div class="highlight"><pre><code class="language-bash"> <span class="o">[</span>root@dev workspces<span class="o">]</span><span class="c1"># mkdir -p /var/run/netns</span>
 <span class="o">[</span>root@dev workspces<span class="o">]</span><span class="c1"># export pid=9737</span>
 <span class="o">[</span>root@dev workspces<span class="o">]</span><span class="c1"># ln -s /proc/$pid/ns/net /var/run/netns/$pid</span></code></pre></div><p data-pid="jHke1S0V">此处创建目录的目的：<b>当我们希望把一个进程关联到一个<code>network namespace</code>上时，就需要有一个地方来保存network namespace的相关信息</b>(如：有哪些network namespace、这些network namespace关联了哪些进程等信息)。这个地方就是<code>/var/run/netns/</code>.</p><p data-pid="yW67A1H6">此处创建软连接的目的:<code>/proc/$pid/ns/net</code>是容器进程的network namespace信息 ，<code>/var/run/netns/$pid</code>是我们自己创建的,用于保存容器进程的network namespace的目录.此处建立软连接是为了后续操作，在创建了链路之后,连接容器进程的network namespace和主机的network namespace用。</p><blockquote data-pid="0EMp4fJ0">⚠️ <b>注:某些程序启动服务后,会将它们PID放置在<code>/var/run/</code>目录下</b></blockquote><p class="ztext-empty-paragraph"><br></p><p data-pid="YABQBt7K"><b>检查容器进程的network namespace是否能在主机上被查看到</b></p><div class="highlight"><pre><code class="language-bash"> <span class="o">[</span>root@dev workspces<span class="o">]</span><span class="c1"># ip netns list</span>
 <span class="m">9737</span></code></pre></div><ul><li data-pid="vdJmVD0e"><code>ip netns</code>：用于管理network namespace。它可以创建命名的 network namespace,然后通过名字来引用network namespace</li><li data-pid="uOlUxz8m"><code>ip netns list</code>：显示所有命名的network namesapce，其<b>实就是显示<code>/var/run/netns</code>目录下的所有network namespace对象</b></li></ul><p class="ztext-empty-paragraph"><br></p><p data-pid="aZ5yBFcD"><b>查看Docker的网桥设备：</b></p><div class="highlight"><pre><code class="language-bash"> <span class="o">[</span>root@dev workspces<span class="o">]</span><span class="c1"># if bridge-utils;then bridge;else yum install bridge-utils; fi</span>
 ​
 <span class="o">[</span>root@dev workspces<span class="o">]</span><span class="c1"># brctl show</span>
 bridge name bridge id       STP enabled interfaces
 docker0     8000.02420bb43568   no</code></pre></div><p data-pid="_6vsshH2">当安装完Docker后，Docker默认在主机上会安装一个Bridge(桥接设备,可以理解为是一个集线器,该集线器上有很多网口。当多台主机的网线都连接到该Bridge设备后，这些主机之间就可以互通了)，该设备用于连接当前主机上的所有容器。</p><p class="ztext-empty-paragraph"><br></p><p data-pid="XIuiqJND"><b>有了网桥设备，想要让容器内的网络和主机互通,就比较容易了，其实只需要做2件事:</b></p><ol><li data-pid="Ov0mods4">为容器进程配置网络</li><li data-pid="lwYS6HGt">从容器的网络中牵一根网线到主机的namespace,并且插在docker0的Bridge上</li></ol><p data-pid="dhJcd8iV">这样主机网络和容器网络就可以互通了</p><p class="ztext-empty-paragraph"><br></p><h3><b>默认模式–网桥和NAT</b></h3><p data-pid="JFhamqzm">Docker网络的默认模式就是桥接。桥接其实就是刚才演示中的那些步骤.</p><p data-pid="_r0f84cg">不指定网络模式时，docker在网络连接方面做的工作，和我们刚才演示的是一样的。</p><p class="ztext-empty-paragraph"><br></p><h3><b>案例</b></h3><p data-pid="sxdKzhEf"><b>不指定网络模式，启动一个nginx容器</b></p><div class="highlight"><pre><code class="language-bash"> <span class="o">[</span>root@dev workspces<span class="o">]</span><span class="c1"># docker run -d nginx;docker ps</span>
 9f27121bb2f4ea27809830be982a705852430c7ed324b810ee2658452f289758</code></pre></div><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic2.zhimg.com/v2-33c864ded3497cda7c99642e07176d0d_r.jpg" data-caption="" data-size="normal" width="2301" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><p data-pid="-W4Yobi9"><b>查看该容器的网络设备情况</b></p><div class="highlight"><pre><code class="language-bash"> <span class="o">[</span>root@dev workspces<span class="o">]</span><span class="c1"># docker inspect 9f|grep -i pid</span>
             <span class="s2">"Pid"</span>: 19942,
             <span class="s2">"PidMode"</span>: <span class="s2">""</span>,
             <span class="s2">"PidsLimit"</span>: 0,</code></pre></div><p class="ztext-empty-paragraph"><br></p><p data-pid="OKdGzpqN"><b>查看容器网络：</b></p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic4.zhimg.com/v2-d0f5a2a826abd1ac9f640b7c05fb107f_r.jpg" data-caption="" data-size="normal" width="1705" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><blockquote data-pid="Wg0pOrp6">可以看到,该容器的IP地址为:<code>172.17.0.5</code>，还可以这样：<br> [root@dev workspces]# docker inspect 9f | grep -i ip<br>  "IpcMode": "",<br>  "LinkLocalIPv6Address": "",<br>  "LinkLocalIPv6PrefixLen": 0,<br>  "SecondaryIPAddresses": null,<br>  "SecondaryIPv6Addresses": null,<br>  "GlobalIPv6Address": "",<br>  "GlobalIPv6PrefixLen": 0,<br>  "IPAddress": "172.17.0.5",<br>  "IPPrefixLen": 16,<br>  "IPv6Gateway": "",<br>  "IPAMConfig": null,<br>  "IPAddress": "172.17.0.5",<br>  "IPPrefixLen": 16,<br>  "IPv6Gateway": "",<br>  "GlobalIPv6Address": "",<br>  "GlobalIPv6PrefixLen": 0,</blockquote><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>端口映射</b></h3><p data-pid="2I2pIktD"><b>若想要把容器内部的服务发布到主机上,该怎么做?</b></p><div class="highlight"><pre><code class="language-bash"> docker run -d --name nginx -p 8080:80 nginx</code></pre></div><p data-pid="_cldRT0g"><b>其底层逻辑为:</b>  Docker以标准模式配置网络</p><ul><li data-pid="mfjJU4nk">创建veth pair</li><li data-pid="UIUxJ92g">将veth pair的一端连接到docker0网桥</li><li data-pid="ZSKD-19W">veth pair的另一端设置为容器network namespace的eth0</li><li data-pid="gGSOBCMv">为容器network namespace的eth0分配ip</li><li data-pid="BCgLZzI7">主机上的iptables规则:<code>PREROUTING -A DOCKER ! -i docker0 -p tcp -m tcp -dport 2333 -j DNAT --to-destination 172.17.0.2:22</code><br> 实际上就是通过主机的iptable做了一个端口转发.</li></ul><p class="ztext-empty-paragraph"><br></p><h3><b>多节点的容器网络模式</b></h3><p class="ztext-empty-paragraph"><br></p><h3><b>Underlay</b></h3><p data-pid="KCDuvLh5">从实现上最容易的就是Underlay模式.</p><ul><li data-pid="iXEhRE7T">采用Linux网桥设备(sbrctl),通过物理网络连通容器</li><li data-pid="5dUKK2Qz">创建新的网桥设备mydr0</li><li data-pid="uWdtoWfG">将主机网卡加入网桥</li><li data-pid="n4ImlYcg">把主机网卡的地址配置到网桥,并把默认路由规则转移到网桥mydr0</li><li data-pid="pXp2KUZu">启动容器</li><li data-pid="fB3gYd6M">创建veth pair,把一个peer添加到网桥mydr0</li><li data-pid="aOUwKyRh">配置容器把veth的另一个peer分配给容器网卡</li></ul><p data-pid="aEgzWYOv">也就是说,Underlay模式是不划分独立的容器网络,而是容器网络融入到基础架构网络中.</p><ul><li data-pid="pLn3J1oV">优点:方案简单</li><li data-pid="V1Dfarzy">缺点:需要较强的网段规划能力.因为容器对IP的需求很大,所以要事先规划好所有IP的分配,避免造成IP的浪费.</li></ul><p class="ztext-empty-paragraph"><br></p><h3><b>Docker Libnetwork Overlay</b></h3><ul><li data-pid="S7By6Dou">Docker overlay网络驱动原生支持多主机网络</li><li data-pid="EUEbYY6W">Libnetwork是一个内置的基于VXLAN的网络驱动</li></ul><p data-pid="q0SaHIwQ">VXLAN是Overlay网络中最常用的一种模式.</p><blockquote data-pid="z9FwGj01">Kubernetes中的网络插件Flannel支持Overlay模式<br></blockquote><ul><li data-pid="L9Kb5Dv2">同一主机内的Pod可以使用网桥进行通信</li><li data-pid="PIaLS9Lf">不同主机上的Pod将通过flanneld将其流量封装在UDP数据包中</li></ul><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h2><b>Dockerbuild</b></h2><ul><li data-pid="BHR635H0"><a href="https://docker.nsddd.top/markdown/24.html" target="_blank">如果你对 dockerfile 基础不是很了解，请看我写的这篇文章~</a></li></ul><p data-pid="W0tC3tfl">Dockerfile：用来构建镜像的文档，文档内容包含了一条构建镜像所需要的命令和说明。可以认为是创建一个虚拟机时，对操作的一个。</p><p data-pid="N4vwDOs0">可以基于Dockerfile来定义整个容器镜像。包括容器的基础镜像、中间件、可运行的文件等。</p><p data-pid="JDS7a9uM"><code>docker build</code>命令会依次读取并运行 Dockerfile 中的命令，把这些命令转换成一个真实的容器镜像。</p><p data-pid="lzbRP8UW"><b>通常一个容器镜像分为2部分：</b></p><ol><li data-pid="JyDzocEz">描述文件（元数据）</li><li data-pid="XujBaHil">二进制文件</li></ol><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>理解构建上下文 (build context)</b></h3><p data-pid="lwsVTENF">我们在阅读源码的时候，经常看到 build context，不管是 sealer、sealos、Kubernetes、k3s……</p><ul><li data-pid="ya04YgEz">当运<code>docker build</code>命令时，<b>当前工作目录被称为构建上下文</b></li><li data-pid="UEKryFjG"><code>docker build</code>默认查找当前目录的<code>Dockerfile</code>作构造输入，也可以通过<code>-f</code>参数指定<code>Dockerfile</code><br> docker build -f ./Dockerfile</li><li data-pid="bwZ2VceH">当<code>docker build</code>运行时，首先会把构建上下文传给docker daemon，把没有用的文件包包含在构建上下文中，会导致传播时间长，构建需要的资源架构出鞄鲧<br></li><ul><li data-pid="Nmv-y2uY">可以通过<code>.dockerignore</code>文件从构建上下文中排除某些文件</li></ul></ul><p class="ztext-empty-paragraph"><br></p><ul><li data-pid="MyeIeyvv">因此需要确保构建上文清晰，比如创建一个专门的目录放Dockerfile，并在目录中运行<code>docker build</code></li></ul><p class="ztext-empty-paragraph"><br></p><h3><b>构建缓存(Build Cache)</b></h3><p data-pid="NPrVzTP6">镜像构建日志：使用<code>docker build</code>命令构建镜像时，打印每一步(每一层或Dockerfile中的每一条指令)执行过程的输出内容。通过日志可以知道构建的每一个步骤.</p><p data-pid="ZRysTjJP">注意日志中的<code>Using cache</code>的部分，即构建缓存。</p><div class="highlight"><pre><code class="language-bash"> <span class="c1"># docker build $GOPATH/src/httpServer</span>
 Sending build context to Docker daemon  7.228MB
 Step 1/9 : FROM ubuntu
  ---&gt; ba6acccedd29
 Step 2/9 : ENV <span class="nv">MY_SERVICE_PORT</span><span class="o">=</span><span class="m">80</span>
  ---&gt; Using cache
  ---&gt; 08b186233bb0
 ......</code></pre></div><p data-pid="ZmTZXO9z">Docker <b>从上往下读取指令后</b>，会先判别存储中是否有可用的已存储镜像，只有已存储镜像不存在时，才会重新构建。否则重复使用(reuse)已存储镜像。</p><ul><li data-pid="j0Gtvyls">通常Docker简单判定Dockerfile中的命令与镜像</li><li data-pid="rafO3TTD">指针<code>ADD</code>和<code>COPY</code>命令，Docker判断应该镜像层每个被复制的文件的内容并生成一个checksum（校验和），与现有镜像比较时，比较的是二方的校验和</li><li data-pid="BDFm16df">其他指令，比如<code>RUN apt-get -y update</code>，Docker简单比较与现有镜像中的指令字符串是否一致</li><li data-pid="uAUPOkpM">当某一层cache失效后，所有层级的cache均一并失效，后续指令都重新构建镜像<br>因此，在构建镜像时，应该尽量把<b>很久才更新一次的(或者可以说不动的)层放在下面，把频繁更新的层放在上面</b>。用于防止一个层缓存失效后，该层之上所有的层都缓存失效的问题。<br>⚠️ 再多解释一下，就是那些 不稳定 的命令写在前面（在下层），那些 稳当 的写在后面（在上层），符合构建策略~</li></ul><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>多段构建(Multi-stage build)</b></h3><p data-pid="YJRFkfxi">有一种场景，我来描述一下：</p><blockquote data-pid="uUnMA860">我们构建一个业务，需要很多依赖包，正常情况下 我们 去拉取、构建、但是我们可能只需要最后一个内容或者文件，所以中间很多依赖我们可能需要去清理、删除。<br><b>场景</b>：此时需编译一个容器镜像，该容器镜像中运行一个GO语言编写的进程，请以最终运行该进程的镜像体积尽可能小为目标，编译容器镜像。<br>GO语言的项目通常有<code>vendor/</code>目录，因此编译时需要拉取第三方依赖包。需要注意的是,此时拉取的是第三方包的源代码，拉取之后才能完成项目的编译工作/但最终容器镜像需要的并不是这些源码，仅仅是编译之后的二进制文件，可是编译的过程又会把源代码拉取到本地,这些源代码会影响最终编译出来的镜像的体积。因此需要多段构建~<br><b>多段构建</b>: 在1个Dockerfile中，指定多个要构建的镜像。其中一个镜像(为方便描述称该镜像为镜像A)用于编译项目，将编译好的二进制文件放到指定的目录；另一个镜像用于运行该二进制文件(为方便描述称该镜像为镜像B)。镜像B从镜像A指定的目录中将二进制文件复制到镜像B中，并运行该二进制文件。<br>所以中间有很多没必要的依赖包，比如说我们只需要最后的二进制文件。所以 docker 提供多段构建，分成多个部分：<br> root@docker-test:/home/roach/dockerGoImg# cat Dockerfile <br> # 编译用镜像<br> ARG GO_VERSION=1.17.6<br> # 命名编译用镜像为builder<br> FROM golang:${GO_VERSION} as builder<br> RUN mkdir -p /go/src/test<br> WORKDIR /go/src/test<br> COPY main.go .<br> RUN go mod init testGoProject<br> RUN CGO_ENABLED=0 GOOS=linux go build -o app .<br> ​<br> # 运行用镜像<br> FROM alpine:latest<br> RUN apk --no-cache add ca-certificates<br> WORKDIR /root/<br> # 从镜像builder处复制文件<br> COPY --from=builder /go/src/test/app .<br> CMD ["./app"]<br><b>我们把临时的 都放在 早期 <code>golang:${GO_VERSION} as builder</code></b><br><b>真正需要的放在 <code>app</code> 二进制文件放在后面 ~</b></blockquote><p class="ztext-empty-paragraph"><br></p><h3><b>Dockerfile 最佳实践建议</b></h3><ul><li data-pid="RJXhrBnP">不要安装无效软件包</li><li data-pid="J_eo2wBw">应简化镜像中同时运行的进程数，理想状况下，每个镜像应该只有1个进程<br></li><ul><li data-pid="8rLv15yF">这样利于管理容器：当把一个传统巨石架构的应用移植到容器平台时，想要一下就成为这种1个容器运行1个进程的架构是比较困难的。经常会有一些伴生的进程，所以这只是指导原则，当做不到的时候，也会把多个进程放在同一个容器中，这时就要选择合理的初始化进程.</li></ul></ul><p class="ztext-empty-paragraph"><br></p><ul><li data-pid="N50d8r4E">当无法避免同一镜像运行多进程时，应选择合理的初始化进程(init process)</li><li data-pid="ondiUZJl">最小化层级数<br></li><ul><li data-pid="kwtIQHrG">最新的docker只有<code>RUN</code>、<code>COPY</code>、<code>ADD</code>指令会创建新的层，其他指令创建的是临时层，不会影响最终镜像的大小<br></li><ul><li data-pid="tCNYvtbn">比如<code>EXPOSE</code>指令就不会生成新的层</li></ul></ul></ul><p class="ztext-empty-paragraph"><br></p><ul><ul><li data-pid="x75hbQ9H">通过多段构建减少镜像层数</li><li data-pid="Xd9PBOSf">将命令用<code>&amp;&amp;</code>连接起来，仅执行1条<code>RUN</code>指令，可以减少层数</li></ul></ul><p class="ztext-empty-paragraph"><br></p><ul><li data-pid="RtWDd-kK">把多行参数按字母排序，可以减少可能出现的重复参数，并且提高可读性</li><li data-pid="HmoDVU5O">编写Dockerfile时，应该把变更频率低的编译指令优先构建，以便放在镜像底层，这样能够有效利用构建缓存(build cache)</li><li data-pid="smxXuT04">复制文件时，每个文件应独立复制，这确保某个文件变更时，只影响文件对应的缓存</li></ul><p data-pid="no-zW4-i"><b>目标:易管理、少漏洞、镜像小、层级少、利用缓存</b></p><p class="ztext-empty-paragraph"><br></p><h3><b>多进程的容器镜像</b></h3><p data-pid="bT3yZuNh">一般来说，都是推荐单进程的，毕竟根据 namespace 原理，一个进程对应一个 app。</p><p data-pid="1oZr_3Qq">但是总会有依赖的，也就是多进程。</p><p data-pid="ZjDo0wXT">推荐应该选择适当的init进程</p><ul><li data-pid="WU0sLfcc">需要捕获SIGTERM信号并完成子进程的优雅终止</li><li data-pid="R_sR6wQH">负责清理退出的子进程以避免僵尸进程</li></ul><p data-pid="hmJ1Pcvv">这方面上如果做的不好,就会出现很大问题:</p><p data-pid="zYUuOjWR">当Kubernetes要去终止一个进程时，会发送一个SIGTERM终止信号给容器，以便容器能够优雅退出。但如果容器这一侧做的不够好，就会出现问题。</p><p data-pid="lx3PdUaM">比如容器中有一个初始化进程（init），用于拉起主进程。则来自Kubernetes的SIGTERM信号发送到初始化进程时，初始化进程并没有把信号传递给主进程，而是直接把这个信号给无视了。这样应用就失去了优雅终止的可能性，最终应用只能被<code>kill -9</code>，有可能导致业务故障。</p><p data-pid="2BsZN2rM">或许这时候你应该需要 <a href="https://github.com/krallin/tini" target="_blank">Tini</a> - 小巧但适用<code>init</code>于容器，<code>init</code>Tini 是您能想到的最简单的。</p><p data-pid="M4V0LB_V">Tini 所做的只是生成一个子进程（Tini 应该在容器中运行），并等待它退出，同时收割僵尸并执行信号转发。</p><p class="ztext-empty-paragraph"><br></p><h3><b>docker tag 与 GitHub 的版本管理</b></h3><p data-pid="UuNAj6gY"><b>以Kuberbetes为例：</b></p><ul><li data-pid="MZdcpClE">开发分支<br></li><ul><li data-pid="ej-gPtXl"><code>git checkout master</code></li></ul></ul><p class="ztext-empty-paragraph"><br></p><ul><li data-pid="3BFpieOe">Release分支<br></li><ul><li data-pid="bIO2xEbj"><code>git checkout -b release-1.21</code></li></ul></ul><p class="ztext-empty-paragraph"><br></p><ul><li data-pid="i4jpYevy">在并行期，所有变更同时进<code>master</code>和<code>release branch</code></li><li data-pid="387JAQdL">版本发布<br></li><ul><li data-pid="dWDBNzZ9">以 <code>release branch</code>为基础构建镜像,并为镜像标记版本信息</li><li data-pid="vMHKwBZN"><code>docker tag 93b6fb6b8635 k8s.io/kubernetes.apiserver:v1.21</code></li></ul></ul><p class="ztext-empty-paragraph"><br></p><ul><li data-pid="V9Pp27cW">在github中保存<code>release</code>代码快照<br></li><ul><li data-pid="dFIrdBne"><code>git tag v1.21</code></li></ul></ul><p class="ztext-empty-paragraph"><br></p><blockquote data-pid="8OUtJeLN">此时 标签 就对上了</blockquote><p class="ztext-empty-paragraph"><br></p><h3><b>docker 私有仓库</b></h3><p data-pid="J9AEZkyZ">如今私有仓库几乎是企业必备的需求，而且以前 docker 基础提高过：</p><p data-pid="HngIqzmI">在 <a href="https://docker.nsddd.top/Cloud-Native-k8s/15.html#%E7%A7%81%E6%9C%89%E4%BB%93%E5%BA%93" target="_blank">k3s 教程中</a> 我们补充过 Kubernetes 、 k3s 私有注册表的配置，我们再提一提：</p><ul><li data-pid="o2HT20u8">docker hub : <a href="https://hub.docker.com/" target="_blank">https://hub.docker.com</a></li></ul><blockquote data-pid="8NmCwrWl">docker 官方镜像有 <a href="https://docker.nsddd.top/" target="_blank">文档，之前做过笔记</a>  就不提了</blockquote><p data-pid="TT9jMVMX"><b>查看 registry 私有镜像仓库：</b></p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic4.zhimg.com/v2-10a6065bb1f380658215c405edc70a87_r.jpg" data-caption="" data-size="normal" width="2196" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p data-pid="B4YM-_5o"><b>使用registry镜像创建私有仓库：</b></p><div class="highlight"><pre><code class="language-bash"> docker run -d -p 宿主机端口:容器端口 registry:TAG</code></pre></div><p data-pid="ZYNRfXA-">运行官方提供的<code>registry</code>镜像。(注：官方建议<code>TAG</code>为2)，你还需要的参数：</p><ul><li data-pid="898XVgbG"><code>-v</code>，<code>--volume</code>：挂载宿主机上的文件卷到容器内。仓库默认被创建在容器的<code>/var/lib/registry</code>目录下。可使用该参数指定镜像文件存放的路径.</li></ul><p class="ztext-empty-paragraph"><br></p><h3><b>案例</b></h3><div class="highlight"><pre><code class="language-bash"> ❯ <span class="nb">export</span> <span class="nv">REG</span><span class="o">=</span><span class="s2">"/opt/data/registry"</span>
 ❯ mkdir -p <span class="nv">$REG</span><span class="p">;</span><span class="nb">cd</span> <span class="nv">$REG</span>
 ❯ docker run -d -p 5003:5000 -v <span class="nv">$REG</span>:/var/lib/registry registry:2
 30c6d0d0ac384d60f72c04e6fb479fab6baeb20fe64790248896b139b591e20a</code></pre></div><p data-pid="cSGtOblu"><b>查看结果：</b></p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic4.zhimg.com/v2-376934c717b5b5cf14445139b92c97e3_r.jpg" data-caption="" data-size="normal" width="2330" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>管理私有仓库</b></h3><p data-pid="pfEV0HXe">我当前的环境：</p><ul><li data-pid="v3gk6BUy">搭建私有仓库虚拟机 Ubuntu-master01：<code>192.168.137.133</code></li><li data-pid="o6fJZQVw">私有仓库端口如上：<code>5003</code></li><li data-pid="iDt5tBs-">另一台客户机，虚拟机地址：<code>192.168.137.134</code></li></ul><p class="ztext-empty-paragraph"><br></p><p data-pid="nIyZsjWP"><b>在客户机上拉取镜像<code>ubuntu:18.04</code></b></p><div class="highlight"><pre><code class="language-bash"> <span class="c1"># docker pull ubuntu:18.04</span></code></pre></div><p class="ztext-empty-paragraph"><br></p><p data-pid="VqJG-vQT"><b>在客户机上使用<code>docker tag</code>命令,将该镜像标记为<code>192.168.137.133:5003/test</code></b></p><div class="highlight"><pre><code class="language-bash"> <span class="c1"># docker tag ubuntu:18.04 192.168.137.133:5003/test</span></code></pre></div><p class="ztext-empty-paragraph"><br></p><p data-pid="N96S68zw"><b>在客户机上添加信任的私有仓库列表</b></p><div class="highlight"><pre><code class="language-bash"> <span class="c1"># cat /etc/docker/daemon.json </span>
 <span class="o">{</span>
     <span class="s2">"registry-mirrors"</span>: <span class="o">[</span><span class="s2">"https://sb6xpp51.mirror.aliyuncs.com"</span><span class="o">]</span>,
     <span class="s2">"insecure-registries"</span>: <span class="o">[</span>
         <span class="s2">"192.168.137.133:5003"</span>
     <span class="o">]</span>
 <span class="o">}</span></code></pre></div><p class="ztext-empty-paragraph"><br></p><p data-pid="EKXQqBON"><b>在客户机上使用<code>docker push</code>上传标记的镜像</b></p><div class="highlight"><pre><code class="language-bash"> <span class="c1"># docker push 192.168.137.133:5003/test</span></code></pre></div><p class="ztext-empty-paragraph"><br></p><p data-pid="qeLZE151"><b>在客户机上使用<code>curl</code>查看仓库<code>192.168.0.152:5000</code>中的镜像</b></p><div class="highlight"><pre><code class="language-bash"> <span class="c1"># curl -XGET http://192.168.137.133:5003/v2/_catalog</span>
 <span class="o">{</span><span class="s2">"repositories"</span>:<span class="o">[</span><span class="s2">"test"</span><span class="o">]}</span></code></pre></div><p class="ztext-empty-paragraph"><br></p><p data-pid="qOx1olbi"><b>在客户机上删除打过TAG的镜像,以便后续测试拉取</b></p><div class="highlight"><pre><code class="language-bash"> <span class="c1"># docker images</span>
 <span class="c1"># docker rmi 192.168.137.133:5003/test</span>
 <span class="c1"># docker images</span>
 ​
 <span class="c1"># docker pull 192.168.137.133:5003/test</span>
 <span class="c1"># docker images</span></code></pre></div><p class="ztext-empty-paragraph"><br></p><h2><b>END 链接</b></h2><ul><li data-pid="7zFiBQpB"><a href="typora://app/README.md" target="_blank">Ⓜ️回到目录 </a></li><li data-pid="XX2iA18P"><b><a href="https://nsddd.top/archives/contributors" target="_blank"> 参与贡献 ❤️‍  </a></b>)</li><li data-pid="XAeNb2mT">✴️版权声明 © ：本书所有内容遵循<a href="http://zh.wikipedia.org/wiki/Wikipedia:CC-by-sa-3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank">CC-BY-SA 3.0协议（署名-相同方式共享）©</a> </li></ul><p></p></div> </details> 
 <hr /> 

 #### - [Go 语言的 Makefile 指南](https://zhuanlan.zhihu.com/p/607940899) 
 <details><summary>توضیحات</summary> <p><img src="https://picx.zhimg.com/v2-4958b319ed9a86053ff64b2cfd7f5632_720w.jpg?source=d16d100b"></p><div><ul><li data-pid="fiPV0jmO"><a href="https://github.com/cubxxw/iam" target="_blank">  开源地址</a></li></ul><h2><b>第7节 高质量的Makefile</b></h2><blockquote data-pid="pDL3hfQ5">❤️  During the winter vacation, I followed up and learned two projects: tiktok project and IAM project, and summarized and practiced the CloudNative project and Go language. I learned a lot in the process.Myblog:<a href="http://nsddd.top/" target="_blank">http://nsddd.top</a></blockquote><h2><b>低质量的makefile</b></h2><p data-pid="S6RQdQlP">低质量的 Makefile 文件是什么样的;</p><div class="highlight"><pre><code class="language-text"> ​
 build: clean vet
   @mkdir -p ./Role
   @export GOOS=linux &amp;&amp; go build -v .
 ​
 vet:
   go vet ./...
 ​
 fmt:
   go fmt ./...
 ​
 clean:
   rm -rf dashboard</code></pre></div><p data-pid="4-Av-3CE">上面这个 Makefile 存在不少问题。例如：功能简单，只能完成最基本的编译、格式化等操作，像构建镜像、自动生成代码等一些高阶的功能都没有；扩展性差，没法编译出可在 Mac 下运行的二进制文件；没有 Help 功能，使用难度高；单 Makefile 文件，结构单一，不适合添加一些复杂的管理功能。</p><p data-pid="ilb9Y8za">所以，我们不光要编写 Makefile，还要编写高质量的 Makefile。那么如何编写一个高质量的 Makefile 呢？我觉得，可以通过以下 4 个方法来实现：</p><ul><li data-pid="t_q4uHDU">打好基础，也就是熟练掌握 <code>Makefile</code> 的语法。</li><li data-pid="rDi2DQE9">做好准备工作，也就是提前规划 <code>Makefile</code> 要实现的功能。</li><li data-pid="igHAaUnH">进行规划，设计一个合理的 <code>Makefile</code> 结构。</li><li data-pid="0buN8nEy">掌握方法，用好 <code>Makefile</code> 的编写技巧。</li></ul><p class="ztext-empty-paragraph"><br></p><h2><b>makefile 如何工作</b></h2><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic1.zhimg.com/v2-eeb128713961264aca17ebb0ff296744_r.jpg" data-caption="" data-size="normal" width="1344" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><p data-pid="0EI3qKPv"><b>makefile规则：</b></p><div class="highlight"><pre><code class="language-bash"> target ... : prerequisites ...
     <span class="nb">command</span>
     ...
     ...</code></pre></div><ul><li data-pid="Y7xRbjLF"><b>target</b><br></li><ul><li data-pid="w8H1Tuo-">可以是一个object file（目标文件），也可以是一个执行文件，还可以是一个标签（label）。对于标签这种特性，在后续的“伪目标”章节中会有叙述。</li></ul></ul><p class="ztext-empty-paragraph"><br></p><ul><li data-pid="CPhVxgmf"><b>prereqisites</b><br></li><ul><li data-pid="bzizLq4R">生成该target所依赖的文件和/或target</li></ul></ul><p class="ztext-empty-paragraph"><br></p><ul><li data-pid="nAHdMmmg"><b>command</b><br></li><ul><li data-pid="uORF_cRM">该target要执行的命令（任意的shell命令）</li></ul></ul><p class="ztext-empty-paragraph"><br></p><blockquote data-pid="rqdWyqsM">prerequisites中如果有一个以上的文件比target文件要新的话，command所定义的命令就会被执行。</blockquote><p class="ztext-empty-paragraph"><br></p><h3><b>Build and Run</b></h3><p data-pid="EwTjYDgX"><b>首先两个特别频繁的指令加进去：</b></p><div class="highlight"><pre><code class="language-bash"> build: 
     go build -o stringifier main.go
 ​
 run:
     go run -race main.gobuild: </code></pre></div><p data-pid="uLhECrjh">我在运行命令中添加了<code>-race</code>标志，方便它在运行时在Go代码中检测到<code>race</code>情况。</p><p class="ztext-empty-paragraph"><br></p><h3><b>Cleaning and DRYing</b></h3><p data-pid="ECF1Y7In">构建二进制文件并运行应用程序后，一切正常, 确保我们在执行其他任何操作之前先清理二进制文件。我们更新<code>Makefile</code>应该看起来像这样：</p><div class="highlight"><pre><code class="language-go"> <span class="nx">clean</span><span class="p">:</span>
     <span class="k">go</span> <span class="nx">clean</span><span class="p">:</span>
</code></pre></div><p data-pid="Z35yoEq3"><b>我们有两点可以改进</b>:</p><ol><li data-pid="Y3yQ30VM">我们明确地重用了我们的应用程序名, 很自然我们的应用程序名称将在整个<code>Makefile</code>中的许多地方使用。</li><li data-pid="Lljt60Kq">每次构建应用之前，我们需要先执行<code>clean</code>的规则。</li></ol><p data-pid="7s7kyQKq"><b>改进后的<code>Makefile</code></b></p><div class="highlight"><pre><code class="language-text"> APP=stringifier
 ​
 build: clean
     go build -o ${APP} main.go
 ​
 run:
     go run -race main.go
 ​
 clean:
     go clean</code></pre></div><p data-pid="L1L0fLzo"><b>更新</b>: 这个例子之前使用的<code>rm -r ${APP}</code>，现在使用<code>go clean</code>。</p><p data-pid="l-D09IZU">在顶部定义<code>Makefile</code>变量，当您调用<code>make</code>命令时make将自动引用它们，这样<code>Makefile</code>看起来就更整洁、规范了。</p><p class="ztext-empty-paragraph"><br></p><h3><b>PHONY targets</b></h3><p data-pid="ISFQmuEH">在 Makefile 中，<code>.PHONY</code> 是一个特殊的目标（target），它用于定义那些不表示实际文件的伪目标（phony target）。</p><p data-pid="kqAFuSza">当 Makefile 执行时，它会检查定义的目标是否已经存在或是否需要更新。对于伪目标，由于它们不表示任何实际文件，因此 Makefile 无法检查它们是否已经存在或是否需要更新。为了避免误判，<b>可以使用 <code>.PHONY</code> 来明确告诉 Makefile 哪些目标是伪目标，以便在执行时跳过对这些目标的检查。</b></p><p data-pid="VHVqXYIv">例如，假设 Makefile 中定义了一个 clean 目标用于删除生成的文件，但是 clean 并不表示任何实际的文件，只是一个伪目标。那么，为了确保 Makefile 在执行时不会将 clean 当成一个文件来检查，可以在 Makefile 中添加如下声明：</p><div class="highlight"><pre><code class="language-text"> .PHONY: clean
 ​
 clean:
     rm -f *.o myprogram</code></pre></div><blockquote data-pid="FoeR5CQk">这样，当执行 "make clean" 命令时，Makefile 会跳过对 clean 目标的文件检查，直接执行清理命令。同时，如果我们在 Makefile 中定义了一个与 clean 相同名字的文件，Makefile 也不会将其与 clean 目标混淆。因此，使用 <code>.PHONY</code> 声明伪目标可以提高 Makefile 的可读性和可靠性。</blockquote><p data-pid="6Y9geE4k"><b>默认情况下</b>，如果一个前置条件或是目录文件已更改，<code>make</code>将执行规则。但是由于我们不依赖于<code>make</code>来检测文件更改的能力，因此我们会遇到潜在的麻烦。</p><p data-pid="k5P1CRbp">假设我们的项目目录中有一个名为 <code>build</code> 的文件, 在这个场景下，当你执行<code>make build</code>, make一定会检查文件build的更改，由于没有前置条件，因此将始终将<code>build</code>文件视为最新的，并且不会执行其规则定义的操作。</p><p data-pid="t3DvUhYo">为了避免这个问题，你需要先知道<code>.PHONY</code> 特殊目录(target)是什么意思：<b>特殊目标<code>.PHONY</code>的先决条件被视为phony目标（targets)。 当需要运行时，make会无条件运行其规则，而不管该名称的文件是否存在或其最后修改时间是多少。</b></p><p data-pid="TDaJ_yvn">所以，你可以通过将目标（target）指定为特殊目标<code>.PHONY</code>的先决条件，将目标指定为<code>.PHONY</code>。</p><div class="highlight"><pre><code class="language-text"> APP=stringifier
 ​
 .PHONY: build
 build: clean
     go build -o ${APP} main.go
 ​
 .PHONY: run
 run:
     go run -race main.go
 ​
 .PHONY: clean
 clean:
     go clean</code></pre></div><p data-pid="f9gtaCbI">现在你已将上述所有的<code>targets</code>指定为<code>phony</code>, 每次你调用任何<code>phony</code>目标（target) 时，make将会执行相应的规则。你还可以一次将所有要指定为<code>phony</code>的目标指定为:</p><div class="highlight"><pre><code class="language-text"> .PHONY: build clean run</code></pre></div><p data-pid="CU0g9v7o">但是对于非常大的Makefile，不建议这样做因为这可能导致歧义和无法读取。因此，首选方法是在规则定义之前显式设置<code>phony</code>目标（target）。</p><p class="ztext-empty-paragraph"><br></p><h3><b>Recursive Make targets</b></h3><p data-pid="nmTg7yDE">当 Makefile 包含多个目标时，我们可以在 Makefile 中使用递归 Make 来构建这些目标。递归 Make 指的是在 Makefile 中调用另一个 Makefile 来构建其中的目标。</p><p data-pid="Z9D92nzG">在递归 Make 中，通常有一个顶层 Makefile，该 Makefile 调用其他 Makefile 来构建子目录中的目标。这样的 Makefile 被称为 "递归 Makefile"，而由这个 Makefile 调用的 Makefile 被称为 "子 Makefile"。</p><p data-pid="StErajZq">在递归 Make 中，每个子 Makefile 负责构建它所在的目录中的目标，然后将构建的结果返回给父 Makefile。递归 Make 的一个常见的问题是，当在子目录中调用 Make 命令时，可能会破坏父目录中的变量设置和规则，因此需要小心地设置变量和规则，以避免不必要的冲突。</p><p data-pid="630aYW_T">递归 Make 的一种常见用法是使用一个称为“递归变量”的特殊变量。递归变量的值可以包含调用另一个 Makefile 的命令，这个命令会返回一个值，可以被递归变量使用。递归变量在递归 Make 中非常有用，因为它们可以帮助子 Makefile 获得父 Makefile 中的变量值。</p><p data-pid="1pKZKdGL">例如，我们可以在项目的根目录下创建一个名为 "Makefile" 的文件，其内容如下：</p><div class="highlight"><pre><code class="language-text">codeSUBDIRS = foo bar baz

.PHONY: all $(SUBDIRS)

all: $(SUBDIRS)

$(SUBDIRS):
    $(MAKE) -C $@</code></pre></div><p data-pid="0A5r8EQc">在上面的 Makefile 中，"SUBDIRS" 变量定义了项目的子目录名称。"all" 是一个伪目标，它将调用每个子目录中的 Makefile 来构建所有目标。</p><p data-pid="EjuSvr3e">$(SUBDIRS) 是一个自动变量，它会展开为 "foo bar baz"。因此，当我们运行 "make all" 命令时，它将首先调用 "make foo"，然后在 "foo" 目录中运行 "make" 命令来构建 "foo" 目录中的目标。接着它会依次调用 "make bar" 和 "make baz" 命令，以此类推。</p><p data-pid="3PvPSzJ8">在子目录的 Makefile 中，我们可以使用和普通 Makefile 中一样的规则和变量定义来构建子目录中的目标。这种方式可以帮助我们轻松地管理复杂的项目，避免代码重复，并提高 Makefile 的可重用性。</p><p data-pid="PDT_7LLW">现在让我们假设我们在项目中使用的根目录中还有另一个模块<code>tokenizer</code>。现在我们的目录结构是这样的：</p><div class="highlight"><pre><code class="language-bash"> ~/programming/stringifier
 .
 ├── main.go
 ├── Makefile
 └── tokenizer/
       ├── main.go
       └── Makefile~/programming/stringifier</code></pre></div><p data-pid="UG6ViVYp">很自然，某些时候我们也想<code>build</code>和<code>test</code>我们的<code>tokenizer</code>模块。由于它是一个独立的模块也可能是一个独立的项目，在它的目录有如下内容的一个<code>Makefile</code>是很有必要的：</p><div class="highlight"><pre><code class="language-text"> # ~/programming/stringifier/tokenizer/Makefile
 ​
 APP=tokenizer
 ​
 build:
     go build -o ${APP} main.go</code></pre></div><p data-pid="-TDc9eVw">现在只要您在<code>stringifier</code>项目的根目录中并且想要构建<code>tokenizer</code>应用程序，你不会想使用诸如<code>cd tokenizer &amp;&amp; make build &amp;&amp; cd -</code>这样的易受攻击的命令行技巧，而具体的<code>Makefiles</code>的规则写在子目录中的方式。幸运的是，<code>make</code>可以帮助你解决这个问题。你可以使用<code>-C</code>标志和特殊的<code>${NAME}</code>变量在其他目录中调用<code>make targets</code>。下面是<code>stringifies</code>项目最初的Makefile:</p><div class="highlight"><pre><code class="language-text"># ~/programming/stringifier/Makefile

APP=stringifier


.PHONY: build
build: clean
	go build -o ${APP} main.go

.PHONY: run
run:
	go run -race main.go

.PHONY: clean
clean:
	go clean

.PHONY: build-tokenizer
build-tokenizer:
	${MAKE} -C tokenizer build</code></pre></div><p data-pid="Qc15moAn">现在只要你运行<code>make build-tokenizer</code>，<code>make</code>都将为您处理目录切换，并以更加可读和健壮的方式为您调用正确目录中的正确目标</p><p data-pid="l8lZpOW0"><b><code>-c</code> 标志和特殊的 <code>${NAME}</code>:</b></p><ol><li data-pid="YMUjha0C"><code>-C</code> 标志：指定 Makefile 文件的目录，让 make 命令在指定的目录下执行 Makefile 文件。例如：<br> all:<br>  cd subdir &amp;&amp; $(MAKE)<br>上述 Makefile 中的 <code>$(MAKE)</code> 命令会在当前目录下的 <code>subdir</code> 目录中执行 Makefile 文件。可以使用 <code>-C</code> 标志来达到同样的效果：<br> all:<br>  $(MAKE) -C subdir</li><li data-pid="kzAY92si"><code>${NAME}</code> 变量：在 Makefile 中使用 <code>${NAME}</code> 变量可以引用环境变量中的值，例如：<br> all:<br>  echo "PATH is ${PATH}"<br>上述 Makefile 中的 <code>${PATH}</code> 变量会展开为当前系统环境变量中的 <code>PATH</code> 值。</li></ol><p data-pid="42udb5yH">以下是一个用 Go 语言编写的 Makefile 示例，其中使用了 <code>-C</code> 标志和 <code>${NAME}</code> 变量：</p><div class="highlight"><pre><code class="language-text"> # Makefile
 ​
 APP_NAME := my-app
 ​
 .PHONY: build
 build:
     cd cmd/my-app &amp;&amp; go build -o ../../bin/$(APP_NAME)
 ​
 .PHONY: test
 test:
     go test ./...
 ​
 .PHONY: clean
 clean:
     rm -rf bin/*
 ​
 .PHONY: build-docker
 build-docker: build
     docker build -t $(APP_NAME) .
 ​
 .PHONY: run-docker
 run-docker: build-docker
     docker run -p 8080:8080 $(APP_NAME)
 ​
 .PHONY: deploy
 deploy: build-docker
     ssh ${SSH_USER}@${SSH_HOST} "docker pull $(APP_NAME); docker stop $(APP_NAME) || true; docker rm $(APP_NAME) || true; docker run -p 8080:8080 -d --name $(APP_NAME) $(APP_NAME)"</code></pre></div><p data-pid="WzZeJMl2">上述 Makefile 中，<code>build-docker</code>、<code>run-docker</code> 和 <code>deploy</code> 等目标中使用了 <code>${APP_NAME}</code> 变量来指定 Docker 镜像的名称，同时使用了 <code>-C</code> 标志来在子目录中执行命令，例如 <code>build</code> 目标中的 <code>cd cmd/my-app &amp;&amp; go build</code> 命令。</p><p class="ztext-empty-paragraph"><br></p><h3><b>Targets for Docker commands</b></h3><p data-pid="vpxJnXA9">现在您希望对应用程序进行容器化，然后为方便起见编写make目标，这是完全可以理解的。</p><p data-pid="e7KkV8KM">你为docker命令定义了如下规则：</p><div class="highlight"><pre><code class="language-text"> .PHONY: docker-build
 docker-build: build
     docker build -t stringifier .
     docker tag stringifier stringifier:tag
 ​
 .PHONY: docker-push
 docker-push: docker-build
     docker push gcr.io/stringifier/stringifier-staging/stringifier:tag</code></pre></div><p data-pid="ovXzDlzD">docker命令基本满足需要，但是还有改善的空间，</p><ul><li data-pid="gRVGKT2I">对于新手，你可以再次重用你的<code>${APP}</code>变量。</li><li data-pid="QvCcflfM">接下来，您想要更灵活并确保可以轻松控制将映像推送到哪里，无论是您的私人镜像仓库还是其他地方。</li><li data-pid="E4iNtjoo">然后，您希望能够根据用户在命令行上的某些输入将镜像（image）分别推送到与预生产和生产环境有关的两个单独的镜像仓库中。</li><li data-pid="sG4Ng4B5">最后，像一个理智的开发人员一样，您想使用当前的git commit sha标记您的镜像（image）。 让我们基于这些问题重新修改下<code>Makefile</code>：</li></ul><div class="highlight"><pre><code class="language-text"> APP?=application
 REGISTRY?=gcr.io/images
 COMMIT_SHA=$(shell git rev-parse --short HEAD)
 ​
 .PHONY: docker-build
 docker-build: build
     docker build -t ${APP} .
     docker tag ${APP} ${APP}:${COMMIT_SHA}
 ​
 .PHONY: docker-push
 docker-push: check-environment docker-build
     docker push ${REGISTRY}/${ENV}/${APP}:${COMMIT_SHA}
 ​
 check-environment:
 ifndef ENV
     $(error ENV not set, allowed values - `staging` or `production`)
 endif</code></pre></div><p data-pid="JZbGXJRz">现在，让我们回顾下上面的更改：</p><ul><li data-pid="GBdw_Jbw">你开始为应用程序名称，镜像名称,提交sha使用变量。</li><li data-pid="g1DUcKxh">您使用特殊的shell函数生成了commit sha。 在这种情况下，您运行了git命令，该命令返回了简短的提交sha，并将其分配给变量<code>${COMMIT_SHA}</code>，以便稍后在Makefile中使用。</li><li data-pid="J7A3Pg_d">您添加了一个新的规则<code>check-environment</code>，该环境使用make条件检查在调用make时是否指定了<code>ENV</code>变量，这有助于区分预生产及生产环境。</li></ul><p data-pid="GrLGyvRc"><code>check-environment</code>的规则如下：</p><div class="highlight"><pre><code class="language-text">check-environment:
ifndef ENV
    $(error ENV not set, allowed values - `staging` or `production`)
endif</code></pre></div><p data-pid="-fpqxPVF">使用<code>ifndef</code>指令检查变量ENV是否为空值，如果存在，则使用另一个make的提供内置函数，如果出错了，将会在关键字之后抛出具体的错误消息。</p><div class="highlight"><pre><code class="language-text">$ make docker-push
Makefile:33: *** ENV not set, allowed values - `staging` or `production`.  Stop.

$ ENV=staging make docker-push
Success</code></pre></div><p data-pid="fBWWNguc">本质上，您要确保docker-push目标具有安全保障，该保障可检查调用目标的用户是否已为ENV变量指定值。</p><p class="ztext-empty-paragraph"><br></p><h3><b>@ 符号</b></h3><p data-pid="J3wXSORh">项目的 <code>makefile</code> 中很容易看到 @ 符号的存在，它的意义不同寻常：</p><div class="highlight"><pre><code class="language-text">## build: Build source code for host platform.
.PHONY: build
build:
	@$(MAKE) go.build</code></pre></div><p data-pid="phgbOQzc">在Makefile中，@符号用于 <b>抑制Make命令的输出</b>。当在Makefile中使用@符号时，<b>Make将不会打印出该行命令的输出结果，而是仅仅执行该命令。</b></p><p data-pid="2yfB_Lp2">在Go语言项目中，我们通常使用Makefile来构建和管理项目。下面是一个简单的Go语言项目Makefile示例：</p><div class="highlight"><pre><code class="language-text"># 编译二进制文件
build:
    @go build -o myapp main.go

# 运行程序
run:
    @./myapp

# 清理
clean:
    @rm -f myapp</code></pre></div><p data-pid="MSGh7bv3">在上面的示例中，我们定义了三个Makefile命令：<code>build</code>，<code>run</code>和<code>clean</code>。在每个命令的前面，我们都使用了<code>@</code>符号来抑制命令的输出。这意味着，当我们在命令行中运行<code>make build</code>时，Make命令将会编译Go程序，但不会将编译器的输出打印到终端。</p><p data-pid="0ofjiVSG">如果我们去掉<code>@</code>符号，那么当我们运行<code>make build</code>时，Make将会输出编译器的输出，类似于下面的结果：</p><div class="highlight"><pre><code class="language-bash">go build -o myapp main.go
<span class="c1"># 输出编译器的输出</span></code></pre></div><p data-pid="4pSQ56Br">因此，使用<code>@</code>符号可以使Makefile输出更加干净，仅仅打印出我们关心的内容，而不会输出一堆不必要的信息。</p><p class="ztext-empty-paragraph"><br></p><h3><b>文件搜索 VPATH</b></h3><p data-pid="RC69DX7o">在一些大的工程中，有大量的源文件，我们通常的做法是把这许多的源文件分类，并存放在不同的目录中。所以，当make需要去找寻文件的依赖关系时，你可以在文件前加上路径，但最好的方法是把一个路径告诉make，让make在自动去找。</p><p data-pid="_OA6cjEv">Makefile文件中的特殊变量 <code>VPATH</code> 就是完成这个功能的，如果没有指明这个变量，make只会在当前的目录中去找寻依赖文件和目标文件。如果定义了这个变量，那么，make就会在当前目录找不到的情况下，到所指定的目录中去找寻文件了。</p><div class="highlight"><pre><code class="language-bash"><span class="nv">VPATH</span> <span class="o">=</span> src:../headers</code></pre></div><p data-pid="1YvEU-Ku">上面的定义指定两个目录，“src”和“<code>../headers</code>”，<code>make</code>会按照这个顺序进行搜索。目录由“冒号”分隔。（当然，当前目录永远是最高优先搜索的地方）</p><p data-pid="T6OS02lp">另一个设置文件搜索路径的方法是使用make的“vpath”关键字（注意，它是全小写的），这不是变量，这是一个make的关键字，这和上面提到的那个VPATH变量很类似，但是它更为灵活。它可以指定不同的文件在不同的搜索目录中。这是一个很灵活的功能。它的使用方法有三种：</p><div class="highlight"><pre><code class="language-text">vpath &lt;pattern&gt; &lt;directories&gt;</code></pre></div><p data-pid="xY04Dgjf">为符合模式<code>&lt;pattern&gt;</code>的文件指定搜索目录<code>&lt;directories&gt;</code>。</p><div class="highlight"><pre><code class="language-text">vpath &lt;pattern&gt;</code></pre></div><p data-pid="kD8Vdn4w">清除符合模式<code>&lt;pattern&gt;</code>的文件的搜索目录。</p><div class="highlight"><pre><code class="language-text">vpath</code></pre></div><p data-pid="7jR4jQWu">清除所有已被设置好了的文件搜索目录。</p><p class="ztext-empty-paragraph"><br></p><h3><b>Help target</b></h3><p data-pid="3f59kEwp">一个新成员加入了该项目并想知道Makefile中所有规则的作用，为帮助它们您可以添加一个新目标(target)，该目标将打印所有目标名称以及它们作用的简短描述:</p><div class="highlight"><pre><code class="language-text"> .PHONY: build
 ## build: build the application
 build: clean
     @echo "Building..."
     @go build -o ${APP} main.go
 ​
 .PHONY: run
 ## run: runs go run main.go
 run:
     go run -race main.go
 ​
 .PHONY: clean
 ## clean: cleans the binary
 clean:
     @echo "Cleaning"
     @go clean
 ​
 .PHONY: setup
 ## setup: setup go modules
 setup:
     @go mod init \
         &amp;&amp; go mod tidy \
         &amp;&amp; go mod vendor
     
 .PHONY: help
 ## help: prints this help message
 help:
     @echo "Usage: \n"
     @sed -n 's/^##//p' ${MAKEFILE_LIST} | column -t -s ':' |  sed -e 's/^/ /'</code></pre></div><p data-pid="9w2gzfmI">你先注意下最后一条规则，<code>help</code> 在这里，您只是使用一些sed魔术来解析和在命令行上打印。 但是要做到这一点，您必要在每条规则之前写了目标名称和简短描述作为注释。 注意另一个特殊变量<code>$ {MAKEFILE_LIST}</code>，它是您所引用的所有Makefile的列表，在本例中仅是Makefile。</p><p data-pid="5kC0CZql">您会将文件Makefile作为输入传递给sed命令，该命令将解析所有帮助注释并以表格格式将其打印到stdout，以便于阅读。 上一个代码段的<code>help</code>目标的输出如下所示：</p><div class="highlight"><pre><code class="language-text"> $ make help
 Usage:
     build             Build the application
     clean             cleans the binary
     run               runs go run main.go
     docker-build      builds docker image
     docker-push       pushes the docker image
     setup             set up modules
     help              prints this help message</code></pre></div><p data-pid="Ja5DuU_n">这些消息很有帮助，对于其他人甚至有时对自己都是一个不错的提示。</p><h3><b>Conclusion 结论</b></h3><p data-pid="nUoBtcMn">Make是一个简单但可高度配置的工具。 在本文中，您遍历了make提供的许多配置和功能，从而为Go应用程序编写了有效而高效的Makefile。</p><p data-pid="appneEHT">下面是完整的Makefile，其中添加了一些琐碎的规则和变量：</p><div class="highlight"><pre><code class="language-text"> GO111MODULES=on
 APP?=stringifier
 REGISTRY?=gcr.io/images
 COMMIT_SHA=$(shell git rev-parse --short HEAD)
 ​
 ​
 ​
 .PHONY: build
 ## build: build the application
 build: clean
     @echo "Building..."
     @go build -o ${APP} main.go
 ​
 .PHONY: run
 ## run: runs go run main.go
 run:
     go run -race main.go
 ​
 .PHONY: clean
 ## clean: cleans the binary
 clean:
     @echo "Cleaning"
     @go clean
 ​
 .PHONY: test
 ## test: runs go test with default values
 test:
     go test -v -count=1 -race ./...
 ​
 ​
 .PHONY: build-tokenizer
 ## build-tokenizer: build the tokenizer application
 build-tokenizer:
     ${MAKE} -c tokenizer build
 ​
 .PHONY: setup
 ## setup: setup go modules
 setup:
     @go mod init \
         &amp;&amp; go mod tidy \
         &amp;&amp; go mod vendor
     
 # helper rule for deployment
 check-environment:
 ifndef ENV
     $(error ENV not set, allowed values - `staging` or `production`)
 endif
 ​
 .PHONY: docker-build
 ## docker-build: builds the stringifier docker image to registry
 docker-build: build
     docker build -t ${APP}:${COMMIT_SHA} .
 ​
 .PHONY: docker-push
 ## docker-push: pushes the stringifier docker image to registry
 docker-push: check-environment docker-build
     docker push ${REGISTRY}/${ENV}/${APP}:${COMMIT_SHA}
 ​
 .PHONY: help
 ## help: Prints this help message
 help:
     @echo "Usage: \n"
     @sed -n 's/^##//p' ${MAKEFILE_LIST} | column -t -s ':' |  sed -e 's/^/ /'</code></pre></div><p class="ztext-empty-paragraph"><br></p><h2><b>熟练makefile语法</b></h2><p data-pid="L7lObUSD"><b>IAM 项目的 Makefile 文件：</b></p><div class="highlight"><pre><code class="language-bash"> $ make <span class="nb">help</span>
 ​
 Usage: make &lt;TARGETS&gt; &lt;OPTIONS&gt; ...
 ​
 Targets:
   <span class="c1"># 代码生成类命令</span>
   gen                Generate all necessary files, such as error code files.
 ​
   <span class="c1"># 格式化类命令</span>
   format             Gofmt <span class="o">(</span>reformat<span class="o">)</span> package sources <span class="o">(</span>exclude vendor dir <span class="k">if</span> existed<span class="o">)</span>.
 ​
   <span class="c1"># 静态代码检查</span>
   lint               Check syntax and styling of go sources.
 ​
   <span class="c1"># 测试类命令</span>
   <span class="nb">test</span>               Run unit test.
   cover              Run unit <span class="nb">test</span> and get <span class="nb">test</span> coverage.
 ​
   <span class="c1"># 构建类命令</span>
   build              Build <span class="nb">source</span> code <span class="k">for</span> host platform.
   build.multiarch    Build <span class="nb">source</span> code <span class="k">for</span> multiple platforms. See option PLATFORMS.
 ​
   <span class="c1"># Docker镜像打包类命令</span>
   image              Build docker images <span class="k">for</span> host arch.
   image.multiarch    Build docker images <span class="k">for</span> multiple platforms. See option PLATFORMS.
   push               Build docker images <span class="k">for</span> host arch and push images to registry.
   push.multiarch     Build docker images <span class="k">for</span> multiple platforms and push images to registry.
 ​
   <span class="c1"># 部署类命令</span>
   deploy             Deploy updated components to development env.
 ​
   <span class="c1"># 清理类命令</span>
   clean              Remove all files that are created by building.
 ​
   <span class="c1"># 其他命令，不同项目会有区别</span>
   release            Release iam
   verify-copyright   Verify the boilerplate headers <span class="k">for</span> all files.
   ca                 Generate CA files <span class="k">for</span> all iam components.
   install            Install iam system with all its components.
   swagger            Generate swagger document.
   tools              install dependent tools.
 ​
   <span class="c1"># 帮助命令</span>
   <span class="nb">help</span>               Show this <span class="nb">help</span> info.
 ​
 <span class="c1"># 选项</span>
 Options:
   DEBUG        Whether to generate debug symbols. Default is 0.
   BINS         The binaries to build. Default is all of cmd.
                This option is available when using: make build/build.multiarch
                Example: make build <span class="nv">BINS</span><span class="o">=</span><span class="s2">"iam-apiserver iam-authz-server"</span>
   ...</code></pre></div><p data-pid="vfp8h6Tl">通常而言，Go 项目的 Makefile 应该实现以下功能：格式化代码、静态代码检查、单元测试、代码构建、文件清理、帮助等等。如果通过 docker 部署，还需要有 docker 镜像打包功能。因为 Go 是跨平台的语言，所以构建和 docker 打包命令，还要能够支持不同的 CPU 架构和平台。为了能够更好地控制 Makefile 命令的行为，还需要支持 Options。</p><p data-pid="hamIbf53"><b>为了方便查看 Makefile 集成了哪些功能，我们需要支持 help 命令。help 命令最好通过解析 Makefile 文件来输出集成的功能，例如：</b></p><div class="highlight"><pre><code class="language-bash"> <span class="c1">## help: Show this help info.</span>
 .PHONY: <span class="nb">help</span>
 help: Makefile
   @echo -e <span class="s2">"\nUsage: make &lt;TARGETS&gt; &lt;OPTIONS&gt; ...\n\nTargets:"</span>
   @sed -n <span class="s1">'s/^##//p'</span> $descriptionlt; <span class="p">|</span> column -t -s <span class="s1">':'</span> <span class="p">|</span> sed -e <span class="s1">'s/^/ /'</span>
   @echo <span class="s2">"</span><span class="nv">$</span><span class="s2">USAGE_OPTIONS"</span></code></pre></div><p data-pid="F2Rc04Ec">上面的 help 命令，通过解析 Makefile 文件中的 <code>##</code> 注释，获取支持的命令。通过这种方式，我们以后新加命令时，就不用再对 help 命令进行修改了。</p><p class="ztext-empty-paragraph"><br></p><h3><b>常用的 Makefile 核心语法</b></h3><p data-pid="7jQLJrY8">大多数的 make 都支持“makefile”和“Makefile”这两种文件名，但我建议使用“Makefile”。因为这个文件名第一个字符大写，会很明显，容易辨别。make 也支持 <code>-f</code> 和 <code>--file</code> 参数来指定其他文件名，比如 <code>make -f golang.mk</code> 或者 <code>make --file golang.mk</code> 。</p><p class="ztext-empty-paragraph"><br></p><h3><b>makefile 支持的通配符</b></h3><p data-pid="D5792Y3x">Makefile 支持三种类型的通配符，他们是：<code>*，? 和~</code></p><ol><li data-pid="JpxUXvty"><b><code>*</code>通配符：</b></li></ol><p data-pid="1_rRhDCo">*通配符代表任意长度的字符序列，可以匹配任意长度的文件名或路径名中的任意字符。例如，可以使用以下规则来匹配所有.c文件：</p><div class="highlight"><pre><code class="language-text"> SRCS := $(wildcard *.c)</code></pre></div><p data-pid="l_6_l0JF">这条规则将会将当前目录下所有以.c为后缀的文件名赋值给变量SRCS，使得我们可以方便地引用这些文件。</p><ol><li data-pid="FtWFcxIb"><b><code>?</code>通配符：</b></li></ol><p data-pid="P9PBGT4d">?通配符代表任意单个字符，可以匹配任意长度的文件名或路径名中的一个字符。例如，可以使用以下规则来匹配所有三个字符长的<code>.txt</code>文件：</p><div class="highlight"><pre><code class="language-text"> SRCS := $(wildcard ???.txt)</code></pre></div><p data-pid="Cx0V0x39">这条规则将会将当前目录下所有文件名长度为3，并以.txt为后缀的文件名赋值给变量SRCS。</p><ol><li data-pid="OWmElElS"><b><code>~</code>通配符：</b></li></ol><p data-pid="2wyzmWTa">~通配符代表当前用户的<code>home</code>目录，可以用来指定文件路径。例如，可以使用以下规则来指定当前用户的<code>home</code>目录：</p><div class="highlight"><pre><code class="language-text"> $(HOME)/myprogram</code></pre></div><p data-pid="AxzQQUHb">这条规则将会将当前用户的home目录路径和myprogram字符串拼接起来，从而得到一个完整的路径名，使得我们可以方便地引用home目录下的文件或路径。</p><p class="ztext-empty-paragraph"><br></p><h3><b>变量</b></h3><p data-pid="DZXZw_dD">变量，可能是 Makefile 中使用最频繁的语法了，Makefile 支持变量赋值、多行变量和环境变量。另外，Makefile 还内置了一些特殊变量和自动化变量。</p><p data-pid="iHBFTTpL"><b>变量赋值 ：</b></p><p data-pid="TrMcPDz5">Makefile 也可以像其他语言一样支持变量。在使用变量时，会像 shell 变量一样原地展开，然后再执行替换后的内容。</p><p data-pid="emz7Xz43">Makefile 可以通过变量声明来声明一个变量，变量在声明时需要赋予一个初值，比如<code>ROOT_PACKAGE=github.com/marmotedu/iam</code>。</p><p data-pid="1N-vD9ZF">引用变量时可以通过<code>$()</code>或者<code>${}</code>方式引用。我的建议是，用<code>$()</code>方式引用变量，例如<code>$(ROOT_PACKAGE)</code>，也建议整个 makefile 的变量引用方式保持一致。</p><p data-pid="CmHM6m6f">变量会像 bash 变量一样，在使用它的地方展开。比如：</p><div class="highlight"><pre><code class="language-bash"> <span class="nv">GO</span><span class="o">=</span>go
 build:
     <span class="k">$(</span>GO<span class="k">)</span> build -v .</code></pre></div><p data-pid="FtD4xDh7">展开后为：</p><div class="highlight"><pre><code class="language-bash"> <span class="nv">GO</span><span class="o">=</span>go
 build:
     go build -v .</code></pre></div><p class="ztext-empty-paragraph"><br></p><p data-pid="2zKsKZAB"><b>Makefile 有四种的赋值方式：</b></p><p data-pid="yzoBuEty"><b><code>=</code> 最基本的赋值方法。</b></p><div class="highlight"><pre><code class="language-bash"> <span class="nv">BASE_IMAGE</span> <span class="o">=</span> alpine:3.10</code></pre></div><blockquote data-pid="9GEakcMR">  注意：使用 <code>=</code> 赋值的时候，取值到的并非是程序依次执行的值，而是最终的值<br> A = a<br> B = $(A) b<br> A = c<br>B 最后的值为 c b，而不是 a b。也就是说，在用变量给变量赋值时，右边变量的取值，取的是最终的变量值。</blockquote><p class="ztext-empty-paragraph"><br></p><p data-pid="3Gb22eys"><b>和go一样，<code>:=</code>直接赋值，赋予当前位置的值。</b></p><div class="highlight"><pre><code class="language-bash"> <span class="nv">A</span> <span class="o">=</span> a
 B :<span class="o">=</span> <span class="k">$(</span>A<span class="k">)</span> b
 <span class="nv">A</span> <span class="o">=</span> c</code></pre></div><p data-pid="09-kGacM">B 最后的值为 a b。通过 <code>:=</code> 的赋值方式，可以避免 <code>=</code> 赋值带来的潜在的不一致。</p><p class="ztext-empty-paragraph"><br></p><p data-pid="rPDHU9Tg"><b><code>?=</code> 表示如果该变量没有被赋值，则赋予等号后的值。</b></p><p data-pid="pFfR_ojm"><b>例如：</b></p><div class="highlight"><pre><code class="language-bash"> PLATFORMS ?<span class="o">=</span> linux_amd64 linux_arm64</code></pre></div><p class="ztext-empty-paragraph"><br></p><p data-pid="o39hu3q5"><b><code>+=</code>表示将等号后面的值添加到前面的变量上。</b></p><div class="highlight"><pre><code class="language-text"> MAKEFLAGS += --no-print-directory</code></pre></div><p class="ztext-empty-paragraph"><br></p><p data-pid="fuKjYtb6"><b>Makefile 还支持多行变量。可以通过 define 关键字设置多行变量，变量中允许换行。定义方式为：</b></p><div class="highlight"><pre><code class="language-text"> define 变量名
 变量内容
 ...
 endef</code></pre></div><p data-pid="mQ010vzs">变量的内容可以包含函数、命令、文字或是其他变量。例如，我们可以定义一个 <code>USAGE_OPTIONS</code> 变量：</p><div class="highlight"><pre><code class="language-text"> define USAGE_OPTIONS
 ​
 Options:
   DEBUG        Whether to generate debug symbols. Default is 0.
   BINS         The binaries to build. Default is all of cmd.
   ...
   V            Set to 1 enable verbose build. Default is 0.
 endef</code></pre></div><p data-pid="643yZ3OK">Makefile 还支持环境变量。在 Makefile 中，有两种环境变量，分别是 Makefile 预定义的环境变量和自定义的环境变量。</p><p data-pid="zPSAtjBs">其中，自定义的环境变量可以覆盖 Makefile 预定义的环境变量。默认情况下，Makefile 中定义的环境变量只在当前 Makefile 有效，如果想向下层传递（Makefile 中调用另一个 Makefile），需要使用 export 关键字来声明。</p><div class="highlight"><pre><code class="language-text"> ...
 export USAGE_OPTIONS
 ...</code></pre></div><p data-pid="LAZ3Pg-G">此外，Makefile 还支持两种内置的变量：特殊变量和自动化变量。</p><p data-pid="vYHzbShP">特殊变量是 make 提前定义好的，可以在 makefile 中直接引用。特殊变量列表如下：</p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic3.zhimg.com/v2-9ed11d1238b122c740fbc98004fc7d0a_r.jpg" data-caption="" data-size="normal" width="1088" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p data-pid="ABFKfYlr">Makefile 还支持自动化变量。自动化变量可以提高我们编写 Makefile 的效率和质量。</p><p class="ztext-empty-paragraph"><br></p><p data-pid="T3PoHw5W"><b>自动化变量：</b></p><p data-pid="t-mgkuOC">这时就可以用到自动化变量。所谓自动化变量，就是这种变量会把模式中所定义的一系列的文件自动地挨个取出，一直到所有符合模式的文件都取完为止。这种自动化变量只应出现在规则的命令中。Makefile 中支持的自动化变量见下表。</p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic1.zhimg.com/v2-4f89913ab376925632be5823a038f938_b.png" data-caption="" data-size="normal" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p data-pid="dJvvMAiF">上面这些自动化变量中，<code>$*</code>是用得最多的。<code>$*</code> 对于构造有关联的文件名是比较有效的。如果目标中没有模式的定义，那么 <code>$*</code> 也就不能被推导出。但是，如果目标文件的后缀是 make 所识别的，那么 <code>$*</code> 就是除了后缀的那一部分。例如：如果目标是 <code>foo.c</code> ，因为.c 是 make 所能识别的后缀名，所以 <code>$*</code> 的值就是 foo。</p><p class="ztext-empty-paragraph"><br></p><p data-pid="gisX26_q"><b>条件语句：</b></p><p data-pid="REakl9xg">Makefile 也支持条件语句。这里先看一个示例。</p><p data-pid="6lF91iHT">下面的例子判断变量ROOT_PACKAGE是否为空，如果为空，则输出错误信息，不为空则打印变量值：</p><div class="highlight"><pre><code class="language-text"> ifeq ($(ROOT_PACKAGE),)
 $(error the variable ROOT_PACKAGE must be set prior to including golang.mk)
 else
 $(info the value of ROOT_PACKAGE is $(ROOT_PACKAGE))
 endif</code></pre></div><p data-pid="UoCpSCQG">条件语句的语法为：</p><div class="highlight"><pre><code class="language-text"> ​
 # if ...
 &lt;conditional-directive&gt;
 &lt;text-if-true&gt;
 endif
 # if ... else ...
 &lt;conditional-directive&gt;
 &lt;text-if-true&gt;
 else
 &lt;text-if-false&gt;
 endif</code></pre></div><p data-pid="d351dwoO">例如，判断两个值是否相等：</p><div class="highlight"><pre><code class="language-text"> ​
 ifeq 条件表达式
 ...
 else
 ...
 endif</code></pre></div><ul><li data-pid="e33gCHQ5">ifeq 表示条件语句的开始，并指定一个条件表达式。表达式包含两个参数，参数之间用逗号分隔，并且表达式用圆括号括起来。</li><li data-pid="-bhDIuSo">else 表示条件表达式为假的情况。</li><li data-pid="-w-UyBTC">endif 表示一个条件语句的结束，任何一个条件表达式都应该以 endif 结束。</li><li data-pid="3TnLKu94">表示条件关键字，有 4 个关键字：ifeq、ifneq、ifdef、ifndef。</li></ul><p class="ztext-empty-paragraph"><br></p><p data-pid="73-aYRYe"><b>为了加深你的理解，我们分别来看下这 4 个关键字的例子。</b></p><p data-pid="KUYwxMLs">ifeq：条件判断，判断是否相等。</p><div class="highlight"><pre><code class="language-text"> ifeq (&lt;arg1&gt;, &lt;arg2&gt;)
 ifeq '&lt;arg1&gt;' '&lt;arg2&gt;'
 ifeq "&lt;arg1&gt;" "&lt;arg2&gt;"
 ifeq "&lt;arg1&gt;" '&lt;arg2&gt;'
 ifeq '&lt;arg1&gt;' "&lt;arg2&gt;"</code></pre></div><p data-pid="313LsmOa">比较 arg1 和 arg2 的值是否相同，如果相同则为真。也可以用 make 函数 / 变量替代 arg1 或 arg2，例如 <code>ifeq ($(origin ROOT_DIR),undefined)</code>或 <code>ifeq ($(ROOT_PACKAGE),)</code> 。origin 函数会在之后专门讲函数的一讲中介绍到。</p><p class="ztext-empty-paragraph"><br></p><p data-pid="vWwv9fz9">ifneq：条件判断，判断是否不相等。</p><div class="highlight"><pre><code class="language-text"> ifneq (&lt;arg1&gt;, &lt;arg2&gt;)
 ifneq '&lt;arg1&gt;' '&lt;arg2&gt;'
 ifneq "&lt;arg1&gt;" "&lt;arg2&gt;"
 ifneq "&lt;arg1&gt;" '&lt;arg2&gt;'
 ifneq '&lt;arg1&gt;' "&lt;arg2&gt;"</code></pre></div><p data-pid="zZIJrw1Q">比较 arg1 和 arg2 的值是否不同，如果不同则为真。</p><p class="ztext-empty-paragraph"><br></p><p data-pid="3z3DsMOK">ifdef：条件判断，判断变量是否已定义。</p><div class="highlight"><pre><code class="language-text"> ifdef &lt;variable-name&gt;</code></pre></div><p data-pid="NmW-DS0t">如果值非空，则表达式为真，否则为假。也可以是函数的返回值。</p><p class="ztext-empty-paragraph"><br></p><p data-pid="hVdaV5QO">ifndef：条件判断，判断变量是否未定义。</p><div class="highlight"><pre><code class="language-text"> ifndef &lt;variable-name&gt;</code></pre></div><p data-pid="SWWVm1yd">如果值为空，则表达式为真，否则为假。也可以是函数的返回值。</p><p class="ztext-empty-paragraph"><br></p><h3><b>函数</b></h3><p data-pid="0GQB5eJE">我们先来看下自定义函数。 make 解释器提供了一系列的函数供 Makefile 调用，这些函数是 Makefile 的预定义函数。我们可以通过 define 关键字来自定义一个函数。自定义函数的语法为：</p><div class="highlight"><pre><code class="language-text"> define 函数名
 函数体
 endef</code></pre></div><p class="ztext-empty-paragraph"><br></p><p data-pid="62zchQRR"><b> 简单的一个案例如下：</b></p><div class="highlight"><pre><code class="language-text"> ​
 define Foo
     @echo "my name is $(0)"
     @echo "param is $(1)"
 endef</code></pre></div><p data-pid="EfMXh6oV">define 本质上是定义一个多行变量，可以在 call 的作用下当作函数来使用，在其他位置使用只能作为多行变量来使用，例如：</p><div class="highlight"><pre><code class="language-text"> var := $(call Foo)
 new := $(Foo)</code></pre></div><p class="ztext-empty-paragraph"><br></p><p data-pid="B5uLtrkT"><b>预定义函数：</b></p><p data-pid="j3hSoGN7">再来看下预定义函数。 刚才提到，make 编译器也定义了很多函数，这些函数叫作预定义函数，调用语法和变量类似，语法为：</p><div class="highlight"><pre><code class="language-text"> $(&lt;function&gt; &lt;arguments&gt;)
 OR
 ${&lt;function&gt; &lt;arguments&gt;}</code></pre></div><p data-pid="bevLq7As"><code>&lt;function&gt;</code> 是函数名，<code>&lt;arguments&gt;</code> 是函数参数，参数间用逗号分割。函数的参数也可以是变量。</p><p data-pid="qtnri8pU"> 简单的一个案例如下：</p><div class="highlight"><pre><code class="language-text"> PLATFORM = linux_amd64
 GOOS := $(word 1, $(subst _, ,$(PLATFORM)))</code></pre></div><p data-pid="ep1d2VOY">上面的例子用到了两个函数：word 和 subst。word 函数有两个参数，1 和 subst 函数的输出。subst 函数将 PLATFORM 变量值中的 <code>_</code> 替换成空格（替换后的 PLATFORM 值为 linux amd64）。word 函数取 linux amd64 字符串中的第一个单词。所以最后 GOOS 的值为 linux。</p><p data-pid="xo9RlDp_">Makefile 预定义函数能够帮助我们实现很多强大的功能，在编写 Makefile 的过程中，如果有功能需求，可以优先使用这些函数。如果你想使用这些函数，那就需要知道有哪些函数，以及它们实现的功能。</p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic4.zhimg.com/v2-af2f23e70bf4b9ee2f2a0106aa6695db_r.jpg" data-caption="" data-size="normal" width="2248" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>引入其他 Makefile</b></h3><p data-pid="WYoNyHCn">在 Makefile 中，我们可以通过关键字 include，把别的 makefile 包含进来，类似于 C 语言的#include，被包含的文件会插入在当前的位置。include 用法为include ，示例如下：</p><div class="highlight"><pre><code class="language-text"> include scripts/make-rules/common.mk
 include scripts/make-rules/golang.mk</code></pre></div><p data-pid="29BZA9ne">include 也可以包含通配符include scripts/make-rules/*。make 命令会按下面的顺序查找 makefile 文件：</p><ul><li data-pid="_kZ6nU2N">如果是绝对或相对路径，就直接根据路径 include 进来。</li><li data-pid="Yefv1vAt">如果 make 执行时，有<code>-I</code>或<code>--include-dir</code>参数，那么 make 就会在这个参数所指定的目录下去找。</li><li data-pid="jlY63DaJ">如果目录<code>&lt;prefix&gt;/include</code>（一般是/usr/local/bin或/usr/include）存在的话，make 也会去找。</li></ul><p data-pid="RoVGF37U">如果有文件没有找到，make 会生成一条警告信息，但不会马上出现致命错误，而是继续载入其他的文件。一旦完成 makefile 的读取，make 会再重试这些没有找到或是不能读取的文件。如果还是不行，make 才会出现一条致命错误信息。如果你想让 <code>make</code> 忽略那些无法读取的文件继续执行，可以在 i<code>n</code>clude 前加一个减号<code>-</code>，如<code>-include</code> 。</p><p class="ztext-empty-paragraph"><br></p><h2><b>设计Makefile结构</b></h2><p data-pid="dY7VVxoM">对于大型项目来说，需要管理的内容很多，所有管理功能都集成在一个 Makefile 中，可能会导致 Makefile 很大，难以阅读和维护，所以建议采用分层的设计方法，<b>根目录下的 Makefile 聚合所有的 Makefile 命令，具体实现则按功能分类，放在另外的 Makefile 中。</b></p><p data-pid="0YyHhYEz">我们经常会在 Makefile 命令中集成 shell 脚本，但如果 shell 脚本过于复杂，也会导致 Makefile 内容过多，难以阅读和维护。并且在 Makefile 中集成复杂的 shell 脚本，编写体验也很差。对于这种情况，<b>可以将复杂的 shell 命令封装在 shell 脚本中，供 Makefile 直接调用，而一些简单的命令则可以直接集成在 Makefile 中。</b></p><p data-pid="QxtLelvn"><b>推荐的 Makefile 结构：</b></p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic2.zhimg.com/v2-daa7206fcb284e3da98e7d00c96854b9_r.jpg" data-caption="" data-size="normal" width="1088" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><p data-pid="SHPB7cJZ">在上面的 Makefile 组织方式中，根目录下的 Makefile 聚合了项目所有的管理功能，这些管理功能通过 Makefile 伪目标的方式实现。同时，还将这些伪目标进行分类，把相同类别的伪目标放在同一个 Makefile 中，这样可以使得 Makefile 更容易维护。对于复杂的命令，则编写成独立的 shell 脚本，并在 Makefile 命令中调用这些 shell 脚本。</p><p data-pid="yi0M2dun">举个例子，下面是 IAM 项目的 Makefile 组织结构：</p><div class="highlight"><pre><code class="language-bash"> ​
 ├── Makefile
 ├── scripts
 │   ├── gendoc.sh
 │   ├── make-rules
 │   │   ├── gen.mk
 │   │   ├── golang.mk
 │   │   ├── image.mk
 │   │   └── ...
     └── ...
 ├── Makefile
 ├── scripts
 │   ├── gendoc.sh
 │   ├── make-rules
 │   │   ├── gen.mk
 │   │   ├── golang.mk
 │   │   ├── image.mk
 │   │   └── ...
     └── ...</code></pre></div><p data-pid="GGF2YbBD">我们将相同类别的操作统一放在 <code>scripts/make-rules</code> 目录下的 Makefile 文件中。<b>Makefile 的文件名参考分类命名</b>，例如 <code>golang.mk</code>。最后，在 <code>/Makefile</code> 中 include 这些 Makefile。</p><blockquote data-pid="XbC5AgVh">需要使用 <code>include</code> 来获取头文件：<br><code>include</code>是一种指令，用于将另一个文件中的规则和变量导入到当前的makefile中。这样做可以让你的makefile更加模块化，易于维护和重用。<br><b>注意和我们上面讲的模块化分配 Makefile 层级调用有些不一样。</b><br>下面是一个include的案例，假设我们有一个名为<code>main.c</code>的源文件，它需要链接一个名为<code>libfoo.a</code>的静态库文件。我们可以将这些规则和变量定义在一个名为<code>Makefile.inc</code>的文件中，然后在我们的主makefile中使用include指令将其导入。<br> CC = gcc<br> CFLAGS = -Wall -Werror -g<br> ​<br> all: libfoo.a<br> ​<br> libfoo.a: foo.o<br>  ar rcs $@ $^<br> ​<br> foo.o: foo.c foo.h<br>  $(CC) $(CFLAGS) -c $descriptionlt;<br> ​<br> clean:<br>  rm -f *.o libfoo.a<br> ​<br>主makefile文件：<br> include Makefile.inc<br> ​<br> main: main.c libfoo.a<br>  $(CC) $(CFLAGS) -o $@ $descriptionlt; -L. -lfoo<br> ​<br> .PHONY: clean<br> clean:<br>  $(MAKE) -C . -f Makefile.inc clean<br>  rm -f main<br><b>go 语言Makefile  简单的一个案例如下：</b><br> # 定义变量<br> GOCMD=go<br> GOBUILD=$(GOCMD) build<br> GOCLEAN=$(GOCMD) clean<br> BINARY_NAME=myapp<br> BINARY_UNIX=$(BINARY_NAME)_unix<br> ​<br> all: deps build<br> build:<br>  $(GOBUILD) -o $(BINARY_NAME) -v<br>  $(GOBUILD) -o $(BINARY_UNIX) -v<br> deps:<br>  $(GOCMD) get -u <a href="http://github.com/golang/dep/cmd/dep" target="_blank"><span class="invisible">http://</span><span class="visible">github.com/golang/dep/c</span><span class="invisible">md/dep</span><span class="ellipsis"></span></a><br>  dep ensure<br> clean:<br>  $(GOCLEAN)<br>  rm -f $(BINARY_NAME)<br>  rm -f $(BINARY_UNIX)<br> run:<br>  $(GOBUILD) -o $(BINARY_NAME) -v ./...<br>  ./$(BINARY_NAME)<br> include docker.mk<br> ​<br>在上面的示例中，最后一行 <code>include docker.mk</code> 引用了名为 <code>docker.mk</code> 的 Makefile 文件。这个文件中可能包含了一些 Docker 相关的命令，比如构建镜像、推送镜像等等。通过 include 指令，这些命令可以被自动引入到主 Makefile 文件中，从而实现更加高效和便捷的编译和构建。<br>需要注意的是，include 指令的作用是将被引入的 Makefile 文件的内容直接复制到主 Makefile 文件中。因此，如果引入的文件中定义了和主 Makefile 文件中相同的变量或者规则，会发生命名冲突。因此，在编写被引入的 Makefile 文件时，应该避免使用和主 Makefile 文件相同的变量和规则名。</blockquote><p data-pid="w8f3MIsd">为了跟 Makefile 的层级相匹配，<code>golang.mk</code> 中的所有目标都按<code>go.xxx</code>这种方式命名。通过这种命名方式，我们可以很容易分辨出某个目标完成什么功能，放在什么文件里，这在复杂的 Makefile 中尤其有用。以下是 IAM 项目根目录下，Makefile 的内容摘录，你可以看一看，作为参考：</p><div class="highlight"><pre><code class="language-text"> include scripts/make-rules/golang.mk
 include scripts/make-rules/image.mk
 include scripts/make-rules/gen.mk
 include scripts/make-rules/...
 ​
 ## build: Build source code for host platform.
 .PHONY: build
 build:
   @$(MAKE) go.build
 ​
 ## build.multiarch: Build source code for multiple platforms. See option PLATFORMS.
 .PHONY: build.multiarch
 build.multiarch:
   @$(MAKE) go.build.multiarch
 ​
 ## image: Build docker images for host arch.
 .PHONY: image
 image:
   @$(MAKE) image.build
 ​
 ## push: Build docker images for host arch and push images to registry.
 .PHONY: push
 push:
   @$(MAKE) image.push
 ​
 ## ca: Generate CA files for all iam components.
 .PHONY: ca
 ca:
   @$(MAKE) gen.ca</code></pre></div><p data-pid="zBdZ-uST">另外，一个合理的 Makefile 结构应该具有前瞻性。也就是说，要在不改变现有结构的情况下，接纳后面的新功能。这就需要你整理好 Makefile 当前要实现的功能、即将要实现的功能和未来可能会实现的功能，然后基于这些功能，利用 Makefile 编程技巧，编写可扩展的 Makefile。</p><p data-pid="nOHEzvcT">这里需要你注意：上面的 Makefile 通过 <code>.PHONY</code> 标识定义了大量的伪目标，定义伪目标一定要加 <code>.PHONY</code> 标识，否则当有同名的文件时，伪目标可能不会被执行。</p><p class="ztext-empty-paragraph"><br></p><h2><b>掌握 Makefile 编写技巧</b></h2><h3><b>技巧 1：善用通配符和自动变量</b></h3><p data-pid="RCSzTOUU">Makefile 允许对目标进行类似正则运算的匹配，主要用到的通配符是%。通过使用通配符，可以使不同的目标使用相同的规则，从而使 Makefile 扩展性更强，也更简洁。</p><p data-pid="tcyHdNv-">我们的 IAM 实战项目中，就大量使用了通配符<code>%</code>，例如：<code>go.build.%</code>、<code>ca.gen.%</code>、<code>deploy.run.%</code>、<code>tools.verify.%</code>、<code>tools.install.%</code>等。</p><p data-pid="IdTRxEPI">这里，我们来看一个具体的例子，<code>tools.verify.%</code>（位于<code>scripts/make-rules/tools.mk</code>文件中）定义如下：</p><div class="highlight"><pre><code class="language-text"> tools.verify.%:
   @if ! which $* &amp;&gt;/dev/null; then $(MAKE) tools.install.$*; fi</code></pre></div><p data-pid="eojjiH1E"><code>make tools.verify.swagger</code>, <code>make tools.verify.mockgen</code>等均可以使用上面定义的规则，%分别代表了<code>swagger</code>和<code>mockgen</code>。</p><p data-pid="azWBSeLQ">如果不使用<code>%</code>，则我们需要分别为<code>tools.verify.swagger</code>和<code>tools.verify.mockgen</code>定义规则，很麻烦，后面修改也困难。</p><p data-pid="PnflaInN">另外，这里也能看出<code>tools.verify.%</code>这种命名方式的好处：tools 说明依赖的定义位于<code>scripts/make-rules/tools.mk</code> Makefile 中；verify说明<code>tools.verify.%</code>伪目标属于 verify 分类，主要用来验证工具是否安装。通过这种命名方式，你可以很容易地知道目标位于哪个 Makefile 文件中，以及想要完成的功能。</p><p data-pid="jwtQ49ag">另外，上面的定义中还用到了自动变量<code>$*</code>，用来指代被匹配的值<code>swagger</code>、<code>mockgen</code>。</p><p class="ztext-empty-paragraph"><br></p><h3><b>技巧 2：善用函数</b></h3><p data-pid="e1wGpdmM">Makefile 自带的函数能够帮助我们实现很多强大的功能。所以，在我们编写 Makefile 的过程中，如果有功能需求，可以优先使用这些函数。我把常用的函数以及它们实现的功能整理在了 <a href="https://github.com/marmotedu/geekbang-go/blob/master/makefile/Makefile%E5%B8%B8%E7%94%A8%E5%87%BD%E6%95%B0%E5%88%97%E8%A1%A8.md" target="_blank">Makefile</a> 常用函数列表 中，你可以参考下。</p><p data-pid="eFwkXNMu">IAM 的 Makefile 文件中大量使用了上述函数，如果你想查看这些函数的具体使用方法和场景，可以参考 IAM 项目的 Makefile 文件 <code>make-rules</code>。</p><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>技巧 3：依赖需要用到的工具</b></h3><p data-pid="QQ56t1cB">如果 Makefile 某个目标的命令中用到了某个工具，可以将该工具放在目标的依赖中。这样，当执行该目标时，就可以指定检查系统是否安装该工具，如果没有安装则自动安装，从而实现更高程度的自动化。例如，<code>/Makefile</code> 文件中，<code>format</code> 伪目标，定义如下：</p><div class="highlight"><pre><code class="language-bash"> .PHONY: format
 format: tools.verify.golines tools.verify.goimports
   @echo <span class="s2">"===========&gt; Formating codes"</span>
   @<span class="k">$(</span>FIND<span class="k">)</span> -type f -name <span class="s1">'*.go'</span> <span class="p">|</span> <span class="k">$(</span>XARGS<span class="k">)</span> gofmt -s -w
   @<span class="k">$(</span>FIND<span class="k">)</span> -type f -name <span class="s1">'*.go'</span> <span class="p">|</span> <span class="k">$(</span>XARGS<span class="k">)</span> goimports -w -local <span class="k">$(</span>ROOT_PACKAGE<span class="k">)</span>
   @<span class="k">$(</span>FIND<span class="k">)</span> -type f -name <span class="s1">'*.go'</span> <span class="p">|</span> <span class="k">$(</span>XARGS<span class="k">)</span> golines -w --max-len<span class="o">=</span><span class="m">120</span> --reformat-tags --shorten-comments --ignore-generated .</code></pre></div><p data-pid="m-s7GsN9">你可以看到，format 依赖<code>tools.verify.golines tools.verify.goimports</code>。我们再来看下<code>tools.verify.golines</code>的定义：</p><div class="highlight"><pre><code class="language-bash"> tools.verify.%:
   @if ! which <span class="nv">$*</span> <span class="p">&amp;</span>&gt;/dev/null<span class="p">;</span> <span class="k">then</span> <span class="k">$(</span>MAKE<span class="k">)</span> tools.install.<span class="nv">$*</span><span class="p">;</span> <span class="k">fi</span></code></pre></div><p class="ztext-empty-paragraph"><br></p><p data-pid="AmE2mRzB">再来看下<code>tools.install.$*</code>规则：</p><div class="highlight"><pre><code class="language-bash">.PHONY: install.golines
install.golines:
  @<span class="k">$(</span>GO<span class="k">)</span> get -u github.com/segmentio/golines</code></pre></div><p data-pid="E-ebLEGL">通过<code>tools.verify.%</code>规则定义，我们可以知道，<code>tools.verify.%</code>会先检查工具是否安装，如果没有安装，就会执行<code>tools.install.$*</code>来安装。如此一来，当我们执行<code>tools.verify.%</code>目标时，如果系统没有安装 golines 命令，就会自动调用go get安装，提高了 Makefile 的自动化程度。</p><p class="ztext-empty-paragraph"><br></p><h3><b>技巧 4：把常用功能放在 /Makefile 中，不常用的放在分类 Makefile 中</b></h3><p data-pid="2MN3yr0x">一个项目，尤其是大型项目，有很多需要管理的地方，其中大部分都可以通过 Makefile 实现自动化操作。不过，为了保持 <code>/Makefile</code> 文件的整洁性，我们不能把所有的命令都添加在 <code>/Makefile</code> 文件中。</p><p data-pid="B02TUDBa">一个比较好的建议是，将常用功能放在 /Makefile 中，不常用的放在分类 Makefile 中，并在 /Makefile 中 include 这些分类 Makefile。</p><p data-pid="DdU9lV_V">例如，IAM 项目的 /Makefile 集成了format、lint、test、build等常用命令，而将<code>gen.errcode.code、gen.errcode.doc</code>这类不常用的功能放在 <code>scripts/make-rules/gen.mk</code> 文件中。当然，我们也可以直接执行 make gen.errcode.code来执行gen.errcode.code伪目标。通过这种方式，既可以保证 /Makefile 的简洁、易维护，又可以通过make命令来运行伪目标，更加灵活。</p><p class="ztext-empty-paragraph"><br></p><h3><b>技巧 5：编写可扩展的 Makefile</b></h3><p data-pid="li2iOoiW">什么叫可扩展的 Makefile 呢？在我看来，可扩展的 Makefile 包含两层含义：</p><ul><li data-pid="pq8XBogm">可以在不改变 Makefile 结构的情况下添加新功能。</li><li data-pid="8MtWbkeD">扩展项目时，新功能可以自动纳入到 Makefile 现有逻辑中。</li></ul><p data-pid="Ai3A7lPZ">其中的第一点，我们可以通过设计合理的 Makefile 结构来实现。要实现第二点，就需要我们在编写 Makefile 时采用一定的技巧，例如多用通配符、自动变量、函数等。这里我们来看一个例子，可以让你更好地理解。</p><p data-pid="vW093qkq">在我们 IAM 实战项目的golang.mk中，执行 <code>make go.build</code> 时能够构建 <code>cmd/</code> 目录下的所有组件，也就是说，当有新组件添加时， <code>make go.build</code> 仍然能够构建新增的组件，这就实现了上面说的第二点。</p><p data-pid="45_pGgNc">具体实现方法如下：</p><div class="highlight"><pre><code class="language-text">COMMANDS ?= $(filter-out %.md, $(wildcard ${ROOT_DIR}/cmd/*))
BINS ?= $(foreach cmd,${COMMANDS},$(notdir ${cmd}))

.PHONY: go.build
go.build: go.build.verify $(addprefix go.build., $(addprefix $(PLATFORM)., $(BINS)))
.PHONY: go.build.%               

go.build.%:             
  $(eval COMMAND := $(word 2,$(subst ., ,$*)))
  $(eval PLATFORM := $(word 1,$(subst ., ,$*)))
  $(eval OS := $(word 1,$(subst _, ,$(PLATFORM))))           
  $(eval ARCH := $(word 2,$(subst _, ,$(PLATFORM))))                         
  @echo "===========&gt; Building binary $(COMMAND) $(VERSION) for $(OS) $(ARCH)"
  @mkdir -p $(OUTPUT_DIR)/platforms/$(OS)/$(ARCH)
  @CGO_ENABLED=0 GOOS=$(OS) GOARCH=$(ARCH) $(GO) build $(GO_BUILD_FLAGS) -o $(OUTPUT_DIR)/platforms/$(OS)/$(ARCH)/$(COMMAND)$(GO_OUT_EXT) $(ROOT_PACKAGE)/cmd/$(COMMAND)
COMMANDS ?= $(filter-out %.md, $(wildcard ${ROOT_DIR}/cmd/*))
BINS ?= $(foreach cmd,${COMMANDS},$(notdir ${cmd}))

.PHONY: go.build
go.build: go.build.verify $(addprefix go.build., $(addprefix $(PLATFORM)., $(BINS)))
.PHONY: go.build.%               

go.build.%:             
  $(eval COMMAND := $(word 2,$(subst ., ,$*)))
  $(eval PLATFORM := $(word 1,$(subst ., ,$*)))
  $(eval OS := $(word 1,$(subst _, ,$(PLATFORM))))           
  $(eval ARCH := $(word 2,$(subst _, ,$(PLATFORM))))                         
  @echo "===========&gt; Building binary $(COMMAND) $(VERSION) for $(OS) $(ARCH)"
  @mkdir -p $(OUTPUT_DIR)/platforms/$(OS)/$(ARCH)
  @CGO_ENABLED=0 GOOS=$(OS) GOARCH=$(ARCH) $(GO) build $(GO_BUILD_FLAGS) -o $(OUTPUT_DIR)/platforms/$(OS)/$(ARCH)/$(COMMAND)$(GO_OUT_EXT) $(ROOT_PACKAGE)/cmd/$(COMMAND)</code></pre></div><p data-pid="26G3nS1D">当执行make go.build 时，会执行 go.build 的依赖 <code>$(addprefix go.build., $(addprefix $(PLATFORM)., $(BINS))</code>) ,<code>addprefix</code>函数最终返回字符串 <code>go.build.linux_amd64.iamctl go.build.linux_amd64.iam-authz-server go.build.linux_amd64.iam-apiserver ...</code> ，这时候就会执行 <code>go.build.%</code> 伪目标。</p><p data-pid="QP4PejWM">在 <code>go.build.%</code> 伪目标中，通过 eval、word、subst 函数组合，算出了 COMMAND 的值 <code>iamctl/iam-apiserver/iam-authz-server/...</code>，最终通过 <code>$(ROOT_PACKAGE)/cmd/$(COMMAND)</code> 定位到需要构建的组件的 main 函数所在目录。</p><p data-pid="b05e1lP1">上述实现中有两个技巧，你可以注意下。首先，通过</p><div class="highlight"><pre><code class="language-bash">COMMANDS ?<span class="o">=</span> <span class="k">$(</span>filter-out %.md, <span class="k">$(</span>wildcard <span class="si">${</span><span class="nv">ROOT_DIR</span><span class="si">}</span>/cmd/*<span class="k">))</span>
BINS ?<span class="o">=</span> <span class="k">$(</span>foreach cmd,<span class="si">${</span><span class="nv">COMMANDS</span><span class="si">}</span>,<span class="k">$(</span>notdir <span class="si">${</span><span class="nv">cmd</span><span class="si">}</span><span class="k">))</span></code></pre></div><p data-pid="12XC7DdV">获取到了 cmd/ 目录下的所有组件名。</p><p data-pid="Pkxzby3P">接着，通过使用通配符和自动变量，自动匹配到<code>go.build.linux_amd64.iam-authz-server</code> 这类伪目标并构建。</p><p data-pid="rT1j2Bg8">可以看到，想要编写一个可扩展的 Makefile，熟练掌握 Makefile 的用法是基础，更多的是需要我们动脑思考如何去编写 Makefile。</p><p class="ztext-empty-paragraph"><br></p><h3><b>技巧 6：将所有输出存放在一个目录下，方便清理和查找</b></h3><p data-pid="5vocGHVI">在执行 Makefile 的过程中，会输出各种各样的文件，例如 Go 编译后的二进制文件、测试覆盖率数据等，我建议你把这些文件统一放在一个目录下，方便后期的清理和查找。通常我们可以把它们放在<code>_output</code>这类目录下，这样清理时就很方便，只需要清理<code>_output</code>文件夹就可以，例如：</p><div class="highlight"><pre><code class="language-bash">.PHONY: go.clean
go.clean:
  @echo <span class="s2">"===========&gt; Cleaning all build output"</span>
  @-rm -vrf <span class="k">$(</span>OUTPUT_DIR<span class="k">)</span></code></pre></div><p data-pid="NbQpvBRG">这里要注意，要用<code>-rm</code>，而不是rm，防止在没有<code>_output</code>目录时，执行<code>make go.clean</code>报错。</p><p class="ztext-empty-paragraph"><br></p><h3><b>技巧 7：使用带层级的命名方式</b></h3><p data-pid="ki6QWccY">通过使用带层级的命名方式，例如<code>tools.verify.swagger</code> ，我们可以实现目标分组管理。这样做的好处有很多。首先，当 Makefile 有大量目标时，通过分组，我们可以更好地管理这些目标。其次，分组也能方便理解，可以通过组名一眼识别出该目标的功能类别。最后，这样做还可以大大减小目标重名的概率。</p><p data-pid="JYHrAL6f">例如，IAM 项目的 Makefile 就大量采用了下面这种命名方式。</p><div class="highlight"><pre><code class="language-text">.PHONY: gen.run
gen.run: gen.clean gen.errcode gen.docgo

.PHONY: gen.errcode
gen.errcode: gen.errcode.code gen.errcode.doc

.PHONY: gen.errcode.code
gen.errcode.code: tools.verify.codegen
    ...
.PHONY: gen.errcode.doc
gen.errcode.doc: tools.verify.codegen
    ...</code></pre></div><p class="ztext-empty-paragraph"><br></p><h3><b>技巧 8：做好目标拆分</b></h3><p data-pid="-GiXknO-">还有一个比较实用的技巧：我们要合理地拆分目标。比如，我们可以将安装工具拆分成两个目标：验证工具是否已安装和安装工具。通过这种方式，可以给我们的 Makefile 带来更大的灵活性。例如：我们可以根据需要选择性地执行其中一个操作，也可以两个操作一起执行。</p><p data-pid="Ei3ztFZi">这里来看一个例子：</p><div class="highlight"><pre><code class="language-text">gen.errcode.code: tools.verify.codegen

tools.verify.%:    
  @if ! which $* &amp;&gt;/dev/null; then $(MAKE) tools.install.$*; fi  

.PHONY: install.codegen
install.codegen:              
  @$(GO) install ${ROOT_DIR}/tools/codegen/codegen.go</code></pre></div><p data-pid="8Ngi2VCN">上面的 Makefile 中，<code>gen.errcode.code</code> 依赖了 <code>tools.verify.codegen</code>，<code>tools.verify.codegen</code> 会先检查 codegen 命令是否存在，如果不存在，再调用 install.codegen 来安装 codegen 工具。</p><p data-pid="51IgAjAO">如果我们的 Makefile 设计是：</p><div class="highlight"><pre><code class="language-bash">gen.errcode.code: install.codegen</code></pre></div><p data-pid="DqxGFJsc">那每次执行 gen.errcode.code 都要重新安装 codegen 命令，这种操作是不必要的，还会导致 make gen.errcode.code 执行很慢。</p><p class="ztext-empty-paragraph"><br></p><h3><b>技巧 9：设置 OPTIONS</b></h3><p data-pid="7XePDEnh">编写 Makefile 时，我们还需要把一些可变的功能通过 OPTIONS 来控制。为了帮助你理解，这里还是拿 IAM 项目的 Makefile 来举例。</p><p data-pid="VNYBGkbP">假设我们需要通过一个选项 V ，来控制是否需要在执行 Makefile 时打印详细的信息。这可以通过下面的步骤来实现。</p><p data-pid="V8yfUCwp">首先，在 <code>/Makefile</code> 中定义 <code>USAGE_OPTIONS</code> 。定义 <code>USAGE_OPTIONS</code> 可以使开发者在执行 make help 后感知到此 OPTION，并根据需要进行设置。</p><div class="highlight"><pre><code class="language-bash">define USAGE_OPTIONS    
                         
Options:
  ...
  BINS         The binaries to build. Default is all of cmd.
               ...
  ...
  V            Set to <span class="m">1</span> <span class="nb">enable</span> verbose build. Default is 0.    
endef    
<span class="nb">export</span> USAGE_OPTIONS    </code></pre></div><p data-pid="mTg8Y819">接着，在<code>scripts/make-rules/common.mk</code>文件中，我们通过判断有没有设置 V 选项，来选择不同的行为：</p><div class="highlight"><pre><code class="language-text">ifndef V    
MAKEFLAGS += --no-print-directory    
endif</code></pre></div><p data-pid="z3aeXnBO">当然，我们还可以通过下面的方法来使用 V ：</p><div class="highlight"><pre><code class="language-bash">ifeq <span class="o">(</span><span class="k">$(</span>origin V<span class="k">)</span>, undefined<span class="o">)</span>                                
<span class="nv">MAKEFLAGS</span> <span class="o">+=</span> --no-print-directory              
endif</code></pre></div><p data-pid="BkrWmdxR">上面，我介绍了 V OPTION，我们在 Makefile 中通过判断有没有定义 V ，来执行不同的操作。其实还有一种 OPTION，这种 OPTION 的值我们在 Makefile 中是直接使用的，例如BINS。针对这种 OPTION，我们可以通过以下方式来使用：</p><div class="highlight"><pre><code class="language-bash">BINS ?<span class="o">=</span> <span class="k">$(</span>foreach cmd,<span class="si">${</span><span class="nv">COMMANDS</span><span class="si">}</span>,<span class="k">$(</span>notdir <span class="si">${</span><span class="nv">cmd</span><span class="si">}</span><span class="k">))</span>
...
go.build: go.build.verify <span class="k">$(</span>addprefix go.build., <span class="k">$(</span>addprefix <span class="k">$(</span>PLATFORM<span class="k">)</span>., <span class="k">$(</span>BINS<span class="k">)))</span></code></pre></div><p data-pid="zLLFKo8w">也就是说，通过 ?= 来判断 BINS 变量有没有被赋值，如果没有，则赋予等号后的值。接下来，就可以在 Makefile 规则中使用它。</p><p class="ztext-empty-paragraph"><br></p><h3><b>技巧 10：定义环境变量</b></h3><p data-pid="7t5dyn4j">我们可以在 Makefile 中定义一些环境变量，例如：</p><div class="highlight"><pre><code class="language-text">GO := go                                          
GO_SUPPORTED_VERSIONS ?= 1.13|1.14|1.15|1.16|1.17    
GO_LDFLAGS += -X $(VERSION_PACKAGE).GitVersion=$(VERSION) \    
  -X $(VERSION_PACKAGE).GitCommit=$(GIT_COMMIT) \       
  -X $(VERSION_PACKAGE).GitTreeState=$(GIT_TREE_STATE) \                          
  -X $(VERSION_PACKAGE).BuildDate=$(shell date -u +'%Y-%m-%dT%H:%M:%SZ')    
ifneq ($(DLV),)                                                                                                                              
  GO_BUILD_FLAGS += -gcflags "all=-N -l"    
  LDFLAGS = ""      
endif                                                                                   
GO_BUILD_FLAGS += -tags=jsoniter -ldflags "$(GO_LDFLAGS)" 
...
FIND := find . ! -path './third_party/*' ! -path './vendor/*'    
XARGS := xargs --no-run-if-empty </code></pre></div><p data-pid="1sjG7zfI">这些环境变量和编程中使用宏定义的作用是一样的：只要修改一处，就可以使很多地方同时生效，避免了重复的工作。</p><p data-pid="BN7sQKGK">通常，我们可以将 GO、GO_BUILD_FLAGS、FIND 这类变量定义为环境变量。</p><p class="ztext-empty-paragraph"><br></p><h3><b>技巧 11：自己调用自己</b></h3><p data-pid="OuTDAFrQ">在编写 Makefile 的过程中，你可能会遇到这样一种情况：A-Target 目标命令中，需要完成操作 B-Action，而操作 B-Action 我们已经通过伪目标 B-Target 实现过。为了达到最大的代码复用度，这时候最好的方式是在 A-Target 的命令中执行 B-Target。方法如下：</p><div class="highlight"><pre><code class="language-bash">tools.verify.%:
  @if ! which <span class="nv">$*</span> <span class="p">&amp;</span>&gt;/dev/null<span class="p">;</span> <span class="k">then</span> <span class="k">$(</span>MAKE<span class="k">)</span> tools.install.<span class="nv">$*</span><span class="p">;</span> <span class="k">fi</span></code></pre></div><p class="ztext-empty-paragraph"><br></p><p data-pid="qy23e0eM">这里，我们通过 <code>$(MAKE)</code> 调用了伪目标 <code>tools.install.$*</code> 。要注意的是，默认情况下，Makefile 在切换目录时会输出以下信息：</p><div class="highlight"><pre><code class="language-text">$ make tools.install.codegen
===========&gt; Installing codegen
make[1]: Entering directory `/home/colin/workspace/golang/src/github.com/marmotedu/iam'
make[1]: Leaving directory `/home/colin/workspace/golang/src/github.com/marmotedu/iam'</code></pre></div><p data-pid="pQJUufRR">如果觉得 Entering directory 这类信息很烦人，可以通过设置 MAKEFLAGS += --no-print-directory 来禁止 Makefile 打印这些信息。</p><p class="ztext-empty-paragraph"><br></p><h2><b>总结</b></h2><p data-pid="eaPzISwN"><b>规范的 Makefile  文件需要的步骤：</b></p><ol><li data-pid="yXKpYKil">v首先，你需要熟练掌握 Makefile 的语法。我建议你重点掌握以下语法：Makefile 规则语法、伪目标、变量赋值、特殊变量、自动化变量。</li><li data-pid="X83J2zij">接着，我们需要提前规划 Makefile 要实现的功能。一个大型 Go 项目通常需要实现以下功能：代码生成类命令、格式化类命令、静态代码检查、 测试类命令、构建类命令、Docker 镜像打包类命令、部署类命令、清理类命令，等等。</li><li data-pid="Z9z85y7v">然后，我们还需要通过 Makefile 功能分类、文件分层、复杂命令脚本化等方式，来设计一个合理的 Makefile 结构。</li><li data-pid="vd_1mjz1">最后，我们还需要掌握一些 Makefile 编写技巧，例如：善用通配符、自动变量和函数；编写可扩展的 Makefile；使用带层级的命名方式，等等。通过这些技巧，可以进一步保证我们编写出一个高质量的 Makefile。</li></ol><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h2><b>END Links</b></h2><ul><li data-pid="zHbJu8GH"><a href="https://time.geekbang.org/column/article/389115" target="_blank"><span class="invisible">https://</span><span class="visible">time.geekbang.org/colum</span><span class="invisible">n/article/389115</span><span class="ellipsis"></span></a></li><li data-pid="RW_ZZKZ9"><a href="https://github.com/cubxxw/iam/blob/master/Makefile" target="_blank"><span class="invisible">https://</span><span class="visible">github.com/cubxxw/iam/b</span><span class="invisible">lob/master/Makefile</span><span class="ellipsis"></span></a></li><li data-pid="QAeJslC4"><a href="https://seisman.github.io/how-to-write-makefile/rules.html" target="_blank"><span class="invisible">https://</span><span class="visible">seisman.github.io/how-t</span><span class="invisible">o-write-makefile/rules.html</span><span class="ellipsis"></span></a></li><li data-pid="zBBuYOSo"><a href="https://colynn.github.io/2020-03-03-using_makefile/" target="_blank"><span class="invisible">https://</span><span class="visible">colynn.github.io/2020-0</span><span class="invisible">3-03-using_makefile/</span><span class="ellipsis"></span></a></li></ul></div> </details> 
 <hr /> 

 #### - [Go语言项目设计和开发流程](https://zhuanlan.zhihu.com/p/607192022) 
 <details><summary>توضیحات</summary> <div><ul><li data-pid="OAExm4HW"><a href="https://github.com/cubxxw/iam" target="_blank">  开源地址</a></li></ul><h2><b>Go语言项目设计</b> <br></h2><blockquote data-pid="GhcRZ1cW">❤️  During the winter vacation, I followed up and learned two projects: tiktok project and IAM project, and summarized and practiced the CloudNative project and Go language. I learned a lot in the process.Myblog:<a href="http://nsddd.top/" target="_blank">http://nsddd.top</a></blockquote><h2><b>目录结构</b></h2><p data-pid="rhC2plcH"><b>命名要求和规范：</b></p><ol><li data-pid="gTygAMbf">命名清晰：目录命名要清晰、简洁，不要太长，也不要太短，目录名要能清晰地表达出该目录实现的功能，并且目录名最好用单数。一方面是因为单数足以说明这个目录的功能，另一方面可以统一规范，避免单复混用的情况。</li><li data-pid="EG8iOW7-">功能明确：一个目录所要实现的功能应该是明确的、并且在整个项目目录中具有很高的辨识度。也就是说，当需要新增一个功能时，我们能够非常清楚地知道把这个功能放在哪个目录下。</li><li data-pid="h-_wzO2j">全面性：目录结构应该尽可能全面地包含研发过程中需要的功能，例如文档、脚本、源码管理、API 实现、工具、第三方包、测试、编译产物等。</li><li data-pid="UcHYrGkV">可观测性：项目规模一定是从小到大的，所以一个好的目录结构应该能够在项目变大时，仍然保持之前的目录结构。</li><li data-pid="7tvkVm3o">可扩展性：每个目录下存放了同类的功能，在项目变大时，这些目录应该可以存放更多同类功能。举个例子，有如下目录结构：</li></ol><p class="ztext-empty-paragraph"><br></p><p data-pid="U5ramxur"> 简单的一个案例如下：</p><div class="highlight"><pre><code class="language-bash"> $ ls internal/
 app  pkg  README.md</code></pre></div><p data-pid="Yo130624"><code>internal</code> 目录下有三个文件，internal 目录用来实现内部代码，app 和 pkg 目录下的所有文件都属于内部代码。如果 internal 目录不管项目大小，永远只有 2 个文件 app 和 pkg，那么就说明 internal 目录是不可扩展的。</p><p data-pid="a0yPlJQN">相反，如果 internal 目录下直接存放每个组件的源码目录（一个项目可以由一个或多个组件组成），当项目变大、组件增多时，可以将新增加的组件代码存放到 internal 目录，这时 internal 目录就是可扩展的。例如：</p><div class="highlight"><pre><code class="language-bash"> $ ls internal/
 apiserver  authzserver  iamctl  pkg  pump  watcher</code></pre></div><p class="ztext-empty-paragraph"><br></p><p data-pid="p9l_3n5U">根据功能，<b>我们可以将目录结构分为结构化目录结构和平铺式目录结构两种。</b> 结构化目录结构主要用在 Go 应用中，相对来说比较复杂；而平铺式目录结构主要用在 Go 包中，相对来说比较简单。</p><p class="ztext-empty-paragraph"><br></p><h3><b>平铺式结构</b></h3><p data-pid="MsLuB3k6">一个 Go 项目可以是一个应用，也可以是一个代码 <b>框架 / 库</b>，当项目是代码 <b>框架 / 库</b> 时，比较适合采用平铺式目录结构。</p><p data-pid="MV6icUPN">平铺方式就是在项目的根目录下存放项目的代码，整个目录结构看起来更像是一层的，这种方式在很多框架 / 库中存在，使用这种方式的好处是引用路径长度明显减少，比如 <a href="http://github.com/marmotedu/log/pkg/options" target="_blank"><span class="invisible">http://</span><span class="visible">github.com/marmotedu/lo</span><span class="invisible">g/pkg/options</span><span class="ellipsis"></span></a>，可缩短为 <a href="http://github.com/marmotedu/log/options" target="_blank"><span class="invisible">http://</span><span class="visible">github.com/marmotedu/lo</span><span class="invisible">g/options</span><span class="ellipsis"></span></a>。例如 log 包 <a href="http://github.com/golang/glog" target="_blank"><span class="invisible">http://</span><span class="visible">github.com/golang/glog</span><span class="invisible"></span></a> 就是平铺式的，目录如下：</p><div class="highlight"><pre><code class="language-bash"> $ ls glog/
 glog_file.go  glog.go  glog_test.go  LICENSE  README</code></pre></div><p class="ztext-empty-paragraph"><br></p><h3><b>结构式结构</b></h3><p data-pid="0Xuoabj7">当前 Go 社区比较推荐的结构化目录结构是 <a href="https://github.com/golang-standards/project-layout" target="_blank">project-layout</a> 。虽然它并不是官方和社区的规范，但因为组织方式比较合理，被很多 Go 开发人员接受。所以，我们可以把它当作是一个事实上的规范。</p><p data-pid="jAnJeArx">开发一个Go语言项目，应该包含哪些功能：</p><ul><li data-pid="_u7JbCQY">项目介绍：README.md。</li><li data-pid="0nMw8AJu">客户端：xxxctl。</li><li data-pid="fHOv1hXx">API 文档。</li><li data-pid="JnNhNS7e">构建配置文件，CICD 配置文件。</li><li data-pid="LKrUVaiw">CHANGELOG。</li><li data-pid="Bd-hBgzF">项目配置文件。</li><li data-pid="E_mY_STv">kubernetes 部署定义文件（未来容器化是趋势，甚至会成为服务部署的事实标准，所以目录结构中需要有存放 kubernetes 定义文件的目录）。</li><li data-pid="8MfXNxXp">Dockerfile 文件。</li><li data-pid="XjceuJR0">systemd/init 部署配置文件（物理机/虚拟机部署方式需要）。</li><li data-pid="vYRHwu0U">项目文档。</li><li data-pid="Wqp-aL3g">commit message 格式检查或者其他 githook。</li><li data-pid="OH5NsPQQ">请求参数校验。</li><li data-pid="EM_Ymsbs">命令行 flag。</li><li data-pid="54FlBUXi">共享包：<br></li><ul><li data-pid="ALK7B9qG">外部项目可导入。</li><li data-pid="JFtsGse6">只有子项目可导入。</li></ul></ul><p class="ztext-empty-paragraph"><br></p><ul><li data-pid="AMBDmN2M">storage 接口。</li><li data-pid="IOznSkCy">项目管理：Makefile，完成代码检查、构建、打包、测试、部署等。</li><li data-pid="nXr5Dagx">版权声明。</li><li data-pid="4CEC3AL5">_output 目录（编译、构建产物）。</li><li data-pid="uA2Xr3oF">引用的第三方包。</li><li data-pid="SFzUmsgA">脚本文件（可能会借助脚本，实现一些源码管理、构建、生成等功能）。</li><li data-pid="07L1X5zk">测试文件。</li></ul><p class="ztext-empty-paragraph"><br></p><p data-pid="WD4t24Mi"><b>IAM 项目规范：</b></p><div class="highlight"><pre><code class="language-bash"> ​
 ├── api
 │   ├── openapi
 │   └── swagger
 ├── build
 │   ├── ci
 │   ├── docker
 │   │   ├── iam-apiserver
 │   │   ├── iam-authz-server
 │   │   └── iam-pump
 │   ├── package
 ├── CHANGELOG
 ├── cmd
 │   ├── iam-apiserver
 │   │   └── apiserver.go
 │   ├── iam-authz-server
 │   │   └── authzserver.go
 │   ├── iamctl
 │   │   └── iamctl.go
 │   └── iam-pump
 │       └── pump.go
 ├── configs
 ├── CONTRIBUTING.md
 ├── deployments
 ├── docs
 │   ├── devel
 │   │   ├── en-US
 │   │   └── zh-CN
 │   ├── guide
 │   │   ├── en-US
 │   │   └── zh-CN
 │   ├── images
 │   └── README.md
 ├── examples
 ├── githooks
 ├── go.mod
 ├── go.sum
 ├── init
 ├── internal
 │   ├── apiserver
 │   │   ├── api
 │   │   │   └── v1
 │   │   │       └── user
 │   │   ├── apiserver.go
 │   │   ├── options
 │   │   ├── service
 │   │   ├── store
 │   │   │   ├── mysql
 │   │   │   ├── fake
 │   │   └── testing
 │   ├── authzserver
 │   │   ├── api
 │   │   │   └── v1
 │   │   │       └── authorize
 │   │   ├── options
 │   │   ├── store
 │   │   └── testing
 │   ├── iamctl
 │   │   ├── cmd
 │   │   │   ├── completion
 │   │   │   ├── user
 │   │   └── util
 │   ├── pkg
 │   │   ├── code
 │   │   ├── options
 │   │   ├── server
 │   │   ├── util
 │   │   └── validation
 ├── LICENSE
 ├── Makefile
 ├── _output
 │   ├── platforms
 │   │   └── linux
 │   │       └── amd64
 ├── pkg
 │   ├── util
 │   │   └── genutil
 ├── README.md
 ├── scripts
 │   ├── lib
 │   ├── make-rules
 ├── <span class="nb">test</span>
 │   ├── testdata
 ├── third_party
 │   └── forked
 └── tools</code></pre></div><p class="ztext-empty-paragraph"><br></p><p data-pid="kul8asSI">一个 Go 项目包含 3 大部分：Go 应用 、项目管理和文档。所以，我们的项目目录也可以分为这 3 大类。同时，Go 应用又贯穿开发阶段、测试阶段和部署阶段，相应的应用类的目录，又可以按开发流程分为更小的子类。当然了，这些是我建议的目录，Go 项目目录中还有一些不建议的目录。所以整体来看，我们的目录结构可以按下图所示的方式来分类：</p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic3.zhimg.com/v2-746b6bffd2fce93378bf5d4bbf79d3c2_r.jpg" data-caption="" data-size="normal" width="1165" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>Go 应用 ：主要存放前后端代码</b></h3><ul><li data-pid="ygNkIaNa"><code>/web</code> ：前端代码存放目录，主要用来存放 Web 静态资源，服务端模板和单页应用（SPAs）。</li></ul><p class="ztext-empty-paragraph"><br></p><h3><b>cmd</b></h3><ul><li data-pid="z0ijc5dw"><code>/cmd</code>：一个项目有很多组件，可以把组件 main 函数所在的文件夹统一放在/cmd 目录下，例如：<br> $ ls cmd/<br> gendocs  geniamdocs  genman  genswaggertypedocs  genyaml  iam-apiserver  iam-authz-server  iamctl  iam-pump<br> ​<br> $ ls cmd/iam-apiserver/<br> apiserver.go<br>每个组件的目录名应该跟你期望的可执行文件名是一致的。这里要保证 <code>/cmd/&lt;组件名&gt;</code> 目录下不要存放太多的代码，如果你认为代码可以导入并在其他项目中使用，那么它应该位于 <code>/pkg</code> 目录中。如果代码不是可重用的，或者你不希望其他人重用它，请将该代码放到 <code>/internal</code> 目录中。</li></ul><h3><b>internal</b></h3><ul><li data-pid="ZDF7mz0Y"><code>/internal</code>：存放私有应用和库代码。如果一些代码，你不希望在其他应用和库中被导入，可以将这部分代码放在/internal 目录下。<br>其他项目导入 <code>/internal</code> 下的包时候，Go语言会编译出错：<br> An import of a path containing the element “internal” is disallowed<br> if the importing code is outside the tree rooted at the parent of the<br> "internal" directory.<br>可以通过 Go 语言本身的机制来约束其他项目 import 项目内部的包。/internal 目录建议包含如下目录：<br></li><ul><li data-pid="-rRk-uor"><code>/internal/apiserver</code>：该目录中存放真实的应用代码。这些应用的共享代码存放在/internal/pkg 目录下。</li><li data-pid="RKqu7MUT"><code>/internal/pkg</code>：存放项目内可共享，项目外不共享的包。这些包提供了比较基础、通用的功能，例如工具、错误码、用户验证等功能。</li></ul></ul><p class="ztext-empty-paragraph"><br></p><p data-pid="93uYZ00z"><b>我的建议是，一开始将所有的共享代码存放在 /internal/pkg 目录下，当该共享代码做好了对外开发的准备后，再转存到/pkg目录下。</b></p><div class="highlight"><pre><code class="language-bash"> ​
 ├── apiserver
 │   ├── api
 │   │   └── v1
 │   │       └── user
 │   ├── options
 │   ├── config
 │   ├── service
 │   │   └── user.go
 │   ├── store
 │   │   ├── mysql
 │   │   │   └── user.go
 │   │   ├── fake
 │   └── testing
 ├── authzserver
 │   ├── api
 │   │   └── v1
 │   ├── options
 │   ├── store
 │   └── testing
 ├── iamctl
 │   ├── cmd
 │   │   ├── cmd.go
 │   │   ├── info
 └── pkg
     ├── code
     ├── middleware
     ├── options
     └── validation</code></pre></div><p class="ztext-empty-paragraph"><br></p><p data-pid="lPK0JixY"><b>/internal 目录大概分为 3 类子目录：</b></p><ul><li data-pid="fEwxwyA1"><code>/internal/pkg</code>：内部共享包存放的目录。</li><li data-pid="VOmiOnYV"><code>/internal/authzserver</code>、<code>/internal/apiserver</code>、<code>/internal/pump</code>、<code>/internal/iamctl</code>：应用目录，里面包含应用程序的实现代码。</li><li data-pid="Bpb_zvfP"><code>/internal/iamctl</code>：对于一些大型项目，可能还会需要一个客户端工具。</li></ul><p data-pid="uyPadY9G">在每个应用程序内部，也会有一些目录结构，这些目录结构主要根据功能来划分：</p><ul><li data-pid="7HCR_BXV"><code>/internal/apiserver/api/v1</code>：HTTP API 接口的具体实现，主要用来做 HTTP 请求的解包、参数校验、业务逻辑处理、返回。注意这里的业务逻辑处理应该是轻量级的，如果业务逻辑比较复杂，代码量比较多，建议放到 /internal/apiserver/service 目录下。该源码文件主要用来串流程。</li><li data-pid="OIxpSHM5"><code>/internal/apiserver/options</code>：应用的 command flag。</li><li data-pid="jijl94jO"><code>/internal/apiserver/config</code>：根据命令行参数创建应用配置。</li><li data-pid="bQ7Wu16l"><code>/internal/apiserver/service</code>：存放应用复杂业务处理代码。</li><li data-pid="VpQt5E7O"><code>/internal/apiserver/store/mysql</code>：一个应用可能要持久化的存储一些数据，这里主要存放跟数据库交互的代码，比如 Create、Update、Delete、Get、List 等。</li></ul><p class="ztext-empty-paragraph"><br></p><p data-pid="9X7IQg6K">/internal/pkg 目录存放项目内可共享的包，通常可以包含如下目录：</p><ul><li data-pid="SoOVrF1p"><code>/internal/pkg/code</code>：项目业务 Code 码。</li><li data-pid="Qpeq0qHL"><code>/internal/pkg/validation</code>：一些通用的验证函数。</li><li data-pid="lOH7hLv2"><code>/internal/pkg/middleware</code>：HTTP 处理链。</li></ul><p class="ztext-empty-paragraph"><br></p><h3><b>pkg</b></h3><p data-pid="zvntEPLS">/pkg 目录是 Go 语言项目中非常常见的目录，我们几乎能够在所有知名的开源项目（非框架）中找到它的身影，例如 Kubernetes、Prometheus、Moby、Knative 等。</p><p data-pid="JlrplH0t">该目录中存放可以被外部应用使用的代码库，其他项目可以直接通过 import 导入这里的代码。所以，我们在将代码库放入该目录时一定要慎重。</p><p class="ztext-empty-paragraph"><br></p><h3><b>/vendor</b></h3><p data-pid="vOxF0idR">项目依赖，可通过 go mod vendor 创建。需要注意的是，如果是一个 Go 库，不要提交 vendor 依赖包。</p><p class="ztext-empty-paragraph"><br></p><h3><b>/third_party</b></h3><p data-pid="869I-Kzw">外部帮助工具，分支代码或其他第三方应用（例如 Swagger UI）。比如我们 fork 了一个第三方 go 包，并做了一些小的改动，我们可以放在目录 /third_party/forked 下。一方面可以很清楚的知道该包是 fork 第三方的，另一方面又能够方便地和 upstream 同步。</p><p class="ztext-empty-paragraph"><br></p><h3><b>Go 应用：主要存放测试相关的文件和代码</b></h3><h3><b>/test</b></h3><p data-pid="XeSpaIfh">用于存放其他外部测试应用和测试数据。/test 目录的构建方式比较灵活：对于大的项目，有一个数据子目录是有意义的。例如，如果需要 Go 忽略该目录中的内容，可以使用 /test/data 或 /test/testdata 目录。</p><p data-pid="n3hGDv2Z">需要注意的是，Go 也会忽略以“.”或 “_” 开头的目录或文件。这样在命名测试数据目录方面，可以具有更大的灵活性。</p><p class="ztext-empty-paragraph"><br></p><h3><b>Go 应用：存放跟应用部署相关的文件</b></h3><p data-pid="r6_k9hhI">接着，我们再来看下与部署阶段相关的目录，这些目录可以存放部署相关的文件。</p><h3><b>/configs</b></h3><p data-pid="GEs5Sy48">这个目录用来配置文件模板或默认配置。例如，可以在这里存放 confd 或 consul-template 模板文件。这里有一点要注意，配置中不能携带敏感信息，这些敏感信息，我们可以用占位符来替代，例如：</p><div class="highlight"><pre><code class="language-bash"> apiVersion: v1    
 user:    
   username: <span class="si">${</span><span class="nv">CONFIG_USER_USERNAME</span><span class="si">}</span> <span class="c1"># iam 用户名    </span>
   password: <span class="si">${</span><span class="nv">CONFIG_USER_PASSWORD</span><span class="si">}</span> <span class="c1"># iam 密码</span></code></pre></div><p class="ztext-empty-paragraph"><br></p><h3><b>/deployments</b></h3><p data-pid="opcdcs9M">用来存放 <code>Iaas</code>、<code>PaaS</code> 系统和容器编排部署配置和模板（Docker-Compose，Kubernetes/Helm，Mesos，Terraform，Bosh）。在一些项目，特别是用 Kubernetes 部署的项目中，这个目录可能命名为 deploy。</p><p data-pid="r3P6CEJf">为什么要将这类跟 Kubernetes 相关的目录放到目录结构中呢？主要是因为当前软件部署基本都在朝着容器化的部署方式去演进。</p><p class="ztext-empty-paragraph"><br></p><h3><b>/init</b></h3><p data-pid="M0GcnVzc">存放初始化系统（systemd，upstart，sysv）和进程管理配置文件（runit，supervisord）。比如 sysemd 的 unit 文件。这类文件，在非容器化部署的项目中会用到。</p><p class="ztext-empty-paragraph"><br></p><h3><b>项目管理：存放用来管理 Go 项目的各类文件</b></h3><p data-pid="rpkphBt6">在做项目开发时，还有些目录用来存放项目管理相关的文件，这里我们一起来看下。</p><p class="ztext-empty-paragraph"><br></p><h3><b>/Makefile</b></h3><p data-pid="zFMgiAEn">虽然 Makefile 是一个很老的项目管理工具，但它仍然是最优秀的项目管理工具。所以，一个 Go 项目在其根目录下应该有一个 Makefile 工具，用来对项目进行管理，Makefile 通常用来执行静态代码检查、单元测试、编译等功能。其他常见功能，你可以参考这里：</p><ul><li data-pid="yaRMR3qf">静态代码检查(lint)：推荐用 golangci-lint。</li><li data-pid="T-0cWD5S">单元测试(test)：运行 go test ./...。</li><li data-pid="jkkD7X2o">编译(build)：编译源码，支持不同的平台，不同的 CPU 架构。</li><li data-pid="EhFNlInq">镜像打包和发布(image/image.push)：现在的系统比较推荐用 Docker/Kubernetes 进行部署，所以一般也要有镜像构建功能。</li><li data-pid="EBgQDZNB">清理（clean）:清理临时文件或者编译后的产物。</li><li data-pid="H0DyVsQK">代码生成（gen）：比如要编译生成 protobuf pb.go 文件。</li><li data-pid="-IPsmdou">部署（deploy，可选）：一键部署功能，方便测试。</li><li data-pid="0oLYxX2D">发布（release）：发布功能，比如：发布到 Docker Hub、github 等。</li><li data-pid="auE0oKCk">帮助（help）:告诉 Makefile 有哪些功能，如何执行这些功能。</li><li data-pid="Xzh8oav2">版权声明（add-copyright）：如果是开源项目，可能需要在每个文件中添加版权头，这可以通过 Makefile 来添加。</li><li data-pid="zDjpdTyT">API 文档（swagger）：如果使用 swagger 来生成 API 文档，这可以通过 Makefile 来生成。</li></ul><p class="ztext-empty-paragraph"><br></p><p data-pid="Wox8iZqp">我还有一条建议：直接执行 make 时，执行如下各项 <code>format -&gt; lint -&gt; test -&gt; build</code>，如果是有代码生成的操作，还可能需要首先生成代码 <code>gen -&gt; format -&gt; lint -&gt; test -&gt; build</code>。</p><p data-pid="vcrEGZi2">在实际开发中，我们可以将一些重复性的工作自动化，并添加到 Makefile 文件中统一管理。</p><p class="ztext-empty-paragraph"><br></p><h3><b>/scripts</b></h3><p data-pid="ZmQFUJ0n">该目录主要用来存放脚本文件，实现构建、安装、分析等不同功能。不同项目，里面可能存放不同的文件，但通常可以考虑包含以下 3 个目录：</p><ul><li data-pid="L9i2QUFt"><code>/scripts/make-rules</code>：用来存放 makefile 文件，实现 /Makefile 文件中的各个功能。Makefile 有很多功能，为了保持它的简洁，我建议你将各个功能的具体实现放在/scripts/make-rules 文件夹下。</li><li data-pid="zF5BDQ3y"><code>/scripts/lib</code>：shell 库，用来存放 shell 脚本。一个大型项目中有很多自动化任务，比如发布、更新文档、生成代码等，所以要写很多 shell 脚本，这些 shell 脚本会有一些通用功能，可以抽象成库，存放在/scripts/lib 目录下，比如 logging.sh，util.sh 等。</li><li data-pid="Z5dUDwXa"><code>/scripts/install</code>：如果项目支持自动化部署，可以将自动化部署脚本放在此目录下。如果部署脚本简单，也可以直接放在 /scripts 目录下。</li></ul><p data-pid="MUEO_4AQ">另外，shell 脚本中的函数名，建议采用语义化的命名方式，例如 iam::log::info 这种语义化的命名方式，可以使调用者轻松的辨别出函数的功能类别，便于函数的管理和引用。在 Kubernetes 的脚本中，就大量采用了这种命名方式。</p><p class="ztext-empty-paragraph"><br></p><h3><b>/build</b></h3><p data-pid="QYhfcRFG">这里存放安装包和持续集成相关的文件。这个目录下有 3 个大概率会使用到的目录，在设计目录结构时可以考虑进去。</p><ul><li data-pid="4wLB6w9S"><code>/build/package</code>：存放容器（Docker）、系统（deb, rpm, pkg）的包配置和脚本。</li><li data-pid="EEcITBRu"><code>/build/ci</code>：存放 CI（travis，circle，drone）的配置文件和脚本。</li><li data-pid="RlWnw3Af"><code>/build/docker</code>：存放子项目各个组件的 Dockerfile 文件。</li></ul><p class="ztext-empty-paragraph"><br></p><h3><b>tools</b></h3><p data-pid="0jHzQ4VR">存放这个项目的支持工具。这些工具可导入来自 /pkg 和 /internal 目录的代码。</p><p class="ztext-empty-paragraph"><br></p><h3><b>githooks</b></h3><p data-pid="LgQQcZwn">Git 钩子。比如，我们可以将 commit-msg 存放在该目录。</p><p class="ztext-empty-paragraph"><br></p><h3><b>/assets</b></h3><p data-pid="Hnyl9Rt3">项目使用的其他资源 (图片、CSS、JavaScript 等)。</p><p class="ztext-empty-paragraph"><br></p><h3><b>/website</b></h3><p data-pid="QUadZs01">如果你不使用 GitHub 页面，那么可以在这里放置项目网站相关的数据。</p><p class="ztext-empty-paragraph"><br></p><h3><b>文档：主要存放项目的各类文档</b></h3><p data-pid="I11tISFG">一个项目，也包含一些文档，这些文档有很多类别，也需要一些目录来存放这些文档，这里我们也一起来看下。</p><p class="ztext-empty-paragraph"><br></p><h3><b>/README.md</b></h3><p data-pid="cKubIkn4">项目的 README 文件一般包含了项目的介绍、功能、快速安装和使用指引、详细的文档链接以及开发指引等。有时候 README 文档会比较长，为了能够快速定位到所需内容，需要添加 markdown toc 索引，可以借助工具 <a href="https://github.com/nochso/tocenize" target="_blank">tocenize</a> 来完成索引的添加。</p><p class="ztext-empty-paragraph"><br></p><h3><b>/docs</b></h3><p data-pid="5nfDh6jb">存放设计文档、开发文档和用户文档等（除了 godoc 生成的文档）。推荐存放以下几个子目录：</p><ul><li data-pid="XVh7-KdE"><code>/docs/devel/{en-US,zh-CN}</code>：存放开发文档、hack 文档等。</li><li data-pid="RQ195N-c"><code>/docs/guide/{en-US,zh-CN}</code>: 存放用户手册，安装、quickstart、产品文档等，分为中文文档和英文文档。</li><li data-pid="TEYmjRBq"><code>/docs/images</code>：存放图片文件。</li></ul><p class="ztext-empty-paragraph"><br></p><h3><b>/CONTRIBUTING.md</b></h3><p data-pid="1rN1lQnI">如果是一个开源就绪的项目，最好还要有一个 CONTRIBUTING.md 文件，用来说明如何贡献代码，如何开源协同等等。CONTRIBUTING.md 不仅能够规范协同流程，还能降低第三方开发者贡献代码的难度。</p><p class="ztext-empty-paragraph"><br></p><h3><b>/api</b></h3><p data-pid="s5TMabT7">/api 目录中存放的是当前项目对外提供的各种不同类型的 API 接口定义文件，其中可能包含类似 /api/protobuf-spec、/api/thrift-spec、/api/http-spec、openapi、swagger 的目录，这些目录包含了当前项目对外提供和依赖的所有 API 文件。例如，如下是 IAM 项目的 /api 目录：</p><div class="highlight"><pre><code class="language-bash"> ​
 ├── openapi/
 │   └── README.md
 └── swagger/
     ├── docs/
     ├── README.md
     └── swagger.yaml</code></pre></div><p data-pid="0SR0QAj5">二级目录的主要作用，就是在一个项目同时提供了多种不同的访问方式时，可以分类存放。用这种方式可以避免潜在的冲突，也能让项目结构更加清晰。</p><p class="ztext-empty-paragraph"><br></p><h3><b>/examples</b></h3><p data-pid="6_FZJs7d">存放应用程序或者公共包的示例代码。这些示例代码可以降低使用者的上手门槛。</p><p class="ztext-empty-paragraph"><br></p><p data-pid="yb323H4Y"><b>  在 Go 项目中，要避免使用带复数的目录或者包。建议统一使用单数。</b></p><p class="ztext-empty-paragraph"><br></p><h2><b>合理的多人开发流</b></h2><p data-pid="5UbovcgN">基于 master 分支新建一个功能分支，功能分支可以取一些有意义的名字，便于理解，例如 feature/rate-limiting。</p><div class="highlight"><pre><code class="language-bash"> $ git checkout -b feature/rate-limiting</code></pre></div><p class="ztext-empty-paragraph"><br></p><p data-pid="dIanoD8V">在功能分支上进行代码开发，开发完成后 commit 到功能分支。</p><div class="highlight"><pre><code class="language-bash"> $ git add limit.go
 $ git commit -m <span class="s2">"add rate limiting"</span></code></pre></div><p class="ztext-empty-paragraph"><br></p><p data-pid="AN2CuqaF">将本地功能分支代码 push 到远程仓库。</p><div class="highlight"><pre><code class="language-bash"> $ git push origin feature/rate-limiting</code></pre></div><p class="ztext-empty-paragraph"><br></p><p data-pid="fvmGCuAS">在远程仓库上创建 PR（例如：GitHub）。</p><p data-pid="uHQreFSW">进入 GitHub 平台上的项目主页，点击 Compare &amp; pull request 提交 PR，如下图所示。</p><figure data-size="normal"><img src="https://pic2.zhimg.com/v2-511eb5feab1a5236457d0f2c67eb74c9_r.jpg" data-caption="" data-size="normal" width="1635" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p data-pid="lPb10Yx7"><b>图中的“Merge pull request” 提供了 3 种 merge 方法：</b></p><ol><li data-pid="4t6HaK47">Create a merge commit：GitHub 的底层操作是 git merge --no-ff。feature 分支上所有的 commit 都会加到 master 分支上，并且会生成一个 merge commit。这种方式可以让我们清晰地知道是谁做了提交，做了哪些提交，回溯历史的时候也会更加方便。</li><li data-pid="d2NYV9cp">Squash and merge：GitHub 的底层操作是 git merge --squash。Squash and merge 会使该 pull request 上的所有 commit 都合并成一个 commit ，然后加到 master 分支上，但原来的 commit 历史会丢失。如果开发人员在 feature 分支上提交的 commit 非常随意，没有规范，那么我们可以选择这种方法来丢弃无意义的 commit。但是在大型项目中，每个开发人员都应该是遵循 commit 规范的，因此我不建议你在团队开发中使用 Squash and merge。</li><li data-pid="gKZxWndB">Rebase and merge：GitHub 的底层操作是 git rebase。这种方式会将 pull request 上的所有提交历史按照原有顺序依次添加到 master 分支的头部（HEAD）。因为 git rebase 有风险，在你不完全熟悉 Git 工作流时，我不建议 merge 时选择这个。通过分析每个方法的优缺点，在实际的项目开发中，我比较推荐你使用 Create a merge commit 方式。</li></ol><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><p data-pid="W133Gg8q"><b>开源项目的贡献步骤：</b></p><blockquote data-pid="GV4dPOZM">这也是我们所需要的步骤，我们绝大多数需要的都是开源项目</blockquote><p data-pid="rbiPgD-R">Fork 远程仓库到自己的账号下。</p><p data-pid="M9j2NK3W">将<a href="https://github.com/marmotedu/iam" target="_blank"><span class="invisible">https://</span><span class="visible">github.com/marmotedu/ia</span><span class="invisible">m</span><span class="ellipsis"></span></a> 项目 Fork 到自己的仓库 <a href="https://github.com/cubxxw/iam" target="_blank"><span class="invisible">https://</span><span class="visible">github.com/cubxxw/iam</span><span class="invisible"></span></a></p><div class="highlight"><pre><code class="language-bash"> $ git clone https://github.com/cubxxw/iam
 $ <span class="nb">cd</span> gitflow-demo
 $ git remote add upstream https://github.com/marmotedu/iam
 $ git remote set-url --push upstream no_push <span class="c1"># Never push to upstream master</span>
 $ git remote -v <span class="c1"># Confirm that your remotes make sense</span>
 origin  https://github.com/cubxxw/iam <span class="o">(</span>fetch<span class="o">)</span>
 origin  https://github.com/cubxxw/iam <span class="o">(</span>push<span class="o">)</span>
 upstream  https://github.com/marmotedu/iam <span class="o">(</span>fetch<span class="o">)</span>
 upstream  https://github.com/marmotedu/iam <span class="o">(</span>push<span class="o">)</span></code></pre></div><p class="ztext-empty-paragraph"><br></p><p data-pid="NT-P_L5e"><b>创建功能分支</b>。</p><p data-pid="lcv75_0H">首先，要同步本地仓库的 master 分支为最新的状态（跟 upstream master 分支一致）。</p><div class="highlight"><pre><code class="language-bash"> $ git fetch upstream
 $ git checkout master
 $ git rebase upstream/master</code></pre></div><p data-pid="iykck743">然后，创建功能分支。</p><div class="highlight"><pre><code class="language-bash"> $ git checkout -b feature/add-function</code></pre></div><p class="ztext-empty-paragraph"><br></p><p data-pid="Y_4gUqWl"><b>提交 commit。</b></p><p data-pid="qE6cFyc0">在 feature/add-function 分支上开发代码，开发完代码后，提交 commit。</p><div class="highlight"><pre><code class="language-bash"> $ git fetch upstream <span class="c1"># commit 前需要再次同步 feature 跟 upstream/master</span>
 $ git rebase upstream/master
 $ git add &lt;file&gt;
 $ git status
 $ git commit</code></pre></div><p data-pid="N46t95bq">分支开发完成后，可能会有一堆 commit，但是合并到主干时，我们往往希望只有一个（或最多两三个）commit，这可以使功能修改都放在一个或几个 commit 中，便于后面的阅读和维护。这个时候，我们可以用 git rebase 来合并和修改我们的 commit，操作如下：</p><div class="highlight"><pre><code class="language-bash"> $ git rebase -i origin/master</code></pre></div><p class="ztext-empty-paragraph"><br></p><h2><b>研发流程</b></h2><p data-pid="_wsBZjLj">一个项目从立项到结项，中间会经历很多阶段。业界相对标准的划分，是把研发流程分为六个阶段，分别是需求阶段、设计阶段、开发阶段、测试阶段、发布阶段、运营阶段。其中，开发人员需要参与的阶段有 4 个：设计阶段、开发阶段、测试阶段和发布阶段。下图就是业界相对比较标准的流程：</p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic2.zhimg.com/v2-16c0959efb141a4578895b0a5fdb66e1_r.jpg" data-caption="" data-size="normal" width="1088" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><p data-pid="H8Z7sL9i">每个阶段结束时，都需要有一个最终的产出物，可以是文档、代码或者部署组件等。这个产出物既是当前阶段的结束里程碑，又是下一阶段的输入。所以说，各个阶段不是割裂的，而是密切联系的整体。每个阶段又细分为很多步骤，这些步骤是需要不同的参与者去完成的工作任务。在完成任务的过程中，可能需要经过多轮的讨论、修改，最终形成定稿。</p><p class="ztext-empty-paragraph"><br></p><h3><b>需求阶段</b></h3><p data-pid="RzfkqiVY">需求阶段是将一个抽象的产品思路具化成一个可实施产品的阶段。在这个阶段，产品人员会讨论产品思路、调研市场需求，并对需求进行分析，整理出一个比较完善的需求文档。最后，产品人员会组织相关人员对需求进行评审，如果评审通过，就会进入设计阶段。</p><p data-pid="iLhCS9jy">需求阶段，一般不需要研发人员参与。但这里，我还是建议你积极参与产品需求的讨论。虽然我们是研发，但我们的视野和对团队的贡献，可以不仅仅局限在研发领域。</p><p data-pid="KystA1Ve">这里有个点需要提醒你，如果你们团队有测试人员，这个阶段也需要拉测试人员旁听下。因为了解产品设计，对测试阶段测试用例的编写和功能测试等都很有帮助。</p><p data-pid="FueksEi1">需求阶段的产出物是一个通过评审的详细的需求文档。</p><p class="ztext-empty-paragraph"><br></p><h3><b>设计阶段</b></h3><p data-pid="RFPYN9Uh">设计阶段，是整个产品研发过程中非常重要的阶段，包括的内容也比较多，你可以看一下这张表：</p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic3.zhimg.com/v2-430babb5a2f357c347e5c45e1a2b9a1e_r.jpg" data-caption="" data-size="normal" width="1088" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p data-pid="e7qJ5C5R">这里的每一个设计项都应该经过反复的讨论、打磨，最终在团队内达成共识。这样可以确保设计是合理的，并减少返工的概率。这里想提醒你的是，技术方案和实现都要经过认真讨论，并获得一致通过，否则后面因为技术方案设计不当，需要返工，你要承担大部分责任。</p><p class="ztext-empty-paragraph"><br></p><h3><b>开发阶段</b></h3><p data-pid="HmyjoyCo">开发阶段，从它的名字你就知道了，这是开发人员的主战场，同时它可能也是持续时间最长的阶段。在这一阶段，开发人员根据技术设计文档，编码实现产品需求。</p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic3.zhimg.com/v2-d8a5a09df31649b2106fc95edc180c8a_r.jpg" data-caption="" data-size="normal" width="1088" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p data-pid="BzonLvnM">让我们来详细看下这张图里呈现的步骤。开发阶段又可以分为“开发”和“构建”两部分，我们先来看开发。</p><p data-pid="TAxDXSUp">为了提高开发效率，越来越多的开发者采用生成代码的方式来生成一部分代码，所以在真正编译之前可能还需要先生成代码，比如生成 <code>.pb.go</code> 文件、API 文档、测试用例、错误码等。我的建议是，在项目开发中，你要思考怎么尽可能自动生成代码。这样不仅能提高研发效率，还能减少错误。</p><p data-pid="98QcDIdq">对于一个开源项目，我们可能还需要检查新增的文件是否有版权信息。此外，根据项目不同，开发阶段还可能有其它不同的步骤。在流程的最后，通常会进行静态代码检查、单元测试和编译。编译之后，我们就可以启动服务，并进行自测了。</p><p data-pid="uuhG4Kgw">自测之后，我们可以遵循 Git Flow 工作流，将开发分支 push 到代码托管平台进行 code review。code review 通过之后，我们就可以将代码 merge 到 develop 分支上。</p><p data-pid="ZdVjWpay">接下来进入构建阶段。这一阶段最好借助 CI/CD 平台实现自动化，提高构建效率。</p><p data-pid="02MPne3f">合并到 develop 分支的代码同样需要进行代码扫描、单元测试，并编译打包。最后，我们需要进行归档，也就是将编译后的二进制文件或 Docker 镜像上传到制品库或镜像仓库。</p><p class="ztext-empty-paragraph"><br></p><p data-pid="1VG_yh8R">如何提高效率呢？两种方法：</p><ol><li data-pid="cYnG7Sf8">将开发阶段的步骤通过 Makefile 实现集中管理；</li><li data-pid="q9R03HHR">将构建阶段的步骤通过 CI/CD 平台实现自动化。</li></ol><p data-pid="4Ztu3lAX">在最终合并代码到 master 之前，要确保代码是经过充分测试的。</p><blockquote data-pid="OOkGs45B">其中有一个代码覆盖率：</blockquote><p class="ztext-empty-paragraph"><br></p><h3><b>测试阶段</b></h3><p data-pid="zDBy--z-">测试阶段由测试工程师（也叫质量工程师）负责，这个阶段的主要流程是：测试工程师根据需求文档创建测试计划、编写测试用例，并拉研发同学一起评审测试计划和用例。评审通过后，测试工程师就会根据测试计划和测试用例对服务进行测试。</p><p data-pid="jYiicCTb">为了提高整个研发效率，测试计划的创建和测试用例的编写可以跟开发阶段并行。</p><p data-pid="aJefkaSS">研发人员在交付给测试时，要提供自测报告、自测用例和安装部署文档。这里我要强调的是：在测试阶段，为了不阻塞测试，确保项目按时发布，研发人员应该优先解决测试同学的 Bug，至少是阻塞类的 Bug。为了减少不必要的沟通和排障，安装部署文档要尽可能详尽和准确。</p><p data-pid="R3CgBiwm">另外，你也可以及时跟进测试，了解测试同学当前遇到的卡点。因为实际工作中，一些测试同学在遇到卡点时，不善于或者不会及时地跟你同步卡点，往往研发 1 分钟就可以解决的问题，可能要花测试同学几个小时或者更久的时间去解决。</p><p class="ztext-empty-paragraph"><br></p><h3><b>发布阶段</b></h3><p data-pid="qn0Ovezg">发布阶段主要是将软件部署上线，为了保证发布的效率和质量，我们需要遵循一定的发布流程，如下图所示：</p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic1.zhimg.com/v2-ae6121590e596a70893b098f79d56688_r.jpg" data-caption="" data-size="normal" width="1088" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p data-pid="LHU3MUFl">首先，开发人员首先需要将经过测试后的代码合并到主干，通常是 master 分支，并生成版本号，然后给最新的 commit 打上版本标签。之后，可以将代码 push 到代码托管平台，并触发 CI 流程，CI 流程一般会执行代码扫描、单元测试、编译，最后将构建产物发布到制品库。CI 流程中，我们可以根据需要添加任意功能。</p><p data-pid="au8l58zC">编写一些自动化的测试用例，在服务发布到现网之后，对现网服务做一次比较充分的回归测试。通过这个自动化测试，可以以最小的代价，最快速地验证现网功能，从而保障发布质量。</p><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>运营阶段</b></h3><p data-pid="T3cRIDL4">研发流程的最后一个阶段是运营阶段，该阶段主要分为产品运营和运维两个部分。</p><ul><li data-pid="DLwAwz8D">产品运营：通过一系列的运营活动，比如线下的技术沙龙、线上的免费公开课、提高关键词排名或者输出一些技术推广文章等方式，来推高整个产品的知名度，提高产品的用户数量，并提高月活和日活。</li><li data-pid="rErQ5eZf">运维：由运维工程师负责，核心目标是确保系统稳定的运行，如果系统异常，能够及时发现并修复问题。长期目标是通过技术手段或者流程来完善整个系统架构，减少人力投入、提高运维效率，并提高系统的健壮性和恢复能力。</li></ul><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic2.zhimg.com/v2-8c04b26c4bc4c7f5b8167643b40bf799_r.jpg" data-caption="" data-size="normal" width="1088" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><p data-pid="APEyiL6z">在运营阶段，研发人员的主要职责就是协助运维解决现网 Bug，优化部署架构。当然，研发人员可能也需要配合运营人员开发一些运营接口，供运营人员使用。</p><p data-pid="GYx8N_Po"><b>分工图：</b></p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic3.zhimg.com/v2-50eaf0e744244f1c16970f2a8cb11b42_r.jpg" data-caption="" data-size="normal" width="1088" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic1.zhimg.com/v2-60f1388f8c05ac6a14fc91cfe0b566e8_r.jpg" data-caption="" data-size="normal" width="1088" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h2><b>如何管理应用生命周期</b></h2><p data-pid="ehJHjY62">采用一些好的工具或方法在应用的整个生命周期中对应用进行管理，以提高应用的研发效率和质量。</p><p data-pid="qFcZKgsP">在这里我先整体介绍一下，你先有个大致的印象，一会我们再一个个细讲。我们可以从两个维度来理解应用生命周期管理技术。</p><ul><li data-pid="Wmw0S9Su">第一个维度是演进维度。应用生命周期，最开始主要是通过研发模式来管理的，按时间线先后出现了瀑布模式、迭代模式、敏捷模式。接着，为了解决研发模式中的一些痛点出现了另一种管理技术，也就是 CI/CD 技术。随着 CI/CD 技术的成熟，又催生了另一种更高级的管理技术 DevOps。</li><li data-pid="9tMb8YB9">第二个维度是管理技术的类别。应用生命周期管理技术可以分为两类：<br></li><ul><li data-pid="ZjuHyYp3">研发模式，用来确保整个研发流程是高效的。</li><li data-pid="_tXYwtIA">DevOps，主要通过协调各个部门之间的合作，来提高软件的发布效率和质量。DevOps 中又包含了很多种技术，主要包括 CI/CD 和多种 Ops，例如 AIOps、ChatOps、GitOps、NoOps 等。其中，CI/CD 技术提高了软件的发布效率和质量，而 Ops 技术则提高了软件的运维和运营效率。</li></ul></ul><p class="ztext-empty-paragraph"><br></p><p data-pid="1qsOZyZX">尽管这些应用生命周期管理技术有很多不同，但是它们彼此支持、相互联系。研发模式专注于开发过程，DevOps 技术里的 CI/CD 专注于流程，Ops 则专注于实战。</p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic4.zhimg.com/v2-ba07903b0391f88198e54325a76acc57_r.jpg" data-caption="" data-size="normal" width="1088" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p data-pid="Rqtrjpmv">也就是按照这样的顺序：研发模式（瀑布模式 -&gt; 迭代模式 -&gt; 敏捷模式） -&gt; CI/CD -&gt; DevOps。</p><p class="ztext-empty-paragraph"><br></p><h3><b>研发模式</b></h3><p data-pid="K4T72BBx">研发模式主要有三种，演进顺序为瀑布模式 -&gt; 迭代模式 -&gt; 敏捷模式，现在我们逐一看下。</p><h3><b>瀑布模式</b></h3><p data-pid="PVf3Cs3s">在早期阶段，软件研发普遍采用的是瀑布模式，像我们熟知的 RHEL、Fedora 等系统就是采用瀑布模式。</p><p data-pid="cN07_tQm">瀑布模式按照预先规划好的研发阶段来推进研发进度。比如，按照需求阶段、设计阶段、开发阶段、测试阶段、发布阶段、运营阶段的顺序串行执行开发任务。每个阶段完美完成之后，才会进入到下一阶段，阶段之间通过文档进行交付。整个过程如下图所示。</p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic1.zhimg.com/v2-4871cb33a436b01ab057f611fcb381dc_r.jpg" data-caption="" data-size="normal" width="1088" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>迭代模式</b></h3><p data-pid="cWFvUEVf">迭代模式，是一种与瀑布式模式完全相反的开发过程：研发任务被切分为一系列轮次，每一个轮次都是一个迭代，每一次迭代都是一个从设计到实现的完整过程。它不要求每一个阶段的任务都做到最完美，而是先把主要功能搭建起来，然后再通过客户的反馈信息不断完善。</p><p data-pid="fVcmGs5V">迭代开发可以帮助产品改进和把控进度，它的灵活性极大地提升了适应需求变化的能力，克服了高风险、难变更、复用性低的特点。</p><p data-pid="sVLbq2uX">但是，迭代模式的问题在于比较专注于开发过程，很少从项目管理的视角去加速和优化项目开发过程。接下来要讲的敏捷模式，就弥补了这个缺点。</p><p class="ztext-empty-paragraph"><br></p><h3><b>敏捷模式</b></h3><p data-pid="bXJirdx7">敏捷模式把一个大的需求分成多个、可分阶段完成的小迭代，每个迭代交付的都是一个可使用的软件。在开发过程中，软件要一直处于可使用状态。</p><p data-pid="8dVRKEAg">在敏捷模式中，我们会把一个大的需求拆分成很多小的迭代，这意味着开发过程中会有很多个开发、构建、测试、发布和部署的流程。这种高频度的操作会给研发、运维和测试人员带来很大的工作量，降低了工作效率。为了解决这个问题，CI/CD 技术诞生了。</p><p class="ztext-empty-paragraph"><br></p><h3><b>CI/CD：自动化构建和部署应用</b></h3><p data-pid="GZWgd6rl">CI/CD 技术通过自动化的手段，来快速执行代码检查、测试、构建、部署等任务，从而提高研发效率，解决敏捷模式带来的弊端。</p><p data-pid="6yI9s3FC">CI/CD 包含了 3 个核心概念。</p><ul><li data-pid="8TnmUWUL">CI：Continuous Integration，持续集成。</li><li data-pid="pSo_KbZF">CD：Continuous Delivery，持续交付。</li><li data-pid="yHbbxPIQ">CD：Continuous Deployment，持续部署。</li></ul><p data-pid="uqaFqbAc">CI 容易理解，但两个 CD 很多开发者区分不开。这里，我来详细说说这 3 个核心概念。</p><p data-pid="KTWDFQSd"><b>首先是持续集成</b>。它的含义为：频繁地（一天多次）将开发者的代码合并到主干上。它的流程为：在开发人员完成代码开发，并 push 到 Git 仓库后，CI 工具可以立即对代码进行扫描、（单元）测试和构建，并将结果反馈给开发者。持续集成通过后，会将代码合并到主干。</p><p data-pid="RVpz5Qyp">CI 流程可以使应用软件的问题在开发阶段就暴露出来，这会让开发人员交付代码时更有信心。因为 CI 流程内容比较多，而且执行比较频繁，所以 CI 流程需要有自动化工具来支撑。</p><p data-pid="AvRMAcek"><b>其次是持续交付</b>，它指的是一种能够使软件在较短的循环中可靠发布的软件方法。</p><p data-pid="bGUPvb0w">持续交付在持续集成的基础上，将构建后的产物自动部署在目标环境中。这里的目标环境，可以是测试环境、预发环境或者现网环境。</p><p data-pid="5_ta2ckf">通常来说，持续部署可以自动地将服务部署到测试环境或者预发环境。因为部署到现网环境存在一定的风险，所以如果部署到现网环境，需要手工操作。手工操作的好处是，可以使相关人员评估发布风险，确保发布的正确性。</p><p data-pid="z3mE94J0"><b>最后是持续部署</b>，持续部署在持续交付的基础上，将经过充分测试的代码自动部署到生产环境，整个流程不再需要相关人员的审核。持续部署强调的是自动化部署，是交付的最高阶段。</p><p data-pid="LCPq5T_4">持续集成、持续交付和持续部署强调的是持续性，也就是能够支持频繁的集成、交付和部署，这离不开自动化工具的支持，离开了这些工具，CI/CD 就不再具有可实施性。持续集成的核心点在代码，持续交付的核心点在可交付的产物，持续部署的核心点在自动部署。</p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic4.zhimg.com/v2-90e1e89e3617d8b66d8d2d7733ccaeaf_r.jpg" data-caption="" data-size="normal" width="1088" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>DevOps：研发运维一体化</b></h3><p data-pid="6gFqjgi4">CI/CD 技术的成熟，加速了 DevOps 这种应用生命周期管理技术的成熟和落地。</p><p data-pid="Vlbr9vGG">DevOps（Development 和 Operations 的组合）是一组过程、方法与系统的统称，用于促进开发（应用程序 / 软件工程）、技术运营和质量保障（QA）部门之间的沟通、协作与整合。这 3 个部门的相互协作，可以提高软件质量、快速发布软件。如下图所示：</p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic3.zhimg.com/v2-0fed03029d90ebdc83532a2f1da1d06e_r.jpg" data-caption="" data-size="normal" width="1088" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p data-pid="QylfIBq6">要实现 DevOps，需要一些工具或者流程的支持，CI/CD 可以很好地支持 DevOps 这种软件开发模式，如果没有 CI/CD 自动化的工具和流程，DevOps 就是没有意义的，CI/CD 使得 DevOps 变得可行。</p><p data-pid="TWKjqpZ8"><b>DevOps ！= CI/CD。DevOps 是一组过程、方法和系统的统称，而 CI/CD 只是一种软件构建和发布的技术。</b></p><p data-pid="Lup08f2-">DevOps 技术之前一直有，但是落地不好，因为没有一个好的工具来实现 DevOps 的理念。但是随着容器、CI/CD 技术的诞生和成熟，DevOps 变得更加容易落地。也就是说，这几年越来越多的人采用 DevOps 手段来提高研发效能。</p><p data-pid="DsdMi0JO">随着技术的发展，目前已经诞生了很多 Ops 手段，来实现运维和运营的高度自动化。下面，我们就来看看 DevOps 中的四个 Ops 手段：AIOps、ChatOps、GitOps、NoOps。</p><p class="ztext-empty-paragraph"><br></p><h3><b>AIOps：智能运维</b></h3><p data-pid="92cKI_Xl">在 2016 年，Gartner 提出利用 AI 技术的新一代 IT 运维，即 AIOps（智能运维）。通过 AI 手段，来智能化地运维 IT 系统。AIOps 通过搜集海量的运维数据，并利用机器学习算法，智能地定位并修复故障。</p><p data-pid="KCLJU-RP">也就是说，AIOps 在自动化的基础上，增加了智能化，从而进一步推动了 IT 运维自动化，减少了人力成本。</p><p data-pid="8E-GJPh_">随着 IT 基础设施规模和复杂度的倍数增长，企业应用规模、数量的指数级增长，传统的人工 / 自动化运维，已经无法胜任愈加沉重的运维工作，而 AIOps 提供了一个解决方案。在腾讯、阿里等大厂很多团队已经在尝试和使用 AIOps，并享受到了 AIOps 带来的红利。例如，故障告警更加灵敏、准确，一些常见的故障，可以自动修复，无须运维人员介入等。</p><p class="ztext-empty-paragraph"><br></p><h3><b>ChatOps：聊着天就把事情给办了</b></h3><p data-pid="OADkZsIj">随着企业微信、钉钉等企业内通讯工具的兴起，最近几年出现了一个新的概念 ChatOps。</p><p data-pid="5rIxCYBL">简单来说，ChatOps 就是在一个聊天工具中，发送一条命令给 ChatBot 机器人，然后 ChatBot 会执行预定义的操作。这些操作可以是执行某个工具、调用某个接口等，并返回执行结果。</p><p data-pid="vm5TN9um">这种新型智能工作方式的优势是什么呢？它可以利用 ChatBot 机器人让团队成员和各项辅助工具连接在一起，以沟通驱动的方式完成工作。ChatOps 可以解决人与人、人与工具、工具与工具之间的信息孤岛，从而提高协作体验和工作效率。</p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic2.zhimg.com/v2-2e738e7c9bc687000a7924c17f4011a5_r.jpg" data-caption="" data-size="normal" width="1088" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p data-pid="OC5YNMl-">开发 / 运维 / 测试人员通过 @聊天窗口中的机器人 Bot 来触发任务，机器人后端会通过 API 接口调用等方式对接不同的系统，完成不同的任务，例如持续集成、测试、发布等工作。机器人可以是我们自己研发的，也可以是开源的。目前，业界有很多流行的机器人可供选择，常用的有 Hubot、Lita、Errbot、StackStorm 等。</p><p class="ztext-empty-paragraph"><br></p><h3><b>GitOps： 一种实现云原生的持续交付模型</b></h3><p data-pid="MQAWpeB_">GitOps 是一种持续交付的方式。它的核心思想是将应用系统的声明性基础架构（YAML）和应用程序存放在 Git 版本库中。将 Git 作为交付流水线的核心，每个开发人员都可以提交拉取请求（Pull Request），并使用 Git 来加速和简化 Kubernetes 的应用程序部署和运维任务。</p><p data-pid="UizUmAHs">通过 Git 这样的工具，开发人员可以将精力聚焦在功能开发，而不是软件运维上，以此提高软件的开发效率和迭代速度。</p><p data-pid="jYxcqRGI">使用 GitOps 可以带来很多优点，其中最核心的是：当使用 Git 变更代码时，GitOps 可以自动将这些变更应用到程序的基础架构上。因为整个流程都是自动化的，所以部署时间更短；又因为 Git 代码是可追溯的，所以我们部署的应用也能够稳定且可重现地回滚。</p><p data-pid="PYkzk-VX"><b>我们可以从概念和流程上来理解 GitOps，它有 3 个关键概念:</b></p><ul><li data-pid="OwWxpKXm">声明性容器编排：通过 Kubernetes YAML 格式的资源定义文件，来定义如何部署应用。</li><li data-pid="mrm-wQjZ">不可变基础设施：基础设施中的每个组件都可以自动的部署，组件在部署完成后，不能发生变更。如果需要变更，则需要重新部署一个新的组件。例如，Kubernetes 中的 Pod 就是一个不可变基础设施。</li><li data-pid="ixnOBGdH">连续同步：不断地查看 Git 存储库，将任何状态更改反映到 Kubernetes 集群中。</li></ul><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic3.zhimg.com/v2-622bd8f045c6531452b8b4c8728bd8da_r.jpg" data-caption="" data-size="normal" width="1088" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><p data-pid="nMKXObpY"><b>GitOps 的工作流程如下：</b></p><ol><li data-pid="CVO9kOUb">首先，开发人员开发完代码后推送到 Git 仓库，触发 CI 流程，CI 流程通过编译构建出 Docker 镜像，并将镜像 push 到 Docker 镜像仓库中。Push 动作会触发一个 push 事件，通过 webhook 的形式通知到 Config Updater 服务，Config Updater 服务会从 webhook 请求中获取最新 push 的镜像名，并更新 Git 仓库中的 Kubernetes YAML 文件。</li><li data-pid="P_o41eW3">然后，GitOps 的 Deploy Operator 服务，检测到 YAML 文件的变动，会重新从 Git 仓库中提取变更的文件，并将镜像部署到 Kubernetes 集群中。Config Updater 和 Deploy Operator 两个组件需要开发人员设计开发。</li></ol><p class="ztext-empty-paragraph"><br></p><h3><b>NoOps：无运维</b></h3><p data-pid="T_1-QJv2">NoOps 即无运维，完全自动化的运维。在 NoOps 中不再需要开发人员、运营运维人员的协同，把微服务、低代码、无服务全都结合了起来，开发者在软件生命周期中只需要聚焦业务开发即可，所有的维护都交由云厂商来完成。</p><p data-pid="nAdjHhlj">毫无疑问，NoOps 是运维的终极形态，在我看来它像 DevOps 一样，更多的是一种理念，需要很多的技术和手段来支撑。当前整个运维技术的发展，也是朝着 NoOps 的方向去演进的，例如 GitOps、AIOps 可以使我们尽可能减少运维，Serverless 技术甚至可以使我们免运维。相信未来 NoOps 会像现在的 Serverless 一样，成为一种流行的、可落地的理念。</p></div> </details> 
 <hr /> 

 #### - [git-chglog write your CHANGELOG](https://zhuanlan.zhihu.com/p/607015570) 
 <details><summary>توضیحات</summary> <p><img src="https://pic1.zhimg.com/v2-0cb68acc751f6241d4bd26186390f0c3_720w.jpg?source=d16d100b"></p><div><ul><li data-pid="Pbn3yvLJ"><a href="https://github.com/cubxxw" target="_blank">author(Github)</a></li></ul><h2><b>git-chglog write your CHANGELOG</b></h2><blockquote data-pid="ZK1CCTW7">❤️  CS self-study guide, neither depth nor breadth of college education can support our professional quality, this section can be regarded as an additional supplement and record in CS learning. Personal blog: <a href="http://nsddd.top" target="_blank"><span class="invisible">http://</span><span class="visible">nsddd.top</span><span class="invisible"></span></a></blockquote><h2><b>Introduce</b></h2><p data-pid="NEzhayCD">  how are git-chglog ？</p><p data-pid="UVya5WBJ">CHANGELOG generator implemented in Go (Golang). <i>Anytime, anywhere, Write your CHANGELOG.</i></p><p class="ztext-empty-paragraph"><br></p><h2><b>Features</b></h2><ul><li data-pid="5uQaL0xU">♻️High portability <br></li><ul><li data-pid="E7zkbPdB">t works with single binary. Therefore, any project (environment) can be used.  </li></ul></ul><p class="ztext-empty-paragraph"><br></p><ul><li data-pid="wntvcyAH"> Simple usability <br></li><ul><li data-pid="QHff42Oa">he CLI usage is very simple and has low learning costs.</li><li data-pid="In3HXe4Y">For example, the simplest command is <code>$ git-chglog</code>.</li></ul></ul><p class="ztext-empty-paragraph"><br></p><ul><li data-pid="sot3wIN_">  High flexibility <br></li><ul><li data-pid="1BKGl6jT">Commit message format and …</li><li data-pid="eY6055kD">CHANGELOG's style (Template) and ...</li><li data-pid="-NfsHg9b">etc ... ETC ...</li></ul></ul><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h2><b>How it works ?</b></h2><p data-pid="_StJ0Fnu"><code>git-chglog</code> internally uses the <code>git</code> command to get data to include in the CHANGELOG. The basic steps are as follows.</p><ul><li data-pid="MsdGPOfE">Get the commits contained between <code>tagA</code> and <code>tagB</code>.</li><li data-pid="vkoBsu8l">Execute with all tags corresponding to <a href="https://github.com/git-chglog/git-chglog#tag-query" target="_blank">tag query</a> that were specified in Step 1 and Step 2.</li></ul><p class="ztext-empty-paragraph"><br></p><h2><b>Install</b></h2><p data-pid="tdnSJ4bI">Please install <code>git-chglog</code> in a way that matches your environment.</p><p data-pid="36NvcCV1"><b>Go users：</b></p><blockquote data-pid="CttVBaly">The good news is that <code>git-chglog</code> is an open source project for the Go language, which means that it compiles to binary use Go：</blockquote><div class="highlight"><pre><code class="language-bash"> go install github.com/git-chglog/git-chglog/cmd/git-chglog@latest</code></pre></div><p class="ztext-empty-paragraph"><br></p><p data-pid="t18z5b_A"><b>For Windowns users：</b></p><p data-pid="X20iGsFW">I use CLI is <code>powershell</code> ，and I installed the <code>scoop</code> tools. </p><div class="highlight"><pre><code class="language-bash"> scoop install git-chglog</code></pre></div><p class="ztext-empty-paragraph"><br></p><p data-pid="76NK_d0R"><b>For Mac users：</b></p><div class="highlight"><pre><code class="language-bash"> brew tap git-chglog/git-chglog
 brew install git-chglog</code></pre></div><p class="ztext-empty-paragraph"><br></p><p data-pid="s4vEhuLt"><b>For Linux users：</b></p><ol><li data-pid="omndHzRf">Obtaining the installation <a href="https://github.com/git-chglog/git-chglog/releases/tag/v0.15.4" target="_blank">Package</a></li><li data-pid="OdPRWe8K">Cloose the right package (<a href="https://github.com/git-chglog/git-chglog/releases/download/v0.15.4/git-chglog_0.15.4_linux_amd64.tar.gz" target="_blank"><span class="invisible">https://</span><span class="visible">github.com/git-chglog/g</span><span class="invisible">it-chglog/releases/download/v0.15.4/git-chglog_0.15.4_linux_amd64.tar.gz</span><span class="ellipsis"></span></a>)</li><li data-pid="Qz-iioOV"> Download to local and add environment variables</li></ol><p data-pid="HZMJvlKP"><b>Example：</b></p><div class="highlight"><pre><code class="language-bash"> <span class="nb">cd</span> /tmp/<span class="p">;</span> wget https://github.com/git-chglog/git-chglog/releases/download/v0.15.4/git-chglog_0.15.4_linux_amd64.tar.gz <span class="o">&amp;&amp;</span> tar zxvf git-chglog_0.15.4_linux_amd64.tar.gz <span class="o">&amp;&amp;</span> mv ./git-chglog /usr/bin</code></pre></div><p class="ztext-empty-paragraph"><br></p><h3><b>Docker</b></h3><p data-pid="itkyGAld">The compiled docker images are maintained on <a href="https://quay.io/repository/git-chglog/git-chglog" target="_blank">quay.io</a>. We maintain the following tags:</p><ul><li data-pid="kJBU71-8"><code>edge</code>: Image that is build from the current <code>HEAD</code> of the main line branch.</li><li data-pid="BHpFd8vn"><code>latest</code>: Image that is built from the <a href="https://github.com/git-chglog/git-chglog/releases" target="_blank">latest released version</a></li><li data-pid="c8hrWd8j"><code>x.y.y</code> (versions): Images that are build from the tagged versions within Github.</li></ul><p data-pid="XnvLj3PO"> ️ U shoud:</p><div class="highlight"><pre><code class="language-bash"> docker pull quay.io/git-chglog/git-chglog:latest
 docker run -v <span class="s2">"</span><span class="nv">$PWD</span><span class="s2">"</span>:/workdir quay.io/git-chglog/git-chglog --versiondocker pull quay.io/git-chglog/git-chglog:latest
 docker run -v <span class="s2">"</span><span class="nv">$PWD</span><span class="s2">"</span>:/workdir quay.io/git-chglog/git-chglog --version</code></pre></div><p data-pid="uBOzwGAi"> ️ Tip：</p><p data-pid="qB2gBTgw">If you are using another platform, you can download a binary from the <a href="https://github.com/git-chglog/git-chglog/releases" target="_blank">releases page</a> and place it in a directory in your <code>$PATH</code>.</p><blockquote data-pid="MnKUJnjD">Refer to the previous Linux download for <code>git-chglog</code>.</blockquote><p class="ztext-empty-paragraph"><br></p><h3><b>Test Installation</b></h3><p data-pid="zteFuf0-">You can check with the following command whether the <code>git-chglog</code> command was included in a directory that is in your <code>$PATH</code>.</p><div class="highlight"><pre><code class="language-bash"> <span class="c1"># ./git-chglog --version</span>
 git-chglog version 0.15.4</code></pre></div><p class="ztext-empty-paragraph"><br></p><h2><b>Quick Start </b></h2><p data-pid="vFQcFzMa"><code>git-chglog</code> requires configuration files and templates to generate a CHANGELOG.</p><p data-pid="SD2FD3fs">However, it is a waste of time to create configuration files and templates from scratch.</p><p data-pid="MIOQDPnV">Therefore we recommend using the <code>--init</code> option which will create them interactively  </p><div class="highlight"><pre><code class="language-bash"> git-chglog --init</code></pre></div><p class="ztext-empty-paragraph"><br></p><p data-pid="2tBhUGbY"><b>Have a shot：</b></p><div class="highlight"><pre><code class="language-bash"> <span class="c1"># git-chglog --init</span>
 ? What is the URL of your repository? https://github.com/cubxxw/go-vue-admin
 ? What is your favorite style? github
 ? Choose the format of your favorite commit message &lt;type&gt;<span class="o">(</span>&lt;scope&gt;<span class="o">)</span>: &lt;subject&gt;
 ? What is your favorite template style? keep-a-changelog
 ? Do you include Merge Commit in CHANGELOG? Yes
 ? Do you include Revert Commit in CHANGELOG? Yes
 ? In which directory <span class="k">do</span> you output configuration files and templates? y
 ​
 ✨  Configuration file and template generation completed!
   ✔ y/config.yml
   ✔ y/CHANGELOG.tpl.md</code></pre></div><p class="ztext-empty-paragraph"><br></p><p data-pid="GFNDE1YE"><b>U Look !</b></p><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><p data-pid="7g-5jQ-3">You are now ready for configuration files and templates!</p><p data-pid="w0p9Eslz">Let's immediately generate a CHANGELOG of your project. By doing the following simple command, Markdown for your CHANGELOG is displayed on stdout.</p><div class="highlight"><pre><code class="language-bash"> git-chglog</code></pre></div><p data-pid="qA3CuRjR">Use <code>-o</code> (<code>--output</code>) option if you want to output to a file instead of stdout.</p><div class="highlight"><pre><code class="language-bash"> git-chglog -o CHANGELOG.md</code></pre></div><p class="ztext-empty-paragraph"><br></p><h2><b>CLI Usages</b></h2><div class="highlight"><pre><code class="language-bash"> $ git-chglog --help
 ​
 USAGE:
   git-chglog <span class="o">[</span>options<span class="o">]</span> &lt;tag query&gt;
 ​
     There are the following specification methods <span class="k">for</span> &lt;tag query&gt;.
 ​
     1. &lt;old&gt;..&lt;new&gt; - Commit contained in &lt;old&gt; tags from &lt;new&gt;.
     2. &lt;name&gt;..     - Commit from the &lt;name&gt; to the latest tag.
     3. ..&lt;name&gt;     - Commit from the oldest tag to &lt;name&gt;.
     4. &lt;name&gt;       - Commit contained in &lt;name&gt;.
 ​
 OPTIONS:
   --init                      generate the git-chglog configuration file in interactive <span class="o">(</span>default: <span class="nb">false</span><span class="o">)</span>
   --path value                Filter commits by path<span class="o">(</span>s<span class="o">)</span>. Can use multiple times.
   --config value, -c value    specifies a different configuration file to pick up <span class="o">(</span>default: <span class="s2">".chglog/config.yml"</span><span class="o">)</span>
   --template value, -t value  specifies a template file to pick up. If not specified, use the one in config
   --repository-url value      specifies git repo URL. If not specified, use <span class="s1">'repository_url'</span> in config
   --output value, -o value    output path and filename <span class="k">for</span> the changelogs. If not specified, output to stdout
   --next-tag value            treat unreleased commits as specified tags <span class="o">(</span>EXPERIMENTAL<span class="o">)</span>
   --silent                    disable stdout output <span class="o">(</span>default: <span class="nb">false</span><span class="o">)</span>
   --no-color                  disable color output <span class="o">(</span>default: <span class="nb">false</span><span class="o">)</span> <span class="o">[</span><span class="nv">$NO_COLOR</span><span class="o">]</span>
   --no-emoji                  disable emoji output <span class="o">(</span>default: <span class="nb">false</span><span class="o">)</span> <span class="o">[</span><span class="nv">$NO_EMOJI</span><span class="o">]</span>
   --no-case                   disable <span class="k">case</span> sensitive filters <span class="o">(</span>default: <span class="nb">false</span><span class="o">)</span>
   --tag-filter-pattern value  Regular expression of tag filter. Is specified, only matched tags will be picked
   --jira-url value            Jira URL <span class="o">[</span><span class="nv">$JIRA_URL</span><span class="o">]</span>
   --jira-username value       Jira username <span class="o">[</span><span class="nv">$JIRA_USERNAME</span><span class="o">]</span>
   --jira-token value          Jira token <span class="o">[</span><span class="nv">$JIRA_TOKEN</span><span class="o">]</span>
   --sort value                Specify how to sort tags<span class="p">;</span> currently supports <span class="s2">"date"</span> or by <span class="s2">"semver"</span> <span class="o">(</span>default: date<span class="o">)</span>
   --help, -h                  show <span class="nb">help</span> <span class="o">(</span>default: <span class="nb">false</span><span class="o">)</span>
   --version, -v               print the version <span class="o">(</span>default: <span class="nb">false</span><span class="o">)</span>
 ​
 EXAMPLE:
 ​
   $ git-chglog
 ​
     If &lt;tag query&gt; is not specified, it corresponds to all tags.
     This is the simplest example.
 ​
   $ git-chglog 1.0.0..2.0.0
 ​
     The above is a <span class="nb">command</span> to generate CHANGELOG including commit of 1.0.0 to 2.0.0.
 ​
   $ git-chglog 1.0.0
 ​
     The above is a <span class="nb">command</span> to generate CHANGELOG including commit of only 1.0.0.
 ​
   $ git-chglog <span class="k">$(</span>git describe --tags <span class="k">$(</span>git rev-list --tags --max-count<span class="o">=</span>1<span class="k">))</span>
 ​
     The above is a <span class="nb">command</span> to generate CHANGELOG with the commit included in the latest tag.
 ​
   $ git-chglog --output CHANGELOG.md
 ​
     The above is a <span class="nb">command</span> to output to CHANGELOG.md instead of standard output.
 ​
   $ git-chglog --config custom/dir/config.yml
 ​
     The above is a <span class="nb">command</span> that uses a configuration file placed other than <span class="s2">".chglog/config.yml"</span>.
 ​
   $ git-chglog --path path/to/my/component --output CHANGELOG.component.md
 ​
     Filter commits by specific paths or files in git and output to a component specific changelog.</code></pre></div><p class="ztext-empty-paragraph"><br></p><h2><b>tag query </b></h2><p data-pid="O6w3yki6">You can specify which commits to include in the generation of CHANGELOG using <code>&lt;tag query&gt;</code>.</p><p data-pid="BTaKdjN-">The table below shows Query patterns and summaries, and Query examples.</p><table data-draft-node="block" data-draft-type="table" data-size="normal" data-row-style="normal"><tbody><tr><th>Query</th><th>Description 描述</th><th>Example</th></tr><tr><td>&lt;old&gt;..&lt;new&gt;</td><td>Commit contained in &lt;new&gt; tags from &lt;old&gt;. 提</td><td>$ git-chglog 1.0.0..2.0.0</td></tr><tr><td>&lt;name&gt;..</td><td>Commit from the &lt;name&gt; to the latest tag. 从</td><td>$ git-chglog 1.0.0..</td></tr><tr><td>..&lt;name&gt;</td><td>Commit from the oldest tag to &lt;name&gt;.</td><td>$ git-chglog ..2.0.0</td></tr><tr><td>&lt;name&gt;</td><td>Commit contained in &lt;name&gt;.</td><td>$ git-chglog 1.0.0</td></tr></tbody></table><p class="ztext-empty-paragraph"><br></p><h2><b>Configuration 配置</b></h2><p data-pid="vDAdfilX">The <code>git-chglog</code> configuration is a yaml file. The default location is <code>.chglog/config.yml</code>.</p><p data-pid="L6iAsFT8">Below is a complete list that you can use with <code>git-chglog</code>.</p><div class="highlight"><pre><code class="language-yaml"><span class="w"> </span><span class="nt">bin</span><span class="p">:</span><span class="w"> </span><span class="l">git</span><span class="w">
</span><span class="w"> </span><span class="nt">style</span><span class="p">:</span><span class="w"> </span><span class="s2">""</span><span class="w">
</span><span class="w"> </span><span class="nt">template</span><span class="p">:</span><span class="w"> </span><span class="l">CHANGELOG.tpl.md</span><span class="w">
</span><span class="w"> </span><span class="nt">info</span><span class="p">:</span><span class="w">
</span><span class="w">   </span><span class="nt">title</span><span class="p">:</span><span class="w"> </span><span class="l">CHANGELOG</span><span class="w">
</span><span class="w">   </span><span class="nt">repository_url</span><span class="p">:</span><span class="w"> </span><span class="l">https://github.com/git-chglog/git-chglog</span><span class="w">
</span><span class="w"> </span><span class="l">​</span><span class="w">
</span><span class="w"> </span><span class="nt">options</span><span class="p">:</span><span class="w">
</span><span class="w">   </span><span class="nt">tag_filter_pattern</span><span class="p">:</span><span class="w"> </span><span class="s1">'^v'</span><span class="w">
</span><span class="w">   </span><span class="nt">sort</span><span class="p">:</span><span class="w"> </span><span class="s2">"date"</span><span class="w">
</span><span class="w"> </span><span class="l">​</span><span class="w">
</span><span class="w">   </span><span class="nt">commits</span><span class="p">:</span><span class="w">
</span><span class="w">     </span><span class="nt">filters</span><span class="p">:</span><span class="w">
</span><span class="w">       </span><span class="nt">Type</span><span class="p">:</span><span class="w">
</span><span class="w">         </span>- <span class="l">feat</span><span class="w">
</span><span class="w">     </span><span class="nt">sort_by</span><span class="p">:</span><span class="w"> </span><span class="l">Scope</span><span class="w">
</span><span class="w"> </span><span class="l">​</span><span class="w">
</span><span class="w">   </span><span class="nt">commit_groups</span><span class="p">:</span><span class="w">
</span><span class="w">     </span><span class="nt">group_by</span><span class="p">:</span><span class="w"> </span><span class="l">Type</span><span class="w">
</span><span class="w">     </span><span class="nt">sort_by</span><span class="p">:</span><span class="w"> </span><span class="l">Title</span><span class="w">
</span><span class="w">     </span><span class="nt">title_order</span><span class="p">:</span><span class="w">
</span><span class="w">       </span>- <span class="l">feat</span><span class="w">
</span><span class="w">     </span><span class="nt">title_maps</span><span class="p">:</span><span class="w">
</span><span class="w">       </span><span class="nt">feat</span><span class="p">:</span><span class="w"> </span><span class="l">Features</span><span class="w">
</span><span class="w"> </span><span class="l">​</span><span class="w">
</span><span class="w">   </span><span class="nt">header</span><span class="p">:</span><span class="w">
</span><span class="w">     </span><span class="nt">pattern</span><span class="p">:</span><span class="w"> </span><span class="s2">"&lt;regexp&gt;"</span><span class="w">
</span><span class="w">     </span><span class="nt">pattern_maps</span><span class="p">:</span><span class="w">
</span><span class="w">       </span>- <span class="l">PropName</span><span class="w">
</span><span class="w"> </span><span class="l">​</span><span class="w">
</span><span class="w">   </span><span class="nt">issues</span><span class="p">:</span><span class="w">
</span><span class="w">     </span><span class="nt">prefix</span><span class="p">:</span><span class="w">
</span><span class="w">       </span>- <span class="c">#</span><span class="w">
</span><span class="w"> </span><span class="l">​</span><span class="w">
</span><span class="w">   </span><span class="nt">refs</span><span class="p">:</span><span class="w">
</span><span class="w">     </span><span class="nt">actions</span><span class="p">:</span><span class="w">
</span><span class="w">       </span>- <span class="l">Closes</span><span class="w">
</span><span class="w">       </span>- <span class="l">Fixes</span><span class="w">
</span><span class="w"> </span><span class="l">​</span><span class="w">
</span><span class="w">   </span><span class="nt">merges</span><span class="p">:</span><span class="w">
</span><span class="w">     </span><span class="nt">pattern</span><span class="p">:</span><span class="w"> </span><span class="s2">"^Merge branch '(\\w+)'$"</span><span class="w">
</span><span class="w">     </span><span class="nt">pattern_maps</span><span class="p">:</span><span class="w">
</span><span class="w">       </span>- <span class="l">Source</span><span class="w">
</span><span class="w"> </span><span class="l">​</span><span class="w">
</span><span class="w">   </span><span class="nt">reverts</span><span class="p">:</span><span class="w">
</span><span class="w">     </span><span class="nt">pattern</span><span class="p">:</span><span class="w"> </span><span class="s2">"^Revert \"([\\s\\S]*)\"$"</span><span class="w">
</span><span class="w">     </span><span class="nt">pattern_maps</span><span class="p">:</span><span class="w">
</span><span class="w">       </span>- <span class="l">Header</span><span class="w">
</span><span class="w"> </span><span class="l">​</span><span class="w">
</span><span class="w">   </span><span class="nt">notes</span><span class="p">:</span><span class="w">
</span><span class="w">     </span><span class="nt">keywords</span><span class="p">:</span><span class="w">
</span><span class="w">       </span>- <span class="l">BREAKING CHANGE</span></code></pre></div><p class="ztext-empty-paragraph"><br></p><h3><b><code>bin</code></b></h3><p data-pid="BlY8pYe3">Git execution command.</p><table data-draft-node="block" data-draft-type="table" data-size="normal" data-row-style="normal"><tbody><tr><th>Required</th><th>Type</th><th>Default</th><th>Description</th></tr><tr><td>N</td><td>String</td><td>"git"</td><td>-</td></tr></tbody></table><h3><b><code>style</code></b></h3><p data-pid="hk1lQ5xJ">CHANGELOG style. Automatic linking of issues and notices, initial value setting such as merges etc. are done automatically.</p><table data-draft-node="block" data-draft-type="table" data-size="normal" data-row-style="normal"><tbody><tr><th>Required</th><th>Type</th><th>Default</th><th>Description</th></tr><tr><td>N</td><td>String</td><td>"none"</td><td>Should be "github" "gitlab" "bitbucket" "none"</td></tr></tbody></table><h3><b><code>template</code></b></h3><p data-pid="rITWlHIt">Path for the template file. It is specified by a relative path from the setting file. Absolute paths are also ok.</p><table data-draft-node="block" data-draft-type="table" data-size="normal" data-row-style="normal"><tbody><tr><th>Required</th><th>Type</th><th>Default</th><th>Description</th></tr><tr><td>N</td><td>String</td><td>"CHANGELOG.tpl.md"</td><td>-</td></tr></tbody></table><h3><b><code>info</code></b></h3><p data-pid="cnb3gBnr">Metadata for CHANGELOG. Depending on Style, it is sometimes used in processing, so it is recommended to specify it.</p><table data-draft-node="block" data-draft-type="table" data-size="normal" data-row-style="normal"><tbody><tr><th>Key</th><th>Required</th><th>Type</th><th>Default</th><th>Description</th></tr><tr><td>title</td><td>N</td><td>String</td><td>"CHANGELOG"</td><td>Title of CHANGELOG.</td></tr><tr><td>repository_url</td><td>N</td><td>String</td><td>none</td><td>URL of git repository.</td></tr></tbody></table><h3><b><code>options</code></b></h3><p data-pid="ovxEM1p-">Options used to process commits.</p><h3><b><code>options.sort</code></b></h3><p data-pid="6dldm3yI">Options concerning the acquisition and sort of commits.</p><table data-draft-node="block" data-draft-type="table" data-size="normal" data-row-style="normal"><tbody><tr><th>Required</th><th>Type</th><th>Default</th><th>Description</th></tr><tr><td>N</td><td>String</td><td>"date"</td><td>Defines how tags are sorted in the generated change log. Values: "date", "semver".</td></tr></tbody></table><h3><b><code>options.commits</code></b></h3><p data-pid="inlYFgV4">Options concerning the acquisition and sort of commits.</p><table data-draft-node="block" data-draft-type="table" data-size="normal" data-row-style="normal"><tbody><tr><th>Key</th><th>Required</th><th>Type</th><th>Default</th><th>Description</th></tr><tr><td>filters</td><td>N</td><td>Map in List</td><td>none</td><td>Filter by using Commit properties and values. Filtering is not done by specifying an empty value.</td></tr><tr><td>sort_by</td><td>N</td><td>String</td><td>"Scope"</td><td>Property name to use for sorting Commit. See Commit.</td></tr></tbody></table><h3><b><code>options.commit_groups</code></b></h3><p data-pid="WUwm8Jxz">Options for groups of commits.</p><table data-draft-node="block" data-draft-type="table" data-size="normal" data-row-style="normal"><tbody><tr><th>Key</th><th>Required</th><th>Type</th><th>Default</th><th>Description</th></tr><tr><td>group_by</td><td>N</td><td>String</td><td>"Type"</td><td>Property name of Commit to be grouped into CommitGroup. See CommitGroup.</td></tr><tr><td>sort_by</td><td>N</td><td>String</td><td>"Title"</td><td>Property name to use for sorting CommitGroup. See CommitGroup.</td></tr><tr><td>title_order</td><td>N</td><td>List</td><td>none</td><td>Predefined order of titles to use for sorting CommitGroup. Only if sort_by is Custom</td></tr><tr><td>title_maps</td><td>N</td><td>Map in List</td><td>none</td><td>Map for CommitGroup title conversion.</td></tr></tbody></table><h3><b><code>options.header</code></b></h3><p data-pid="YGWrHeXb">This option is used for parsing the commit header.</p><table data-draft-node="block" data-draft-type="table" data-size="normal" data-row-style="normal"><tbody><tr><th>Key</th><th>Required</th><th>Type</th><th>Default</th><th>Description</th></tr><tr><td>pattern</td><td>Y</td><td>String</td><td>none</td><td>A regular expression to use for parsing the commit header.</td></tr><tr><td>pattern_maps</td><td>Y</td><td>List</td><td>none</td><td>A rule for mapping the result of HeaderPattern to the property of Commit. See Commit.</td></tr></tbody></table><h3><b><code>options.issues</code></b></h3><p data-pid="uIpj8ONI">This option is used to detect issues.</p><table data-draft-node="block" data-draft-type="table" data-size="normal" data-row-style="normal"><tbody><tr><th>Key</th><th>Required</th><th>Type</th><th>Default</th><th>Description</th></tr><tr><td>prefix</td><td>N</td><td>List</td><td>none</td><td>Prefix used for issues. (e.g. #, #gh-)</td></tr></tbody></table><h3><b><code>options.refs</code></b></h3><p data-pid="itnubw04">This option is for parsing references.</p><table data-draft-node="block" data-draft-type="table" data-size="normal" data-row-style="normal"><tbody><tr><th>Key</th><th>Required</th><th>Type</th><th>Default</th><th>Description</th></tr><tr><td>actions</td><td>N</td><td>List</td><td>none</td><td>Word list of Ref.Action. See Ref.</td></tr></tbody></table><h3><b><code>options.merges</code></b></h3><p data-pid="Pod0kuxH">Options to detect and parse merge commits.</p><table data-draft-node="block" data-draft-type="table" data-size="normal" data-row-style="normal"><tbody><tr><th>Key</th><th>Required</th><th>Type</th><th>Default</th><th>Description</th></tr><tr><td>pattern</td><td>N</td><td>String</td><td>none</td><td>Similar to options.header.pattern.</td></tr><tr><td>pattern_maps</td><td>N</td><td>List</td><td>none</td><td>Similar to options.header.pattern_maps.</td></tr></tbody></table><h3><b><code>options.reverts</code></b></h3><p data-pid="8xoe1GqG">Options to detect and parse revert commits.</p><table data-draft-node="block" data-draft-type="table" data-size="normal" data-row-style="normal"><tbody><tr><th>Key</th><th>Required</th><th>Type</th><th>Default</th><th>Description</th></tr><tr><td>pattern</td><td>N</td><td>String</td><td>none</td><td>Similar to options.header.pattern.</td></tr><tr><td>pattern_maps</td><td>N</td><td>List</td><td>none</td><td>Similar to options.header.pattern_maps.</td></tr></tbody></table><h3><b><code>options.notes</code></b></h3><p data-pid="TEPDzPMK">Options to detect notes contained in commit bodies.</p><table data-draft-node="block" data-draft-type="table" data-size="normal" data-row-style="normal"><tbody><tr><th>Key</th><th>Required</th><th>Type</th><th>Default</th><th>Description</th></tr><tr><td>keywords</td><td>N</td><td>List</td><td>none</td><td>Keyword list to find Note. A semicolon is a separator, like &lt;keyword&gt;: (e.g. BREAKING CHANGE).</td></tr></tbody></table><h2><b>Templates</b></h2><p data-pid="WXkfMdeX">The <code>git-chglog</code> template uses the <code>text/template</code> package and enhanced templating functions provided by <a href="http://masterminds.github.io/sprig" target="_blank">Sprig</a>. For basic usage please refer to the following.</p><ul><li data-pid="U-br0go5"><a href="https://golang.org/pkg/text/template/" target="_blank">text/template</a></li><li data-pid="0OaYgtVr"><a href="http://masterminds.github.io/sprig" target="_blank">Sprig</a></li></ul><p data-pid="ljT7RPrJ">We have implemented the following custom template functions. These override functions provided by <a href="http://masterminds.github.io/sprig" target="_blank">Sprig</a>.</p><table data-draft-node="block" data-draft-type="table" data-size="normal" data-row-style="normal"><tbody><tr><th>Name</th><th>Signature</th><th>Description</th></tr><tr><td>contains</td><td>func(s, substr string) bool</td><td>Reports whether substr is within s using strings.Contains</td></tr><tr><td>datetime</td><td>func(layout string, input time.Time) string</td><td>Generate a formatted Date string based on layout</td></tr><tr><td>hasPrefix</td><td>func(s, prefix string) bool</td><td>Tests whether the string s begins with prefix using strings.HasPrefix</td></tr><tr><td>hasSuffix</td><td>func(s, suffix string) bool</td><td>Tests whether the string s ends with suffix. using strings.HasPrefix</td></tr><tr><td>indent</td><td>func(s string, n int) string</td><td>Indent all lines of s by n spaces</td></tr><tr><td>replace</td><td>func(s, old, new string, n int) string</td><td>Replace old with new within string s, n times using strings.Replace</td></tr><tr><td>upperFirst</td><td>func(s string) string</td><td>Upper case the first character of a string</td></tr></tbody></table><p data-pid="Mq3H43Vq">If you are not satisfied with the prepared template please try customizing one.</p><p class="ztext-empty-paragraph"><br></p><hr><p class="ztext-empty-paragraph"><br></p><p data-pid="7aVBKh--">The basic templates are as follows.</p><p data-pid="D6VKtP3Z"><b>Example:</b></p><div class="highlight"><pre><code class="language-text">{{ if .Versions -}}
&lt;a name="unreleased"&gt;&lt;/a&gt;
## [Unreleased]

{{ if .Unreleased.CommitGroups -}}
{{ range .Unreleased.CommitGroups -}}
### {{ .Title }}
{{ range .Commits -}}
- {{ if .Scope }}**{{ .Scope }}:** {{ end }}{{ .Subject }}
{{ end }}
{{ end -}}
{{ end -}}
{{ end -}}

{{ range .Versions }}
&lt;a name="{{ .Tag.Name }}"&gt;&lt;/a&gt;
## {{ if .Tag.Previous }}[{{ .Tag.Name }}]{{ else }}{{ .Tag.Name }}{{ end }} - {{ datetime "2006-01-02" .Tag.Date }}
{{ range .CommitGroups -}}
### {{ .Title }}
{{ range .Commits -}}
- {{ if .Scope }}**{{ .Scope }}:** {{ end }}{{ .Subject }}
{{ end }}
{{ end -}}

{{- if .RevertCommits -}}
### Reverts
{{ range .RevertCommits -}}
- {{ .Revert.Header }}
{{ end }}
{{ end -}}

{{- if .MergeCommits -}}
### Pull Requests
{{ range .MergeCommits -}}
- {{ .Header }}
{{ end }}
{{ end -}}

{{- if .NoteGroups -}}
{{ range .NoteGroups -}}
### {{ .Title }}
{{ range .Notes }}
{{ .Body }}
{{ end }}
{{ end -}}
{{ end -}}
{{ end -}}

{{- if .Versions }}
[Unreleased]: {{ .Info.RepositoryURL }}/compare/{{ $latest := index .Versions 0 }}{{ $latest.Tag.Name }}...HEAD
{{ range .Versions -}}
{{ if .Tag.Previous -}}
[{{ .Tag.Name }}]: {{ $.Info.RepositoryURL }}/compare/{{ .Tag.Previous.Name }}...{{ .Tag.Name }}
{{ end -}}
{{ end -}}
{{ end -}}</code></pre></div><p data-pid="M8ixfJ2N">See the godoc <a href="https://godoc.org/github.com/git-chglog/git-chglog#RenderData" target="_blank">RenderData</a> documentation for available variables.</p><h2><b>Supported Styles</b></h2><table data-draft-node="block" data-draft-type="table" data-size="normal" data-row-style="normal"><tbody><tr><th>Name</th><th>Status</th><th>Features</th></tr><tr><td>GitHub</td><td>✅</td><td>Mentions automatic link. Automatic link to references.</td></tr><tr><td>GitLab</td><td>✅</td><td>Mentions automatic link. Automatic link to references.</td></tr><tr><td>Bitbucket</td><td>✅</td><td>Mentions automatic link. Automatic link to references.</td></tr></tbody></table><blockquote data-pid="7OmMRAtS">  Even with styles that are not yet supported, it is possible to make ordinary CHANGELOG.</blockquote><h2><b>Jira Integration</b></h2><p data-pid="nTojjDb4">Jira is a popular project management tool. When a project uses Jira to track feature development and bug fixes, it may also want to generate change log based information stored in Jira. With embedding a Jira story id in git commit header, the git-chglog tool may automatically fetch data of the story from Jira, those data then can be used to render the template.</p><p data-pid="y10RApYH">Take the following steps to add Jira integration:</p><h3><b>1. Change the header parse pattern to recognize Jira issue id in the configure file</b></h3><p data-pid="0hYDmQbM"><b>Where Jira issue is identical Jira story.</b></p><p data-pid="9Pw2QdK6">The following is a sample pattern:</p><div class="highlight"><pre><code class="language-text"> header:
   pattern: "^(?:(\\w*)|(?:\\[(.*)\\])?)\\:\\s(.*)$"
   pattern_maps:
     - Type
     - JiraIssueID
     - Subject</code></pre></div><p data-pid="VlAwjbRI">This sample pattern can match both forms of commit headers:</p><ul><li data-pid="S-McFMgW"><code>feat: new feature of something</code></li><li data-pid="Rg5QTQEE"><code>[JIRA-ID]: something</code></li></ul><h3><b>2. Add Jira configuration to the configure file</b></h3><p data-pid="Y7OHo6Nn">The following is a sample:</p><div class="highlight"><pre><code class="language-text"> jira:
   info:
     username: u
     token: p
     url: https://jira.com
   issue:
     type_maps:
       Task: fix
       Story: feat
     description_pattern: "&lt;changelog&gt;(.*)&lt;/changelog&gt;"</code></pre></div><p data-pid="E5jK0YHJ">Here you need to define Jira URL, access username and token (password). If you don't want to write your Jira access credential in configure file, you may define them with environment variables: <code>JIRA_URL</code>, <code>JIRA_USERNAME</code> and <code>JIRA_TOKEN</code>.</p><p data-pid="JX6pgSt2">You also needs to define a issue type map. In above sample, Jira issue type <code>Task</code> will be mapped to <code>fix</code> and <code>Story</code> will be mapped to <code>feat</code>.</p><p data-pid="28zfsK7B">As a Jira story's description could be very long, you might not want to include the entire description into change log. In that case, you may define <code>description_pattern</code> like above, so that only content embraced with <code>&lt;changelog&gt; ... &lt;/changelog&gt;</code> will be included.</p><h3><b>3. Update the template to show Jira data</b></h3><p data-pid="7cDRh-Rq">In the template, if a commit contains a Jira issue id, then you may show Jira data. For example:</p><div class="highlight"><pre><code class="language-bash"> <span class="o">{{</span> range .CommitGroups -<span class="o">}}</span>
 <span class="c1">### {{ .Title }}</span>
 <span class="o">{{</span> range .Commits -<span class="o">}}</span>
 - <span class="o">{{</span> <span class="k">if</span> .Scope <span class="o">}}</span>**<span class="o">{{</span> .Scope <span class="o">}}</span>:** <span class="o">{{</span> end <span class="o">}}{{</span> .Subject <span class="o">}}</span>
 <span class="o">{{</span> <span class="k">if</span> .JiraIssue <span class="o">}}</span> <span class="o">{{</span> .JiraIssue.Description <span class="o">}}</span>
 <span class="o">{{</span> end <span class="o">}}</span>
 <span class="o">{{</span> end <span class="o">}}</span>
 <span class="o">{{</span> end -<span class="o">}}</span></code></pre></div><p data-pid="w2yb2SFX">Within a <code>Commit</code>, the following Jira data can be used in template:</p><ul><li data-pid="JQvgp23p"><code>.JiraIssue.Summary</code> - Summary of the Jira story</li><li data-pid="UL2SPj_o"><code>.JiraIssue.Description</code> - Description of the Jira story</li><li data-pid="IQAUzjIO"><code>.JiraIssue.Type</code> - Original type of the Jira story, and <code>.Type</code> will be mapped type.</li><li data-pid="zIQtFrWD"><code>.JiraIssue.Labels</code> - A list of strings, each is a Jira label.</li></ul><h2><b>END Links</b></h2><ul><li data-pid="P8Chxzqy"><a href="https://godoc.org/github.com/git-chglog/git-chglog" target="_blank"><span class="invisible">https://</span><span class="visible">godoc.org/github.com/gi</span><span class="invisible">t-chglog/git-chglog</span><span class="ellipsis"></span></a></li><li data-pid="64PXljsI"><a href="https://github.com/git-chglog/git-chglog" target="_blank"><span class="invisible">https://</span><span class="visible">github.com/git-chglog/g</span><span class="invisible">it-chglog</span><span class="ellipsis"></span></a></li></ul></div> </details> 
 <hr /> 

 #### - [IAM 项目部署](https://zhuanlan.zhihu.com/p/606959150) 
 <details><summary>توضیحات</summary> <div><ul><li data-pid="stP5700C"><a href="https://github.com/cubxxw/iam" target="_blank">  开源地址</a></li></ul><h2><b>第2节 IAM项目部署</b></h2><blockquote data-pid="MgZ2CD9Y">❤️  During the winter vacation, I followed up and learned two projects: tiktok project and IAM project, and summarized and practiced the CloudNative project and Go language. I learned a lot in the process.Myblog:<a href="http://nsddd.top/" target="_blank">http://nsddd.top</a></blockquote><h2><b>前言</b></h2><ul><li data-pid="l0KtYmFE"><a href="https://github.com/cubxxw/cs-awesome-Block_Chain" target="_blank">⭕   菜鸟成长手册  CS系列 、云原生系列、区块链系列、web3系列 、Golang系列 </a></li><li data-pid="5YF5_hCz"><a href="https://go.nsddd.top/" target="_blank">  Go语言基础-进阶</a><br></li><ul><li data-pid="4YmJzOx7"><a href="https://github.com/cubxxw/cs-awesome-Block_Chain/blob/master/TOC.md" target="_blank"> ️GO 基础部分 </a></li><li data-pid="x1m0OmJB"><a href="https://github.com/cubxxw/cs-awesome-Block_Chain/blob/master/Gomd_super/README.md" target="_blank"> ️Go语言100篇进阶 </a></li><li data-pid="jGdpNvLW"><a href="https://github.com/cubxxw/cs-awesome-Block_Chain/blob/master/go-advancend/README.md" target="_blank"> ️Go 高级篇</a></li></ul></ul><p class="ztext-empty-paragraph"><br></p><ul><li data-pid="BDfHMtci"><a href="https://docker.nsddd.top/" target="_blank">  docker &amp; k8s &amp; 云原生</a></li><li data-pid="HH3is7A9"><a href="https://github.com/cubxxw/iam" target="_blank">IAM github地址</a></li><li data-pid="vEq0z4so"><a href="https://time.geekbang.org/column/article/378082" target="_blank">课程地址</a></li></ul><p class="ztext-empty-paragraph"><br></p><h2><b>基本开发环境</b></h2><p data-pid="NfW5j-Sx"><b>查看我的环境：</b></p><div class="highlight"><pre><code class="language-bash">root@cubmaster01:/# uname -va
Linux cubmaster01 5.4.0-135-generic <span class="c1">#152-Ubuntu SMP Wed Nov 23 20:19:22 UTC 2022 x86_64 x86_64 x86_64 GNU/Linux</span>
root@cubmaster01:/# go version 
go version go1.19.3 linux/amd64
root@cubmaster01:/# git version
git version 2.25.1</code></pre></div><p class="ztext-empty-paragraph"><br></p><h3><b>用户权限</b></h3><p data-pid="dCAPXIDB">使用普通用户登录和操作开发机也可以保证系统的安全性，这是一个比较好的习惯，所以我们在日常开发中也要尽量避免使用 Root 用户。</p><div class="highlight"><pre><code class="language-bash">oot@cubmaster01:/# useradd cubiam
root@cubmaster01:/# passwd cubiam
New password: 
Retype new password: 
passwd: password updated successfully</code></pre></div><p class="ztext-empty-paragraph"><br></p><h3><b>添加 sudoers</b></h3><p data-pid="4SloACQT">普通用户也要用到 Root 的一些权限，但 Root 用户的密码一般是由系统管理员维护并定期更改的，每次都向管理员询问密码又很麻烦。因此，我建议你将普通用户加入到 sudoers 中，这样普通用户就可以通过 sudo 命令来暂时获取 Root 的权限。具体来说，你可以执行如下命令添加：</p><div class="highlight"><pre><code class="language-bash">sed -i <span class="s1">'/^root.*ALL=(ALL).*ALL/a\cubaim\tALL=(ALL) \tALL'</span> /etc/sudoers</code></pre></div><p class="ztext-empty-paragraph"><br></p><h3><b>配置 <code>$HOME/.bashrc</code> 文件</b></h3><p data-pid="sFg6xoRO">我们登录新服务器后的第一步就是配置 <code>$HOME/.bashrc</code> 文件，以使 Linux 登录 shell 更加易用，例如配置 LANG 解决中文乱码，配置 PS1 可以避免整行都是文件路径，并将 <code>$HOME/bin</code> 加入到 PATH 路径中。配置后的内容如下：</p><div class="highlight"><pre><code class="language-bash"><span class="c1"># .bashrc</span>
 
<span class="c1"># User specific aliases and functions</span>
<span class="c1"># -i： 每次删除前提醒~</span>
<span class="nb">alias</span> <span class="nv">rm</span><span class="o">=</span><span class="s1">'rm -i'</span>
<span class="nb">alias</span> <span class="nv">cp</span><span class="o">=</span><span class="s1">'cp -i'</span>
<span class="nb">alias</span> <span class="nv">mv</span><span class="o">=</span><span class="s1">'mv -i'</span>
 
<span class="c1"># Source global definitions</span>
<span class="k">if</span> <span class="o">[</span> -f /etc/bashrc <span class="o">]</span><span class="p">;</span> <span class="k">then</span>
        . /etc/bashrc
<span class="k">fi</span>
 
<span class="c1"># User specific environment</span>
<span class="c1"># Basic envs</span>
<span class="nb">export</span> <span class="nv">LANG</span><span class="o">=</span><span class="s2">"en_US.UTF-8"</span> <span class="c1"># 设置系统语言为 en_US.UTF-8，避免终端出现中文乱码</span>
<span class="nb">export</span> <span class="nv">PS1</span><span class="o">=</span><span class="s1">'[\u@dev \W]\$ '</span> <span class="c1"># 默认的 PS1 设置会展示全部的路径，为了防止过长，这里只展示："用户名@dev 最后的目录名"</span>
<span class="nb">export</span> <span class="nv">WORKSPACE</span><span class="o">=</span><span class="s2">"</span><span class="nv">$HOME</span><span class="s2">/workspace"</span> <span class="c1"># 设置工作目录</span>
<span class="nb">export</span> <span class="nv">PATH</span><span class="o">=</span><span class="nv">$HOME</span>/bin:<span class="nv">$PATH</span> <span class="c1"># 将 $HOME/bin 目录加入到 PATH 变量中</span>
 
<span class="c1"># Default entry folder</span>
<span class="nb">cd</span> <span class="nv">$WORKSPACE</span> <span class="c1"># 登录系统，默认进入 workspace 目录</span></code></pre></div><p data-pid="d-Ch3zVs">有一点需要我们注意，在 export PATH 时，最好把 <code>$PATH</code> 放到最后，因为我们添加到目录中的命令是期望被优先搜索并使用的。配置完 <code>$HOME/.bashrc</code> 后，我们还需要创建工作目录 workspace。将工作文件统一放在 <code>$HOME/workspace</code> 目录中，有几点好处。</p><ol><li data-pid="qWXPvQmQ">可以使我们的 <code>HOME</code>目录保持整洁，便于以后的文件查找和分类。</li><li data-pid="NlxrvsAK">如果哪一天 /分区空间不足，可以将整个 workspace 目录 mv 到另一个分区中，并在 /分区中保留软连接，例如：/home/going/workspace -&gt; /data/workspace/。</li><li data-pid="TYVAHryl">如果哪天想备份所有的工作文件，可以直接备份 workspace。</li></ol><p data-pid="hE66Z9RY">具体的操作指令是 <code>mkdir -p $HOME/workspace</code>。配置好 <code>HOME/.bashrc</code> 文件后，我们就可以执行 bash 命令将配置加载到当前 shell 中了。</p><p class="ztext-empty-paragraph"><br></p><h3><b>安装 git</b></h3><p data-pid="PukF8lZ2">因为安装 IAM 系统、执行 go get 命令、安装 protobuf 工具等都是通过 Git 来操作的，所以接下来我们还需要安装 Git。由于低版本的 Git 不支持 <code>--unshallow</code> 参数，而 go get 在安装 Go 包时会用到 <code>git fetch --unshallow</code> 命令，因此我们要确保安装一个高版本的 Git，具体的安装方法如下：</p><div class="highlight"><pre><code class="language-bash">$ <span class="nb">cd</span> /tmp
$ wget --no-check-certificate https://mirrors.edge.kernel.org/pub/software/scm/git/git-2.39.0.tar.gz
$ tar -xvzf git-2.39.0.tar.gz
$ <span class="nb">cd</span> git-2.39.0/
$ ./configure
$ make
$ sudo make install
$ git --version          <span class="c1"># 输出 git 版本号，说明安装成功</span>
git version 2.39.0
tee -a <span class="nv">$HOME</span>/.bashrc <span class="s">&lt;&lt;'EOF'
</span><span class="s"># Configure for git
</span><span class="s">export PATH=/usr/local/libexec/git-core:$PATHEOF</span></code></pre></div><p data-pid="DERpnCpb">配置 Git。我们直接执行如下命令配置 Git</p><div class="highlight"><pre><code class="language-bash">git config --global user.name <span class="s2">"Xinwei Xiong"</span>    <span class="c1"># 用户名改成自己的</span>
git config --global user.email <span class="s2">"3293172751nss@gmail.com"</span>    <span class="c1"># 邮箱改成自己的</span>
git config --global credential.helper store    <span class="c1"># 设置 Git，保存用户名和密码</span>
git config --global core.longpaths <span class="nb">true</span> <span class="c1"># 解决 Git 中 'Filename too long' 的错误</span></code></pre></div><p data-pid="gelvKrqK">除了按照上述步骤配置 Git 之外，我们还有几点需要注意。首先，在 Git 中，我们会把非 ASCII 字符叫做 Unusual 字符。这类字符在 Git 输出到终端的时候默认是用 8 进制转义字符输出的（以防乱码），但现在的终端多数都支持直接显示非 ASCII 字符，所以我们可以关闭掉这个特性，具体的命令如下：</p><div class="highlight"><pre><code class="language-bash">git config --global core.quotepath off</code></pre></div><p data-pid="RogmTUnu">其次，GitHub 限制最大只能克隆 100M 的单个文件，为了能够克隆大于 100M 的文件，我们还需要安装 Git Large File Storage，安装方式如下：</p><div class="highlight"><pre><code class="language-bash">git lfs install --skip-repo</code></pre></div><p class="ztext-empty-paragraph"><br></p><h2><b>go语言环境变量设置和含义</b></h2><p data-pid="NaiGe2D0"><b>我们在设置Go语言的环境变量：</b></p><div class="highlight"><pre><code class="language-bash">$ tee -a <span class="nv">$HOME</span>/.bashrc <span class="s">&lt;&lt;'EOF'
</span><span class="s"># Go envs
</span><span class="s">export GOVERSION=go1.18.3 # Go 版本设置
</span><span class="s">export GO_INSTALL_DIR=$HOME/go # Go 安装目录
</span><span class="s">export GOROOT=$GO_INSTALL_DIR/$GOVERSION # GOROOT 设置
</span><span class="s">export GOPATH=$WORKSPACE/golang # GOPATH 设置
</span><span class="s">export PATH=$GOROOT/bin:$GOPATH/bin:$PATH # 将 Go 语言自带的和通过 go install 安装的二进制文件加入到 PATH 路径中
</span><span class="s">export GO111MODULE="on" # 开启 Go moudles 特性
</span><span class="s">export GOPROXY=https://goproxy.cn,direct # 安装 Go 模块时，代理服务器设置
</span><span class="s">export GOPRIVATE=
</span><span class="s">export GOSUMDB=off # 关闭校验 Go 依赖包的哈希值
</span><span class="s">EOF</span></code></pre></div><p data-pid="6x940fWw">为什么要增加这么多环境变量呢？这是因为，Go 语言是通过一系列的环境变量来控制 Go 编译器行为的。因此，我们一定要理解每一个环境变量的含义。</p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic4.zhimg.com/v2-15e13989d233e6333fae92fc2b3d46bb_r.jpg" data-caption="" data-size="normal" width="1088" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p data-pid="tKWkbx8F">因为 Go 以后会用 Go modules 来管理依赖，所以我建议你将 GO111MODULE 设置为 on。</p><p data-pid="-u7tx_c5">在使用模块的时候，<code>$GOPATH</code> 是无意义的，不过它还是会把下载的依赖储存在 <code>$GOPATH/pkg/mod</code> 目录中，也会把 go install 的二进制文件存放在 <code>$GOPATH/bin</code> 目录中。</p><p data-pid="Q6PeNba0">另外，我们还要将 <code>$GOPATH/bin</code>、<code>$GOROOT/bin</code> 加入到 Linux 可执行文件搜索路径中。这样一来，我们就可以直接在 bash shell 中执行 go 自带的命令，以及通过 go install 安装的命令。</p><p class="ztext-empty-paragraph"><br></p><h2><b>vim go-plug</b></h2><p data-pid="DKoDE3OA">安装：</p><div class="highlight"><pre><code class="language-go"><span class="nx">git</span> <span class="nx">clone</span> <span class="o">--</span><span class="nx">depth</span><span class="p">=</span><span class="mi">1</span> <span class="nx">https</span><span class="p">:</span><span class="c1">//github.com/fatih/vim-go.git ~/.vim/pack/plugins/start/vim-go
</span></code></pre></div><p data-pid="XOYHYgBn">vim-go 会用到一些 Go 工具，比如在函数跳转时会用到 guru、godef 工具，在格式化时会用到 goimports，所以你也需要安装这些工具。安装方式如下：执行 <code>vi /tmp/test.go</code>，然后输入 <code>:GoInstallBinaries</code> 安装 vim-go 需要的工具。安装后的 Go IDE 常用操作的按键映射如下表所示：</p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic3.zhimg.com/v2-dd199cbbdc8203ac884f4891c469cbd2_r.jpg" data-caption="" data-size="normal" width="1075" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><h2><b>ProtoBuf 编译环境安装</b></h2><p data-pid="6I9Ee7N0">接着，我们再来安装 <code>protobuf</code> 的编译器 <code>protoc</code>。<code>protoc</code> 需要 <code>protoc-gen-go</code> 来完成 Go 语言的代码转换，因此我们需要安装 <code>protoc</code> 和 <code>protoc-gen-go</code> 这 2 个工具。它们的安装方法比较简单，你直接看我下面给出的代码和操作注释就可以了。</p><blockquote data-pid="phfEEWZ9">Protocol Buffers（缩写为 protobuf）是 Google 开发的一种数据交换格式。它是一种结构化数据存储格式，可用于结构化数据串行化，或者说把数据从程序中“变成”字节流，又可以把字节流重新“变成”程序中的数据。由于 protobuf 是跨语言的，所以它可以被多种语言的程序使用。</blockquote><div class="highlight"><pre><code class="language-bash"><span class="c1"># 第一步：安装 protobuf</span>
$ <span class="nb">cd</span> /tmp/
$ git clone -b v3.21.1 --depth<span class="o">=</span><span class="m">1</span> https://github.com/protocolbuffers/protobuf
$ <span class="nb">cd</span> protobuf
$ ./autogen.sh
$ ./configure
$ make
$ sudo make install
$ protoc --version <span class="c1"># 查看 protoc 版本，成功输出版本号，说明安装成功</span>
libprotoc 3.21.1

<span class="c1"># 第二步：安装 protoc-gen-go</span>
$ go install github.com/golang/protobuf/protoc-gen-go@v1.5.2</code></pre></div><p class="ztext-empty-paragraph"><br></p><h2><b>IAM手动部署</b></h2><blockquote data-pid="U8Odykid">和Kubernetes一样，可以支持手动部署和自动部署。</blockquote><p data-pid="Ta0SMcJI">IAM 系统是一个企业级的项目，有一定的复杂度，安装的话需要小心~</p><p data-pid="Ke7b_yDW"><b>部署的步骤：</b></p><ol><li data-pid="Mej-dr2Q">安装和配置数据库：我们需要安装和配置 MariaDB、Redis 和 MongoDB。</li><li data-pid="vNltnIRl">安装和配置 IAM 服务：我们需要安装和配置 iam-apiserver、iam-authz-server、iam-pump、iamctl 和 man 文件。</li></ol><blockquote data-pid="-ul0yw4C">有的人直接将整个环境打包了：<br>我自己是在 docker 容器中部署的，我把项目部署好的容器打包上传了，有需要的同学可以直接拉下来用（<code>docker pull mjcjm/centos-go-project</code>），启动参数一定要用：<code>docker run -tid --name</code> 容器名称  <code>-v /sys/fs/cgroup:/sys/fs/cgroup  --privileged=true</code> 镜像 <code>id /usr/sbin/init</code>。 </blockquote><p class="ztext-empty-paragraph"><br></p><h3><b>下载项目代码</b></h3><p data-pid="cKL1RUDa">因为 IAM 的安装脚本存放在 iam 代码仓库中，安装需要的二进制文件也需要通过 iam 代码构建，所以在安装之前，我们需要先下载 iam 代码：</p><div class="highlight"><pre><code class="language-bash">$ <span class="nb">cd</span> <span class="nv">$WORKSPACE</span>
$ git clone https://github.com/cubxxw/iam.git
$ go work use ./iam</code></pre></div><p data-pid="NwVzoekT"><b>设置别名和环境变量：</b></p><div class="highlight"><pre><code class="language-bash">tee -a <span class="nv">$HOME</span>/.bashrc <span class="s">&lt;&lt; 'EOF'
</span><span class="s"># Alias for quick access
</span><span class="s">export GOSRC="$WORKSPACE/"
</span><span class="s">export IAM_ROOT="$HOME/workspces/iam"
</span><span class="s">alias mm="cd $HOME/workspces"
</span><span class="s">alias i="cd $HOME/workspces/iam"
</span><span class="s">EOF</span></code></pre></div><p data-pid="gqIBf0gV">在安装配置IAM系统之前需要你执行以下命令export <code>going</code> 用户的密码，这里假设密码是 <code>iam59!z$</code>：</p><div class="highlight"><pre><code class="language-bash"><span class="nb">export</span> <span class="nv">LINUX_PASSWORD</span><span class="o">=</span><span class="s1">'iam59!z </details> 
 <hr /> 
</span></code></pre></div><p data-pid="usMPyWx4">在项目开发中，像密码、密钥 Key 这类敏感信息，一般不会直接硬编码在系统中，而是通过环境变量的方式来使用。现网应用的配置文件是存放在一个安全的网络环境中，并且有访问授权流程，比较安全，这种配置文件中是可以配置密码等敏感信息的。</p><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h2><b>安装和配置数据库</b></h2><p data-pid="crLxXwKo">因为 IAM 系统用到了 MariaDB、Redis、MongoDB 数据库来存储数据，而 IAM 服务在启动时会先尝试连接这些数据库，所以为了避免启动时连接数据库失败，这里我们先来安装需要的数据库。</p><p class="ztext-empty-paragraph"><br></p><h3><b>MariaDB </b></h3><p data-pid="dpLzow9B"><b>mysql:</b></p><blockquote data-pid="goBSawd8">IAM 会把 REST 资源的定义信息存储在关系型数据库中，关系型数据库我选择了 MariaDB。为啥选择 MariaDB，而不是 MySQL 呢？。选择 MariaDB 一方面是因为它是发展最快的 MySQL 分支，相比 MySQL，它加入了很多新的特性，并且它能够完全兼容 MySQL，包括 API 和命令行。另一方面是因为 MariaDB 是开源的，而且迭代速度很快。</blockquote><div class="highlight"><pre><code class="language-bash"><span class="nb">cd</span> <span class="nv">$IAM_ROOT</span>
./scripts/install/mariadb.sh iam::mariadb::install</code></pre></div><p class="ztext-empty-paragraph"><br></p><h3><b>Redis</b></h3><p data-pid="gPy1lZBq">在 IAM 系统中，由于 iam-authz-server 是从 iam-apiserver 拉取并缓存用户的密钥 / 策略信息的，因此同一份密钥 / 策略数据会分别存在 2 个服务中，这可能会出现数据不一致的情况。数据不一致会带来一些问题，例如当我们通过 iam-apiserver 创建了一对密钥，但是这对密钥还没有被 iam-authz-server 缓存，这时候通过这对密钥访问 iam-authz-server 就会访问失败。</p><p data-pid="HUb6xayX">为了保证数据的一致性，我们可以使用 Redis 的发布订阅 (pub/sub) 功能进行消息通知。同时，iam-authz-server 也会将授权审计日志缓存到 Redis 中，所以也需要安装 Redis key-value 数据库。我们可以通过以下命令来安装和配置 Redis，并将 Redis 的初始密码设置为 <code>iam59!z$</code> ：</p><div class="highlight"><pre><code class="language-bash">$ <span class="nb">cd</span> <span class="nv">$IAM_ROOT</span>
$ ./scripts/install/redis.sh iam::redis::install</code></pre></div><p data-pid="oAEsiE_j">这里我们要注意，scripts/install/redis.sh 脚本中 iam::redis::install 函数对 Redis 做了一些配置，例如修改 Redis 使其以守护进程的方式运行、修改 Redis 的密码为 <code>iam59!z$</code>等，详细配置可参考函数 <code>iam::redis::install</code> 函数。</p><div class="highlight"><pre><code class="language-bash"> $ redis-cli -h 127.0.0.1 -p <span class="m">6379</span> -a <span class="s1">'iam59!z </details> 
 <hr /> 
</span> <span class="c1"># 连接 Redis，-h 指定主机，-p 指定监听端口，-a 指定登录密码</span></code></pre></div><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>安装和配置 MariaDB</b></h3><ul><li data-pid="6g-B-mt2"><a href="https://github.com/MariaDB/server" target="_blank">开源的 GitHub 地址</a></li></ul><p data-pid="L9Gvidh-">IAM 会把 REST 资源的定义信息存储在关系型数据库中，关系型数据库我选择了 MariaDB。为啥选择 MariaDB，而不是 MySQL 呢？。选择 MariaDB 一方面是因为它是发展最快的 MySQL 分支，相比 MySQL，它加入了很多新的特性，并且它能够完全兼容 MySQL，包括 API 和命令行。另一方面是因为 MariaDB 是开源的，而且迭代速度很快。首先，我们可以通过以下命令安装和配置 MariaDB，并将 Root 密码设置为 <code>1234</code>：</p><blockquote data-pid="dzAAQDZV">MariaDB vs Mysql:<br>MariaDB是一种关系型数据库管理系统，是MySQL的一个分支。两者在技术上基本相同，但MariaDB有一些额外的特性和功能。<br>一个明显的区别是MariaDB是一个开源项目，而MySQL是Oracle公司拥有和维护。<br>MariaDB还添加了一些新特性，如支持更高版本的SQL标准和更好的性能，还有一些安全性增强。<br>但是, 一般来说，MariaDB和MySQL的性能相当接近，因为它们使用相同的存储引擎。<br>在一些情况下，MariaDB可能会更快，因为它有一些额外的优化和特性，例如更新的SQL解析器和更快的查询优化器。<br>另外, 也有一些测试结果表明MariaDB的性能比MySQL更优秀，但是这取决于具体的场景和使用方式。<br>对于开发人员来说，两者的语法和API几乎相同，所以从MySQL迁移到MariaDB是非常简单的。<br>总的来说，MariaDB是MySQL的一个很好的替代品，它在继承了MySQL的优秀特性的同时，还添加了许多新功能。</blockquote><div class="highlight"><pre><code class="language-bash"><span class="nb">cd</span> <span class="nv">$IAM_ROOT</span><span class="p">;</span> ./scripts/install/mariadb.sh iam::mariadb::install</code></pre></div><p class="ztext-empty-paragraph"><br></p><h3><b>安装redis</b></h3><p data-pid="17VKW_D7">在 IAM 系统中，由于 iam-authz-server 是从 iam-apiserver 拉取并缓存用户的密钥/策略信息的，因此同一份密钥/策略数据会分别存在 2 个服务中，这可能会出现数据不一致的情况。数据不一致会带来一些问题，例如当我们通过 iam-apiserver 创建了一对密钥，但是这对密钥还没有被 iam-authz-server 缓存，这时候通过这对密钥访问 iam-authz-server 就会访问失败。</p><p data-pid="tsdtFVfn">为了保证数据的一致性，我们可以使用 Redis 的发布订阅(pub/sub)功能进行消息通知。同时，iam-authz-server 也会将授权审计日志缓存到 Redis 中，所以也需要安装 Redis key-value 数据库。我们可以通过以下命令来安装和配置 Redis，并将 Redis 的初始密码设置为 <code>iam59!z$</code> ：</p><div class="highlight"><pre><code class="language-bash"><span class="nb">cd</span> <span class="nv">$IAM_ROOT</span>$ ./scripts/install/redis.sh iam::redis::install</code></pre></div><p data-pid="sAzpu_Sw">这里我们要注意，scripts/install/redis.sh 脚本中 iam::redis::install 函数对 Redis 做了一些配置，例如修改 Redis 使其以守护进程的方式运行、修改 Redis 的密码为 <code>iam59!z$</code>等，详细配置可参考函数 <a href="https://github.com/marmotedu/iam/blob/v1.0.0/scripts/install/redis.sh#L20" target="_blank">iam::redis::install</a> 函数。</p><p data-pid="hIq0X0c-">安装完成后，我们可以通过以下命令，来测试 Redis 是否安装成功：</p><div class="highlight"><pre><code class="language-bash">redis-cli -h 127.0.0.1 -p <span class="m">6379</span> -a <span class="s1">'iam59!z </details> 
 <hr /> 
</span> 
<span class="c1"># 连接 Redis，-h 指定主机，-p 指定监听端口，-a 指定登录密码</span></code></pre></div><p class="ztext-empty-paragraph"><br></p><h3><b>安装和配置 MongoDB</b></h3><p data-pid="0ZkQGlaz">因为 iam-pump 会将 iam-authz-server 产生的数据处理后存储在 MongoDB 中，所以我们也需要安装 MongoDB 数据库。主要分两步安装：</p><ol><li data-pid="zWVDtsdE">首先安装 MongoDB</li><li data-pid="omXCW4OM">然后再创建 MongoDB 账号</li></ol><p class="ztext-empty-paragraph"><br></p><h3><b>第 1 步，安装 MongoDB</b></h3><p data-pid="xSIHrR5_">首先，我们可以通过以下 4 步来安装 MongoDB。</p><p data-pid="F-0ZCzwi"><b>配置 MongoDB yum 源，并安装 MongoDB。</b></p><p data-pid="Dw_5sfrK">CentOS8.x 系统默认没有配置安装 MongoDB 需要的 yum 源，所以我们需要先配置好 yum 源再安装：</p><div class="highlight"><pre><code class="language-bash">$ sudo tee /etc/yum.repos.d/mongodb-org-5.0.repo<span class="s">&lt;&lt;'EOF'
</span><span class="s">[mongodb-org-5.0]
</span><span class="s">name=MongoDB Repository
</span><span class="s">baseurl=https://repo.mongodb.org/yum/redhat/$releasever/mongodb-org/5.0/x86_64/
</span><span class="s">gpgcheck=1
</span><span class="s">enabled=1
</span><span class="s">gpgkey=https://www.mongodb.org/static/pgp/server-5.0.asc
</span><span class="s">EOF</span>
 
$ sudo yum install -y mongodb-org</code></pre></div><p data-pid="mbFH4Fvn"><b>关闭 SELinux</b>。</p><p data-pid="Q5Z2hfp3">在安装的过程中，SELinux 有可能会阻止 MongoDB 访问 <code>/sys/fs/cgroup</code>，所以我们还需要关闭 SELinux：</p><blockquote data-pid="4oiwPDm1">SELinux(Security-Enhanced Linux 或 Security-Enhanced Linux)是一种安全控制机制，由NSA公司开发，可以在Linux系统上提供更强大的安全性。它使用标签来区分操作系统上的文件和目录，并且可以在系统上实施特定的安全策略，以确保系统的安全。</blockquote><div class="highlight"><pre><code class="language-bash">$ sudo setenforce <span class="m">0</span>
$ sudo sed -i <span class="s1">'s/^SELINUX=.*$/SELINUX=disabled/'</span> /etc/selinux/config <span class="c1"># 永久关闭 SELINUX</span></code></pre></div><p class="ztext-empty-paragraph"><br></p><p data-pid="DjQ3h8q3"><b>开启外网访问权限和登录验证</b>。</p><p data-pid="4GLCHUPe">MongoDB 安装完之后，默认情况下是不会开启外网访问权限和登录验证，为了方便使用，我建议你先开启这些功能，执行如下命令开启：</p><div class="highlight"><pre><code class="language-bash">$ sudo sed -i <span class="s1">'/bindIp/{s/127.0.0.1/0.0.0.0/}'</span> /etc/mongod.conf
$ sudo sed -i <span class="s1">'/^#security/a\security:\n  authorization: enabled'</span> /etc/mongod.conf</code></pre></div><p class="ztext-empty-paragraph"><br></p><p data-pid="odog-dpx"><b>启动 MongoDB。</b></p><p data-pid="QgAI6F47">配置完 MongoDB 之后，我们就可以启动它了，具体的命令如下：</p><div class="highlight"><pre><code class="language-bash">$ sudo systemctl start mongod
$ sudo systemctl <span class="nb">enable</span> mongod <span class="c1"># 设置开机启动</span>
$ sudo systemctl status mongod <span class="c1"># 查看 mongod 运行状态，如果输出中包含 active (running)字样说明 mongod 成功启动</span></code></pre></div><p data-pid="CGA-FS4l">安装完 MongoDB 后，我们就可以通过 <code>mongo</code> 命令登录 MongoDB Shell。如果没有报错，就说明 MongoDB 被成功安装了。</p><div class="highlight"><pre><code class="language-bash">mongosh --quiet <span class="s2">"mongodb://127.0.0.1:27017&amp;quot</span></code></pre></div><p class="ztext-empty-paragraph"><br></p><h3><b>第 2 步，创建 MongoDB 账号</b></h3><p data-pid="Wx9inVlM">安装完 MongoDB 之后，默认是没有用户账号的，为了方便 IAM 服务使用，我们需要先创建好管理员账号，通过管理员账户登录 MongoDB，我们可以执行创建普通用户、数据库等操作。</p><p data-pid="0GD6_uLe"><b>创建管理员账户</b>。</p><p data-pid="ZUuqtvnk">首先，我们通过 <code>use admin</code> 指令切换到 admin 数据库，再通过 <code>db.auth("用户名"，"用户密码")</code> 验证用户登录权限。如果返回 1 表示验证成功；如果返回 0 表示验证失败。具体的命令如下：</p><div class="highlight"><pre><code class="language-text">$ mongosh --quiet "mongodb://127.0.0.1:27017"
test&gt; use admin 
switched to db admin
admin&gt; db.createUser({user:"root",pwd:"iam59!z$",roles:["root"]})
{ ok: 1 }
admin&gt; db.auth("root", "iam59!z$")
{ ok: 1 }</code></pre></div><p data-pid="IJrrLWrl">此外，如果想删除用户，可以使用 <code>db.dropUser("用户名")</code> 命令。</p><p data-pid="Mmn3otFx"><code>db.createUser</code> 用到了以下 3 个参数。</p><ul><li data-pid="aPEHHCp4">user: 用户名。</li><li data-pid="eqS3HJ1M">pwd: 用户密码。</li><li data-pid="lW-uegqM">roles: 用来设置用户的权限，比如读、读写、写等。</li></ul><p data-pid="gRoKxcCq">因为 admin 用户具有 MongoDB 的 Root 权限，权限过大安全性会降低。为了提高安全性，我们还需要创建一个 iam 普通用户来连接和操作 MongoDB。</p><ol><li data-pid="JS_srxFt">创建 iam 用户，命令如下：</li></ol><div class="highlight"><pre><code class="language-bash">$ mongosh --quiet mongodb://root:<span class="s1">'iam59!z </details> 
 <hr /> 
</span>@127.0.0.1:27017/iam_analytics?authSource<span class="o">=</span>admin <span class="c1"># 用管理员账户连接 MongoDB</span>
iam_analytics&gt; db.createUser<span class="o">({</span>user:<span class="s2">"iam"</span>,pwd:<span class="s2">"iam59!z</span>$<span class="s2">"</span>,roles:<span class="o">[</span><span class="s2">"dbOwner"</span><span class="o">]})</span>
<span class="o">{</span> ok: <span class="m">1</span> <span class="o">}</span>
iam_analytics&gt; db.auth<span class="o">(</span><span class="s2">"iam"</span>, <span class="s2">"iam59!z</span>$<span class="s2">"</span><span class="o">)</span>
<span class="o">{</span> ok: <span class="m">1</span> <span class="o">}</span></code></pre></div><p data-pid="pAEp7pYO">创建完 iam 普通用户后，我们就可以通过 iam 用户登录 MongoDB 了：</p><div class="highlight"><pre><code class="language-bash">$ mongosh --quiet mongodb://iam:<span class="s1">'iam59!z </details> 
 <hr /> 
</span>@127.0.0.1:27017/iam_analytics?authSource<span class="o">=</span>iam_analytics</code></pre></div><p data-pid="ILf0DdTH">至此，我们成功安装了 IAM 系统需要的数据库 MariaDB、Redis 和 MongoDB。</p><p class="ztext-empty-paragraph"><br></p><h3><b>安装和配置 IAM 系统</b></h3><p data-pid="6xOn7iJ0">要想完成 IAM 系统的安装，我们还需要安装和配置 iam-apiserver、iam-authz-server、iam-pump 和 iamctl。这些组件的功能我们在<a href="https://time.geekbang.org/column/article/377998" target="_blank">第1讲</a>详细讲过，如果不记得你可以翻回去看看。</p><blockquote data-pid="JFXSZzuw">提示：IAM 项目我会长期维护、定期更新，欢迎你 Star &amp; Contributing。</blockquote><p class="ztext-empty-paragraph"><br></p><p data-pid="xNNxTxMQ"><b>准备工作：</b></p><p data-pid="2BCXGr9B">在开始安装之前，我们需要先做一些准备工作，主要有 5 步。</p><ol><li data-pid="HTe2X0o3">初始化 MariaDB 数据库，创建 iam 数据库。</li><li data-pid="PBi7pJWY">配置 scripts/install/environment.sh。</li><li data-pid="SSxCuVXO">创建需要的目录。</li><li data-pid="6P_momaD">创建 CA 根证书和密钥。</li><li data-pid="WthteERz">配置 hosts。</li></ol><p class="ztext-empty-paragraph"><br></p><h3><b>第 1 步，初始化 MariaDB 数据库，创建 iam 数据库。</b></h3><p data-pid="SdWdak6k">安装完 MariaDB 数据库之后，我们需要在 MariaDB 数据库中创建 IAM 系统需要的数据库、表和存储过程，以及创建 SQL 语句保存在 IAM 代码仓库中的 <code>configs/iam.sql</code> 文件中。具体的创建步骤如下。</p><p data-pid="XVGUf5bl"><b>登录数据库并创建 iam 用户。</b></p><div class="highlight"><pre><code class="language-bash">$ <span class="nb">cd</span> <span class="nv">$IAM_ROOT</span>
$ mysql -h127.0.0.1 -P3306 -uroot -p<span class="s1">'iam59!z </details> 
 <hr /> 
</span> <span class="c1"># 连接 MariaDB，-h 指定主机，-P 指定监听端口，-u 指定登录用户，-p 指定登录密码</span>
MariaDB <span class="o">[(</span>none<span class="o">)]</span>&gt; grant all on iam.* TO iam@127.0.0.1 identified by <span class="s1">'iam59!z </details> 
 <hr /> 
</span><span class="p">;</span>
Query OK, <span class="m">0</span> rows affected <span class="o">(</span>0.000 sec<span class="o">)</span>
MariaDB <span class="o">[(</span>none<span class="o">)]</span>&gt; flush privileges<span class="p">;</span>
Query OK, <span class="m">0</span> rows affected <span class="o">(</span>0.000 sec<span class="o">)</span></code></pre></div><p class="ztext-empty-paragraph"><br></p><p data-pid="Lv94AfCK"><b>用 iam 用户登录 MariaDB，执行 iam.sql 文件，创建 iam 数据库。</b></p><div class="highlight"><pre><code class="language-bash">$ mysql -h127.0.0.1 -P3306 -uiam -p<span class="s1">'iam59!z </details> 
 <hr /> 
</span>
MariaDB <span class="o">[(</span>none<span class="o">)]</span>&gt; <span class="nb">source</span> configs/iam.sql<span class="p">;</span>
MariaDB <span class="o">[</span>iam<span class="o">]</span>&gt; show databases<span class="p">;</span>
+--------------------+
<span class="p">|</span> Database           <span class="p">|</span>
+--------------------+
<span class="p">|</span> iam                <span class="p">|</span>
<span class="p">|</span> information_schema <span class="p">|</span>
+--------------------+
<span class="m">2</span> rows in <span class="nb">set</span> <span class="o">(</span>0.000 sec<span class="o">)</span></code></pre></div><p data-pid="CMtI_BkG">上面的命令会创建 iam 数据库，并创建以下数据库资源。</p><ul><li data-pid="sZ-gJ6mc">表：<br></li><ul><li data-pid="NNdnu_M0">user 是用户表，用来存放用户信息；</li><li data-pid="8y7esrj7">secret 是密钥表，用来存放密钥信息；</li><li data-pid="2-acPlrY">policy 是策略表，用来存放授权策略信息；</li><li data-pid="oZJzqyYK">policy_audit 是策略历史表，被删除的策略会被转存到该表。</li></ul></ul><p class="ztext-empty-paragraph"><br></p><ul><li data-pid="fcRacMTJ">admin 用户：在 user 表中，我们需要创建一个管理员用户，用户名是 admin，密码是 <code>Admin@2021</code>。</li><li data-pid="w8gp7NhL">存储过程：删除用户时会自动删除该用户所属的密钥和策略信息。</li></ul><p class="ztext-empty-paragraph"><br></p><h3><b>第 2 步，配置 scripts/install/environment.sh。</b></h3><p data-pid="Ox8ETL0f">IAM 组件的安装配置都是通过环境变量文件 <a href="https://zhuanlan.zhihu.com/p/606959150/scripts/install/environment.sh">scripts/install/environment.sh</a> 进行配置的，所以我们要先配置好 scripts/install/environment.sh 文件。这里，你可以直接使用默认值，提高你的安装效率。</p><p class="ztext-empty-paragraph"><br></p><h3><b>第 3 步，创建需要的目录。</b></h3><p data-pid="vk4Y5KBS">在安装和运行 IAM 系统的时候，我们需要将配置、二进制文件和数据文件存放到指定的目录。所以我们需要先创建好这些目录，创建步骤如下。</p><div class="highlight"><pre><code class="language-bash"> $ <span class="nb">cd</span> <span class="nv">$IAM_ROOT</span>
 $ <span class="nb">source</span> scripts/install/environment.sh
 $ sudo mkdir -p <span class="si">${</span><span class="nv">IAM_DATA_DIR</span><span class="si">}</span>/<span class="o">{</span>iam-apiserver,iam-authz-server,iam-pump<span class="o">}</span> <span class="c1"># 创建 Systemd WorkingDirectory 目录</span>
 $ sudo mkdir -p <span class="si">${</span><span class="nv">IAM_INSTALL_DIR</span><span class="si">}</span>/bin <span class="c1">#创建 IAM 系统安装目录</span>
 $ sudo mkdir -p <span class="si">${</span><span class="nv">IAM_CONFIG_DIR</span><span class="si">}</span>/cert <span class="c1"># 创建 IAM 系统配置文件存放目录</span>
 $ sudo mkdir -p <span class="si">${</span><span class="nv">IAM_LOG_DIR</span><span class="si">}</span> <span class="c1"># 创建 IAM 日志文件存放目录</span></code></pre></div><p class="ztext-empty-paragraph"><br></p><h3><b>第 4 步， 创建 CA 根证书和密钥。</b></h3><p data-pid="oMz3lytt">为了确保安全，IAM 系统各组件需要使用 x509 证书对通信进行加密和认证。所以，这里我们需要先创建 CA 证书。CA 根证书是所有组件共享的，只需要创建一个 CA 证书，后续创建的所有证书都由它签名。</p><p data-pid="LyxNXXOQ">我们可以使用 CloudFlare 的 PKI 工具集 cfssl 来创建所有的证书。</p><p data-pid="gWHYWGIK"><b>安装 cfssl 工具集。</b></p><p data-pid="EzCJFKCT">我们可以直接安装 cfssl 已经编译好的二进制文件，cfssl 工具集中包含很多工具，这里我们需要安装 cfssl、cfssljson、cfssl-certinfo，功能如下。</p><ol><li data-pid="h51rCkXk">cfssl：证书签发工具。</li><li data-pid="u2v1tmdE">cfssljson：将 cfssl 生成的证书（json 格式）变为文件承载式证书。</li></ol><p data-pid="80kGlhOz">这两个工具的安装方法如下：</p><div class="highlight"><pre><code class="language-bash">$ <span class="nb">cd</span> <span class="nv">$IAM_ROOT</span>
$ ./scripts/install/install.sh iam::install::install_cfssl</code></pre></div><p data-pid="zuRnA6re"><b>创建配置文件。</b></p><p data-pid="-J9x1n81">CA 配置文件是用来配置根证书的使用场景 (profile) 和具体参数 (usage、过期时间、服务端认证、客户端认证、加密等)，可以在签名其它证书时用来指定特定场景：</p><div class="highlight"><pre><code class="language-bash">$ <span class="nb">cd</span> <span class="nv">$IAM_ROOT</span>
$ tee ca-config.json <span class="s">&lt;&lt; EOF
</span><span class="s">{
</span><span class="s">  "signing": {
</span><span class="s">    "default": {
</span><span class="s">      "expiry": "87600h"
</span><span class="s">    },
</span><span class="s">    "profiles": {
</span><span class="s">      "iam": {
</span><span class="s">        "usages": [
</span><span class="s">          "signing",
</span><span class="s">          "key encipherment",
</span><span class="s">          "server auth",
</span><span class="s">          "client auth"
</span><span class="s">        ],
</span><span class="s">        "expiry": "876000h"
</span><span class="s">      }
</span><span class="s">    }
</span><span class="s">  }
</span><span class="s">}
</span><span class="s">EOF</span></code></pre></div><p data-pid="zmNsXePi">上面的 JSON 配置中，有一些字段解释如下。</p><ul><li data-pid="0WY06b4L">signing：表示该证书可用于签名其它证书（生成的 ca.pem 证书中 CA=TRUE）。</li><li data-pid="fdUZXWx1">server auth：表示 client 可以用该证书对 server 提供的证书进行验证。</li><li data-pid="uIozGHyQ">client auth：表示 server 可以用该证书对 client 提供的证书进行验证。</li><li data-pid="9o4vYxii">expiry：876000h，证书有效期设置为 100 年。</li></ul><p class="ztext-empty-paragraph"><br></p><p data-pid="1L-FCoPe"><b>创建证书签名请求文件。</b></p><p data-pid="OerbHhHv">我们创建用来生成 CA 证书签名请求（CSR）的 JSON 配置文件：</p><div class="highlight"><pre><code class="language-bash">$ <span class="nb">cd</span> <span class="nv">$IAM_ROOT</span>
$ tee ca-csr.json <span class="s">&lt;&lt; EOF
</span><span class="s">{
</span><span class="s">  "CN": "iam-ca",
</span><span class="s">  "key": {
</span><span class="s">    "algo": "rsa",
</span><span class="s">    "size": 2048
</span><span class="s">  },
</span><span class="s">  "names": [
</span><span class="s">    {
</span><span class="s">      "C": "CN",
</span><span class="s">      "ST": "BeiJing",
</span><span class="s">      "L": "BeiJing",
</span><span class="s">      "O": "marmotedu",
</span><span class="s">      "OU": "iam"
</span><span class="s">    }
</span><span class="s">  ],
</span><span class="s">  "ca": {
</span><span class="s">    "expiry": "876000h"
</span><span class="s">  }
</span><span class="s">}
</span><span class="s">EOF</span></code></pre></div><p class="ztext-empty-paragraph"><br></p><p data-pid="SqOftFmN"><b>上面的 JSON 配置中，有一些字段解释如下。</b></p><ul><li data-pid="wCe2hZPD">C：Country，国家。</li><li data-pid="_E2b_m4T">ST：State，省份。</li><li data-pid="sQ9Vnejh">L：Locality (L) or City，城市。</li><li data-pid="xYBckvBB">CN：Common Name，iam-apiserver 从证书中提取该字段作为请求的用户名 (User Name) ，浏览器使用该字段验证网站是否合法。</li><li data-pid="-6mGpoVi">O：Organization，iam-apiserver 从证书中提取该字段作为请求用户所属的组 (Group)。</li><li data-pid="HQysH_CC">OU：Company division (or Organization Unit – OU)，部门 / 单位。</li></ul><p data-pid="LeaZ5IUt">除此之外，还有两点需要我们注意。</p><ul><li data-pid="5lJYEMY4">不同证书 csr 文件的 CN、C、ST、L、O、OU 组合必须不同，否则可能出现 PEER'S CERTIFICATE HAS AN INVALID SIGNATURE 错误。</li><li data-pid="Rh99WBkH">后续创建证书的 csr 文件时，CN、OU 都不相同（C、ST、L、O 相同），以达到区分的目的。</li><li data-pid="JSjoDFue">创建 CA 证书和私钥</li></ul><p data-pid="Uqb7_J0z">首先，我们通过 cfssl gencert 命令来创建：</p><div class="highlight"><pre><code class="language-bash">$ <span class="nb">cd</span> <span class="nv">$IAM_ROOT</span>
$ <span class="nb">source</span> scripts/install/environment.sh
$ cfssl gencert -initca ca-csr.json <span class="p">|</span> cfssljson -bare ca
$ ls ca*
ca-config.json  ca.csr  ca-csr.json  ca-key.pem  ca.pem
$ sudo mv ca* <span class="si">${</span><span class="nv">IAM_CONFIG_DIR</span><span class="si">}</span>/cert <span class="c1"># 需要将证书文件拷贝到指定文件夹下（分发证书），方便各组件引用</span></code></pre></div><p data-pid="IDaP43O5">上述命令会创建运行 CA 所必需的文件 ca-key.pem（私钥）和 ca.pem（证书），还会生成 ca.csr（证书签名请求），用于交叉签名或重新签名。</p><p data-pid="KnKykx3D">创建完之后，我们可以通过 cfssl certinfo 命名查看 cert 和 csr 信息：</p><div class="highlight"><pre><code class="language-bash">$ cfssl certinfo -cert <span class="si">${</span><span class="nv">IAM_CONFIG_DIR</span><span class="si">}</span>/cert/ca.pem <span class="c1"># 查看 cert(证书信息)</span>
$ cfssl certinfo -csr <span class="si">${</span><span class="nv">IAM_CONFIG_DIR</span><span class="si">}</span>/cert/ca.csr <span class="c1"># 查看 CSR(证书签名请求)信息</span></code></pre></div><p class="ztext-empty-paragraph"><br></p><h3><b>第 5 步，配置 hosts。</b></h3><p data-pid="SQoaOcDJ">iam 通过域名访问 API 接口，因为这些域名没有注册过，还不能在互联网上解析，所以需要配置 hosts，具体的操作如下：</p><div class="highlight"><pre><code class="language-bash">$ sudo tee -a /etc/hosts <span class="s">&lt;&lt;EOF
</span><span class="s">127.0.0.1 iam.api.marmotedu.com
</span><span class="s">127.0.0.1 iam.authz.marmotedu.com
</span><span class="s">EOF</span></code></pre></div><p class="ztext-empty-paragraph"><br></p><h3><b>安装和配置 iam-apiserver</b></h3><p data-pid="3zqJ1_G9">完成了准备工作之后，我们就可以安装 IAM 系统的各个组件了。首先我们通过以下 3 步来安装 iam-apiserver 服务。</p><p class="ztext-empty-paragraph"><br></p><h3><b>第 1 步，创建 iam-apiserver 证书和私钥。</b></h3><p data-pid="zvsD34TX">其它服务为了安全都是通过 HTTPS 协议访问 iam-apiserver，所以我们要先创建 iam-apiserver 证书和私钥。</p><p data-pid="UBzixlPs"><b>创建证书签名请求</b>：</p><div class="highlight"><pre><code class="language-bash">$ <span class="nb">cd</span> <span class="nv">$IAM_ROOT</span>
$ <span class="nb">source</span> scripts/install/environment.sh
$ tee iam-apiserver-csr.json <span class="s">&lt;&lt;EOF
</span><span class="s">{
</span><span class="s">  "CN": "iam-apiserver",
</span><span class="s">  "key": {
</span><span class="s">    "algo": "rsa",
</span><span class="s">    "size": 2048
</span><span class="s">  },
</span><span class="s">  "names": [
</span><span class="s">    {
</span><span class="s">      "C": "CN",
</span><span class="s">      "ST": "BeiJing",
</span><span class="s">      "L": "BeiJing",
</span><span class="s">      "O": "marmotedu",
</span><span class="s">      "OU": "iam-apiserver"
</span><span class="s">    }
</span><span class="s">  ],
</span><span class="s">  "hosts": [
</span><span class="s">    "127.0.0.1",
</span><span class="s">    "localhost",
</span><span class="s">    "iam.api.marmotedu.com"
</span><span class="s">  ]
</span><span class="s">}
</span><span class="s">EOF</span></code></pre></div><p data-pid="tVj3tTVE">代码中的 hosts 字段是用来指定授权使用该证书的 IP 和域名列表，上面的 hosts 列出了 iam-apiserver 服务的 IP 和域名。</p><p class="ztext-empty-paragraph"><br></p><p data-pid="XPjDril-"><b>生成证书和私钥</b>：</p><div class="highlight"><pre><code class="language-bash">$ cfssl gencert -ca<span class="o">=</span><span class="si">${</span><span class="nv">IAM_CONFIG_DIR</span><span class="si">}</span>/cert/ca.pem <span class="se">\
</span><span class="se"></span>  -ca-key<span class="o">=</span><span class="si">${</span><span class="nv">IAM_CONFIG_DIR</span><span class="si">}</span>/cert/ca-key.pem <span class="se">\
</span><span class="se"></span>  -config<span class="o">=</span><span class="si">${</span><span class="nv">IAM_CONFIG_DIR</span><span class="si">}</span>/cert/ca-config.json <span class="se">\
</span><span class="se"></span>  -profile<span class="o">=</span>iam iam-apiserver-csr.json <span class="p">|</span> cfssljson -bare iam-apiserver
$ sudo mv iam-apiserver*pem <span class="si">${</span><span class="nv">IAM_CONFIG_DIR</span><span class="si">}</span>/cert 
<span class="c1"># 将生成的证书和私钥文件拷贝到配置文件目录</span></code></pre></div><p class="ztext-empty-paragraph"><br></p><h3><b>第 2 步，安装并运行 iam-apiserver。</b></h3><p data-pid="U6eSSPEI">iam-apiserver 作为 iam 系统的核心组件，需要第一个安装。</p><p class="ztext-empty-paragraph"><br></p><p data-pid="XBWIXqOa"><b>安装 iam-apiserver 可执行程序：</b></p><div class="highlight"><pre><code class="language-bash"> $ <span class="nb">cd</span> <span class="nv">$IAM_ROOT</span>
 $ <span class="nb">source</span> scripts/install/environment.sh
 $ make build <span class="nv">BINS</span><span class="o">=</span>iam-apiserver
 $ sudo cp _output/platforms/linux/amd64/iam-apiserver <span class="si">${</span><span class="nv">IAM_INSTALL_DIR</span><span class="si">}</span>/bin</code></pre></div><p class="ztext-empty-paragraph"><br></p><p data-pid="-z1SPXwF"><b>生成并安装 iam-apiserver 的配置文件（iam-apiserver.yaml）：</b></p><div class="highlight"><pre><code class="language-bash"> $ ./scripts/genconfig.sh scripts/install/environment.sh configs/iam-apiserver.yaml &gt; iam-apiserver.yaml
 $ sudo mv iam-apiserver.yaml <span class="si">${</span><span class="nv">IAM_CONFIG_DIR</span><span class="si">}</span></code></pre></div><p class="ztext-empty-paragraph"><br></p><p data-pid="dzEzmCTL"><b>创建并安装 iam-apiserver systemd unit 文件：</b></p><div class="highlight"><pre><code class="language-bash"> $ ./scripts/genconfig.sh scripts/install/environment.sh init/iam-apiserver.service &gt; iam-apiserver.service
 $ sudo mv iam-apiserver.service /etc/systemd/system/</code></pre></div><p class="ztext-empty-paragraph"><br></p><p data-pid="NGr6CdGj"><b>启动 iam-apiserver 服务：</b></p><div class="highlight"><pre><code class="language-bash"> $ sudo systemctl daemon-reload
 $ sudo systemctl <span class="nb">enable</span> iam-apiserver
 $ sudo systemctl restart iam-apiserver
 $ systemctl status iam-apiserver <span class="c1"># 查看 iam-apiserver 运行状态，如果输出中包含 active (running)字样说明 iam-apiserver 成功启动</span></code></pre></div><p class="ztext-empty-paragraph"><br></p><h3><b>第 3 步，测试 iam-apiserver 是否成功安装。</b></h3><p data-pid="8AQ8iQT0">测试 iam-apiserver 主要是测试 RESTful 资源的 CURD：<b>用户 CURD、密钥 CURD、授权策略 CURD。</b></p><p data-pid="zNwPgB5r">首先，我们需要获取访问 iam-apiserver 的 Token，请求如下 API 访问：</p><div class="highlight"><pre><code class="language-bash"> $ curl -s -XPOST -H<span class="s1">'Content-Type: application/json'</span> -d<span class="s1">'{"username":"admin","password":"Admin@2021"}'</span> http://127.0.0.1:8080/login <span class="p">|</span> jq -r .token
 eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJpYW0uYXBpLm1hcm1vdGVkdS5jb20iLCJleHAiOjE2NzY2MzI5MzcsImlkZW50aXR5IjoiYWRtaW4iLCJpc3MiOiJpYW0tYXBpc2VydmVyIiwib3JpZ19pYXQiOjE2NzY1NDY1MzcsInN1YiI6ImFkbWluIn0.FprBR_QLI_LS8Y087mat88tIRIQyWrYDo41RsRmnQjE</code></pre></div><p data-pid="6pkwPIvf">代码中下面的 HTTP 请求通过<code>-H'Authorization: Bearer &lt;Token&gt;'</code> 指定认证头信息，将上面请求的 Token 替换 <code>&lt;Token&gt;</code> 。</p><p class="ztext-empty-paragraph"><br></p><p data-pid="1vk3mSex"><b>用户 CURD:</b></p><p data-pid="ZAfndJqA">创建用户、列出用户、获取用户详细信息、修改用户、删除单个用户、批量删除用户，请求方法如下：</p><div class="highlight"><pre><code class="language-bash"> <span class="c1"># 创建用户</span>
 $ curl -s -XPOST -H<span class="s1">'Content-Type: application/json'</span> -H<span class="s1">'Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJpYW0uYXBpLm1hcm1vdGVkdS5jb20iLCJleHAiOjE2NzY2MzI5MzcsImlkZW50aXR5IjoiYWRtaW4iLCJpc3MiOiJpYW0tYXBpc2VydmVyIiwib3JpZ19pYXQiOjE2NzY1NDY1MzcsInN1YiI6ImFkbWluIn0.FprBR_QLI_LS8Y087mat88tIRIQyWrYDo41RsRmnQjE'</span> -d<span class="s1">'{"password":"User@2021","metadata":{"name":"colin"},"nickname":"colin","email":"colin@foxmail.com","phone":"1812884xxxx"}'</span> http://127.0.0.1:8080/v1/users
 ​
 <span class="c1"># 列出用户</span>
 $ curl -s -XGET -H<span class="s1">'Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJpYW0uYXBpLm1hcm1vdGVkdS5jb20iLCJleHAiOjE2NzY2MzI5MzcsImlkZW50aXR5IjoiYWRtaW4iLCJpc3MiOiJpYW0tYXBpc2VydmVyIiwib3JpZ19pYXQiOjE2NzY1NDY1MzcsInN1YiI6ImFkbWluIn0.FprBR_QLI_LS8Y087mat88tIRIQyWrYDo41RsRmnQjE'</span> <span class="s1">'http://127.0.0.1:8080/v1/users?offset=0&amp;limit=10'</span>
 ​
 <span class="c1"># 获取 colin 用户的详细信息</span>
 $ curl -s -XGET -H<span class="s1">'Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJpYW0uYXBpLm1hcm1vdGVkdS5jb20iLCJleHAiOjE2NzY2MzI5MzcsImlkZW50aXR5IjoiYWRtaW4iLCJpc3MiOiJpYW0tYXBpc2VydmVyIiwib3JpZ19pYXQiOjE2NzY1NDY1MzcsInN1YiI6ImFkbWluIn0.FprBR_QLI_LS8Y087mat88tIRIQyWrYDo41RsRmnQjE'</span> http://127.0.0.1:8080/v1/users/colin
 ​
 <span class="c1"># 修改 colin 用户</span>
 $ curl -s -XPUT -H<span class="s1">'Content-Type: application/json'</span> -H<span class="s1">'Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJpYW0uYXBpLm1hcm1vdGVkdS5jb20iLCJleHAiOjE2NzY2MzI5MzcsImlkZW50aXR5IjoiYWRtaW4iLCJpc3MiOiJpYW0tYXBpc2VydmVyIiwib3JpZ19pYXQiOjE2NzY1NDY1MzcsInN1YiI6ImFkbWluIn0.FprBR_QLI_LS8Y087mat88tIRIQyWrYDo41RsRmnQjE'</span> -d<span class="s1">'{"nickname":"colin","email":"colin_modified@foxmail.com","phone":"1867274xxxx"}'</span> http://127.0.0.1:8080/v1/users/colin
 ​
 <span class="c1"># 删除 colin 用户</span>
 $ curl -s -XDELETE -H<span class="s1">'Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJpYW0uYXBpLm1hcm1vdGVkdS5jb20iLCJleHAiOjE2NzY2MzI5MzcsImlkZW50aXR5IjoiYWRtaW4iLCJpc3MiOiJpYW0tYXBpc2VydmVyIiwib3JpZ19pYXQiOjE2NzY1NDY1MzcsInN1YiI6ImFkbWluIn0.FprBR_QLI_LS8Y087mat88tIRIQyWrYDo41RsRmnQjE'</span> http://127.0.0.1:8080/v1/users/colin
 ​
 <span class="c1"># 批量删除用户</span>
 $ curl -s -XDELETE -H<span class="s1">'Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJpYW0uYXBpLm1hcm1vdGVkdS5jb20iLCJleHAiOjE2NzY2MzI5MzcsImlkZW50aXR5IjoiYWRtaW4iLCJpc3MiOiJpYW0tYXBpc2VydmVyIiwib3JpZ19pYXQiOjE2NzY1NDY1MzcsInN1YiI6ImFkbWluIn0.FprBR_QLI_LS8Y087mat88tIRIQyWrYDo41RsRmnQjE'</span> <span class="s1">'http://127.0.0.1:8080/v1/users?name=colin&amp;name=mark&amp;name=john'</span></code></pre></div><p class="ztext-empty-paragraph"><br></p><p data-pid="0lQrsRfl"><b>密钥 CURD:</b></p><p data-pid="_KrIR6mj">创建密钥、列出密钥、获取密钥详细信息、修改密钥、删除密钥请求方法如下：</p><div class="highlight"><pre><code class="language-bash"> ​
 <span class="c1"># 创建 secret0 密钥</span>
 $ curl -s -XPOST -H<span class="s1">'Content-Type: application/json'</span> -H<span class="s1">'Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJpYW0uYXBpLm1hcm1vdGVkdS5jb20iLCJleHAiOjE2NzY2MzI5MzcsImlkZW50aXR5IjoiYWRtaW4iLCJpc3MiOiJpYW0tYXBpc2VydmVyIiwib3JpZ19pYXQiOjE2NzY1NDY1MzcsInN1YiI6ImFkbWluIn0.FprBR_QLI_LS8Y087mat88tIRIQyWrYDo41RsRmnQjE'</span> -d<span class="s1">'{"metadata":{"name":"secret0"},"expires":0,"description":"admin secret"}'</span> http://127.0.0.1:8080/v1/secrets
 ​
 <span class="c1"># 列出所有密钥</span>
 $ curl -s -XGET -H<span class="s1">'Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJpYW0uYXBpLm1hcm1vdGVkdS5jb20iLCJleHAiOjE2NzY2MzI5MzcsImlkZW50aXR5IjoiYWRtaW4iLCJpc3MiOiJpYW0tYXBpc2VydmVyIiwib3JpZ19pYXQiOjE2NzY1NDY1MzcsInN1YiI6ImFkbWluIn0.FprBR_QLI_LS8Y087mat88tIRIQyWrYDo41RsRmnQjE'</span> http://127.0.0.1:8080/v1/secrets
 ​
 <span class="c1"># 获取 secret0 密钥的详细信息</span>
 $ curl -s -XGET -H<span class="s1">'Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJpYW0uYXBpLm1hcm1vdGVkdS5jb20iLCJleHAiOjE2NzY2MzI5MzcsImlkZW50aXR5IjoiYWRtaW4iLCJpc3MiOiJpYW0tYXBpc2VydmVyIiwib3JpZ19pYXQiOjE2NzY1NDY1MzcsInN1YiI6ImFkbWluIn0.FprBR_QLI_LS8Y087mat88tIRIQyWrYDo41RsRmnQjE'</span> http://127.0.0.1:8080/v1/secrets/secret0
 ​
 <span class="c1"># 修改 secret0 密钥</span>
 $ curl -s -XPUT -H<span class="s1">'Content-Type: application/json'</span> -H<span class="s1">'Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJpYW0uYXBpLm1hcm1vdGVkdS5jb20iLCJleHAiOjE2NzY2MzI5MzcsImlkZW50aXR5IjoiYWRtaW4iLCJpc3MiOiJpYW0tYXBpc2VydmVyIiwib3JpZ19pYXQiOjE2NzY1NDY1MzcsInN1YiI6ImFkbWluIn0.FprBR_QLI_LS8Y087mat88tIRIQyWrYDo41RsRmnQjE'</span> -d<span class="s1">'{"metadata":{"name":"secret0"},"expires":0,"description":"admin secret(modified)"}'</span> http://127.0.0.1:8080/v1/secrets/secret0
 ​
 <span class="c1"># 删除 secret0 密钥</span>
 $ curl -s -XDELETE -H<span class="s1">'Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJpYW0uYXBpLm1hcm1vdGVkdS5jb20iLCJleHAiOjE2NzY2MzI5MzcsImlkZW50aXR5IjoiYWRtaW4iLCJpc3MiOiJpYW0tYXBpc2VydmVyIiwib3JpZ19pYXQiOjE2NzY1NDY1MzcsInN1YiI6ImFkbWluIn0.FprBR_QLI_LS8Y087mat88tIRIQyWrYDo41RsRmnQjE'</span> http://127.0.0.1:8080/v1/secrets/secret0</code></pre></div><p data-pid="pgM3QGPz">这里我们要注意，因为密钥属于重要资源，被删除会导致所有的访问请求失败，所以密钥不支持批量删除。</p><p class="ztext-empty-paragraph"><br></p><p data-pid="gcbvIirY"><b>授权策略 CURD:</b></p><p data-pid="6g1e6MPe">创建策略、列出策略、获取策略详细信息、修改策略、删除策略请求方法如下：</p><div class="highlight"><pre><code class="language-bash"> <span class="c1"># 创建策略</span>
 $ curl -s -XPOST -H<span class="s1">'Content-Type: application/json'</span> -H<span class="s1">'Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJpYW0uYXBpLm1hcm1vdGVkdS5jb20iLCJleHAiOjE2NzY2MzI5MzcsImlkZW50aXR5IjoiYWRtaW4iLCJpc3MiOiJpYW0tYXBpc2VydmVyIiwib3JpZ19pYXQiOjE2NzY1NDY1MzcsInN1YiI6ImFkbWluIn0.FprBR_QLI_LS8Y087mat88tIRIQyWrYDo41RsRmnQjE'</span> -d<span class="s1">'{"metadata":{"name":"policy0"},"policy":{"description":"One policy to rule them all.","subjects":["users:&lt;peter|ken&gt;","users:maria","groups:admins"],"actions":["delete","&lt;create|update&gt;"],"effect":"allow","resources":["resources:articles:&lt;.*&gt;","resources:printer"],"conditions":{"remoteIPAddress":{"type":"CIDRCondition","options":{"cidr":"192.168.0.1/16"}}}}}'</span> http://127.0.0.1:8080/v1/policies
 ​
 <span class="c1"># 列出所有策略</span>
 $ curl -s -XGET -H<span class="s1">'Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJpYW0uYXBpLm1hcm1vdGVkdS5jb20iLCJleHAiOjE2NzY2MzI5MzcsImlkZW50aXR5IjoiYWRtaW4iLCJpc3MiOiJpYW0tYXBpc2VydmVyIiwib3JpZ19pYXQiOjE2NzY1NDY1MzcsInN1YiI6ImFkbWluIn0.FprBR_QLI_LS8Y087mat88tIRIQyWrYDo41RsRmnQjE'</span> http://127.0.0.1:8080/v1/policies
 ​
 <span class="c1"># 获取 policy0 策略的详细信息</span>
 $ curl -s -XGET -H<span class="s1">'Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJpYW0uYXBpLm1hcm1vdGVkdS5jb20iLCJleHAiOjE2NzY2MzI5MzcsImlkZW50aXR5IjoiYWRtaW4iLCJpc3MiOiJpYW0tYXBpc2VydmVyIiwib3JpZ19pYXQiOjE2NzY1NDY1MzcsInN1YiI6ImFkbWluIn0.FprBR_QLI_LS8Y087mat88tIRIQyWrYDo41RsRmnQjE'</span> http://127.0.0.1:8080/v1/policies/policy0
 ​
 <span class="c1"># 修改 policy0 策略</span>
 $ curl -s -XPUT -H<span class="s1">'Content-Type: application/json'</span> -H<span class="s1">'Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJpYW0uYXBpLm1hcm1vdGVkdS5jb20iLCJleHAiOjE2NzY2MzI5MzcsImlkZW50aXR5IjoiYWRtaW4iLCJpc3MiOiJpYW0tYXBpc2VydmVyIiwib3JpZ19pYXQiOjE2NzY1NDY1MzcsInN1YiI6ImFkbWluIn0.FprBR_QLI_LS8Y087mat88tIRIQyWrYDo41RsRmnQjE'</span> -d<span class="s1">'{"metadata":{"name":"policy0"},"policy":{"description":"One policy to rule them all(modified).","subjects":["users:&lt;peter|ken&gt;","users:maria","groups:admins"],"actions":["delete","&lt;create|update&gt;"],"effect":"allow","resources":["resources:articles:&lt;.*&gt;","resources:printer"],"conditions":{"remoteIPAddress":{"type":"CIDRCondition","options":{"cidr":"192.168.0.1/16"}}}}}'</span> http://127.0.0.1:8080/v1/policies/policy0
 ​
 <span class="c1"># 删除 policy0 策略</span>
 $ curl -s -XDELETE -H<span class="s1">'Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJpYW0uYXBpLm1hcm1vdGVkdS5jb20iLCJleHAiOjE2NzY2MzI5MzcsImlkZW50aXR5IjoiYWRtaW4iLCJpc3MiOiJpYW0tYXBpc2VydmVyIiwib3JpZ19pYXQiOjE2NzY1NDY1MzcsInN1YiI6ImFkbWluIn0.FprBR_QLI_LS8Y087mat88tIRIQyWrYDo41RsRmnQjE'</span> http://127.0.0.1:8080/v1/policies/policy0
 ​
 <span class="c1"># 创建策略</span>
 $ curl -s -XPOST -H<span class="s1">'Content-Type: application/json'</span> -H<span class="s1">'Authorization: Bearer eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJpYW0uYXBpLm1hcm1vdGVkdS5jb20iLCJleHAiOjE2NzY2MzI5MzcsImlkZW50aXR5IjoiYWRtaW4iLCJpc3MiOiJpYW0tYXBpc2VydmVyIiwib3JpZ19pYXQiOjE2NzY1NDY1MzcsInN1YiI6ImFkbWluIn0.FprBR_QLI_LS8Y087mat88tIRIQyWrYDo41RsRmnQjE'</span> -d<span class="s1">'{"metadata":{"name":"policy0"},"policy":{"description":"One policy to rule them all.","subjects":["users:&lt;peter|ken&gt;","users:maria","groups:admins"],"actions":["delete","&lt;create|update&gt;"],"effect":"allow","resources":["resources:articles:&lt;.*&gt;","resources:printer"],"conditions":{"remoteIPAddress":{"type":"CIDRCondition","options":{"cidr":"192.168.0.1/16"}}}}}'</span> http://127.0.0.1:8080/v1/policies</code></pre></div><p class="ztext-empty-paragraph"><br></p><h3><b>安装 iamctl</b></h3><p data-pid="AQriyJGo">上面，我们安装了 iam 系统的 API 服务。但是想要访问 iam 服务，我们还需要安装客户端工具 iamctl。具体来说，我们可以通过 3 步完成 iamctl 的安装和配置。</p><p class="ztext-empty-paragraph"><br></p><h3><b>第 1 步，创建 iamctl 证书和私钥。</b></h3><p data-pid="I5o9rAc6">iamctl 使用 https 协议与 iam-apiserver 进行安全通信，iam-apiserver 对 iamctl 请求包含的证书进行认证和授权。iamctl 后续用于 iam 系统访问和管理，所以这里创建具有最高权限的 admin 证书。</p><p class="ztext-empty-paragraph"><br></p><p data-pid="EzIb5bXP"><b>创建证书签名请求</b>。</p><p data-pid="a1ayLoPf">下面创建的证书只会被 iamctl 当作 client 证书使用，所以 hosts 字段为空。代码如下：</p><div class="highlight"><pre><code class="language-bash"> $ <span class="nb">cd</span> <span class="nv">$IAM_ROOT</span>
 $ <span class="nb">source</span> scripts/install/environment.sh
 $ cat &gt; admin-csr.json <span class="s">&lt;&lt;EOF
</span><span class="s"> {
</span><span class="s">   "CN": "admin",
</span><span class="s">   "key": {
</span><span class="s">     "algo": "rsa",
</span><span class="s">     "size": 2048
</span><span class="s">   },
</span><span class="s">   "names": [
</span><span class="s">     {
</span><span class="s">       "C": "CN",
</span><span class="s">       "ST": "BeiJing",
</span><span class="s">       "L": "BeiJing",
</span><span class="s">       "O": "marmotedu",
</span><span class="s">       "OU": "iamctl"
</span><span class="s">     }
</span><span class="s">   ],
</span><span class="s">   "hosts": []
</span><span class="s"> }
</span><span class="s"> EOF</span></code></pre></div><p class="ztext-empty-paragraph"><br></p><p data-pid="IeqPxLP6"><b>生成证书和私钥：</b></p><div class="highlight"><pre><code class="language-bash"> $ cfssl gencert -ca<span class="o">=</span><span class="si">${</span><span class="nv">IAM_CONFIG_DIR</span><span class="si">}</span>/cert/ca.pem <span class="se">\
</span><span class="se"></span>   -ca-key<span class="o">=</span><span class="si">${</span><span class="nv">IAM_CONFIG_DIR</span><span class="si">}</span>/cert/ca-key.pem <span class="se">\
</span><span class="se"></span>   -config<span class="o">=</span><span class="si">${</span><span class="nv">IAM_CONFIG_DIR</span><span class="si">}</span>/cert/ca-config.json <span class="se">\
</span><span class="se"></span>   -profile<span class="o">=</span>iam admin-csr.json <span class="p">|</span> cfssljson -bare admin
 $ mkdir -p <span class="k">$(</span>dirname <span class="si">${</span><span class="nv">CONFIG_USER_CLIENT_CERTIFICATE</span><span class="si">}</span><span class="k">)</span> <span class="k">$(</span>dirname <span class="si">${</span><span class="nv">CONFIG_USER_CLIENT_KEY</span><span class="si">}</span><span class="k">)</span> <span class="c1"># 创建客户端证书存放的目录</span>
 $ mv admin.pem <span class="si">${</span><span class="nv">CONFIG_USER_CLIENT_CERTIFICATE</span><span class="si">}</span> <span class="c1"># 安装 TLS 的客户端证书</span>
 $ mv admin-key.pem <span class="si">${</span><span class="nv">CONFIG_USER_CLIENT_KEY</span><span class="si">}</span> <span class="c1"># 安装 TLS 的客户端私钥文件</span></code></pre></div><p class="ztext-empty-paragraph"><br></p><h3><b>第 2 步，安装 iamctl。</b></h3><p data-pid="1IJc2gUq">iamctl 是 IAM 系统的客户端工具，其安装位置和 iam-apiserver、iam-authz-server、iam-pump 位置不同，为了能够在 shell 下直接运行 iamctl 命令，我们需要将 iamctl 安装到<code>$HOME/bin</code> 下，同时将 iamctl 的配置存放在默认加载的目录下：<code>$HOME/.iam</code>。主要分 2 步进行。</p><p class="ztext-empty-paragraph"><br></p><p data-pid="VrKVkG47"><b>安装 iamctl 可执行程序：</b></p><div class="highlight"><pre><code class="language-bash"> $ <span class="nb">cd</span> <span class="nv">$IAM_ROOT</span>
 $ <span class="nb">source</span> scripts/install/environment.sh
 $ make build <span class="nv">BINS</span><span class="o">=</span>iamctl
 $ cp _output/platforms/linux/amd64/iamctl <span class="nv">$HOME</span>/bin</code></pre></div><p class="ztext-empty-paragraph"><br></p><p data-pid="QhDQ2s7_"><b>生成并安装 iamctl 的配置文件（iamctl.yaml）：</b></p><div class="highlight"><pre><code class="language-bash"> $ ./scripts/genconfig.sh scripts/install/environment.sh configs/iamctl.yaml&gt; iamctl.yaml
 $ mkdir -p <span class="nv">$HOME</span>/.iam
 $ mv iamctl.yaml <span class="nv">$HOME</span>/.iam</code></pre></div><p data-pid="cXyoZl51">因为 iamctl 是一个客户端工具，可能会在多台机器上运行。为了简化部署 iamctl 工具的复杂度，我们可以把 config 配置文件中跟 CA 认证相关的 CA 文件内容用 base64 加密后，放置在 config 配置文件中。具体的思路就是把 config 文件中的配置项 client-certificate、client-key、certificate-authority 分别用如下配置项替换 client-certificate-data、client-key-data、certificate-authority-data。这些配置项的值可以通过对 CA 文件使用 base64 加密获得。</p><p data-pid="UEvf7b2V">假如，certificate-authority 值为<code>/etc/iam/cert/ca.pem</code>，则 certificate-authority-data 的值为 <code>cat "/etc/iam/cert/ca.pem" | base64 | tr -d '\r\n'</code>，其它-data 变量的值类似。这样当我们再部署 iamctl 工具时，只需要拷贝 iamctl 和配置文件，而不用再拷贝 CA 文件了。</p><p class="ztext-empty-paragraph"><br></p><h3><b>第 3 步，测试 iamctl 是否成功安装。</b></h3><p data-pid="AGxOQIEz">执行 <code>iamctl user list</code> 可以列出预创建的 admin 用户，如下图所示：</p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic2.zhimg.com/v2-3318b038fbd0457f269f577b8c6b3f21_r.jpg" data-caption="" data-size="normal" width="1540" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>安装和配置 iam-authz-server</b></h3><p data-pid="zoSDA2jF">接下来，我们需要安装另外一个核心组件：iam-authz-server，可以通过以下 3 步来安装。</p><h3><b>第 1 步，创建 iam-authz-server 证书和私钥。</b></h3><p data-pid="SHW0D_sL"><b>创建证书签名请求：</b></p><div class="highlight"><pre><code class="language-bash"> $ <span class="nb">cd</span> <span class="nv">$IAM_ROOT</span>
 $ <span class="nb">source</span> scripts/install/environment.sh
 $ tee iam-authz-server-csr.json <span class="s">&lt;&lt;EOF
</span><span class="s"> {
</span><span class="s">   "CN": "iam-authz-server",
</span><span class="s">   "key": {
</span><span class="s">     "algo": "rsa",
</span><span class="s">     "size": 2048
</span><span class="s">   },
</span><span class="s">   "names": [
</span><span class="s">     {
</span><span class="s">       "C": "CN",
</span><span class="s">       "ST": "BeiJing",
</span><span class="s">       "L": "BeiJing",
</span><span class="s">       "O": "marmotedu",
</span><span class="s">       "OU": "iam-authz-server"
</span><span class="s">     }
</span><span class="s">   ],
</span><span class="s">   "hosts": [
</span><span class="s">     "127.0.0.1",
</span><span class="s">     "localhost",
</span><span class="s">     "iam.authz.marmotedu.com"
</span><span class="s">   ]
</span><span class="s"> }
</span><span class="s"> EOF</span></code></pre></div><p data-pid="I6EC1M6i">代码中的 hosts 字段指定授权使用该证书的 IP 和域名列表，上面的 hosts 列出了 iam-authz-server 服务的 IP 和域名。</p><p data-pid="O61haNbi"><b>生成证书和私钥：</b></p><div class="highlight"><pre><code class="language-bash"> $ cfssl gencert -ca<span class="o">=</span><span class="si">${</span><span class="nv">IAM_CONFIG_DIR</span><span class="si">}</span>/cert/ca.pem <span class="se">\
</span><span class="se"></span>   -ca-key<span class="o">=</span><span class="si">${</span><span class="nv">IAM_CONFIG_DIR</span><span class="si">}</span>/cert/ca-key.pem <span class="se">\
</span><span class="se"></span>   -config<span class="o">=</span><span class="si">${</span><span class="nv">IAM_CONFIG_DIR</span><span class="si">}</span>/cert/ca-config.json <span class="se">\
</span><span class="se"></span>   -profile<span class="o">=</span>iam iam-authz-server-csr.json <span class="p">|</span> cfssljson -bare iam-authz-server
 $ sudo mv iam-authz-server*pem <span class="si">${</span><span class="nv">IAM_CONFIG_DIR</span><span class="si">}</span>/cert <span class="c1"># 将生成的证书和私钥文件拷贝到配置文件目录</span></code></pre></div><p class="ztext-empty-paragraph"><br></p><h3><b>第 2 步，安装并运行 iam-authz-server。</b></h3><p data-pid="K5c8dm9E">安装 iam-authz-server 步骤和安装 iam-apiserver 步骤基本一样，也需要 4 步。</p><p data-pid="9MMv8mul"><b>安装 iam-authz-server 可执行程序：</b></p><div class="highlight"><pre><code class="language-bash"> $ <span class="nb">cd</span> <span class="nv">$IAM_ROOT</span>
 $ <span class="nb">source</span> scripts/install/environment.sh
 $ make build <span class="nv">BINS</span><span class="o">=</span>iam-authz-server
 $ sudo cp _output/platforms/linux/amd64/iam-authz-server <span class="si">${</span><span class="nv">IAM_INSTALL_DIR</span><span class="si">}</span>/bin</code></pre></div><p class="ztext-empty-paragraph"><br></p><p data-pid="zVovBJc-"><b>生成并安装 iam-authz-server 的配置文件（iam-authz-server.yaml）：</b></p><div class="highlight"><pre><code class="language-bash"> $ ./scripts/genconfig.sh scripts/install/environment.sh configs/iam-authz-server.yaml &gt; iam-authz-server.yaml
 $ sudo mv iam-authz-server.yaml <span class="si">${</span><span class="nv">IAM_CONFIG_DIR</span><span class="si">}</span></code></pre></div><p class="ztext-empty-paragraph"><br></p><p data-pid="lS3aYa0e"><b>创建并安装 iam-authz-server systemd unit 文件：</b></p><div class="highlight"><pre><code class="language-bash"> $ ./scripts/genconfig.sh scripts/install/environment.sh init/iam-authz-server.service &gt; iam-authz-server.service
 $ sudo mv iam-authz-server.service /etc/systemd/system/</code></pre></div><p class="ztext-empty-paragraph"><br></p><p data-pid="LKRBZhkt"><b>启动 iam-authz-server 服务：</b></p><div class="highlight"><pre><code class="language-bash"> $ sudo systemctl daemon-reload
 $ sudo systemctl <span class="nb">enable</span> iam-authz-server
 $ sudo systemctl restart iam-authz-server
 $ systemctl status iam-authz-server 
 <span class="c1"># 查看 iam-authz-server 运行状态，如果输出中包含 active (running)字样说明 iam-authz-server 成功启动。</span></code></pre></div><p class="ztext-empty-paragraph"><br></p><h3><b>第 3 步，测试 iam-authz-server 是否成功安装。</b></h3><p data-pid="ad_nE2hh"><b>重新登陆系统，并获取访问令牌</b></p><div class="highlight"><pre><code class="language-bash"> $ <span class="nv">token</span><span class="o">=</span><span class="sb">`</span>curl -s -XPOST -H<span class="s1">'Content-Type: application/json'</span> -d<span class="s1">'{"username":"admin","password":"Admin@2021"}'</span> http://127.0.0.1:8080/login <span class="p">|</span> jq -r .token<span class="sb">`</span></code></pre></div><p class="ztext-empty-paragraph"><br></p><p data-pid="QJxcA-tk"><b>创建授权策略:</b></p><div class="highlight"><pre><code class="language-bash"> $ curl -s -XPOST -H<span class="s2">"Content-Type: application/json"</span> -H<span class="s2">"Authorization: Bearer </span><span class="nv">$token</span><span class="s2">"</span> -d<span class="s1">'{"metadata":{"name":"authztest"},"policy":{"description":"One policy to rule them all.","subjects":["users:&lt;peter|ken&gt;","users:maria","groups:admins"],"actions":["delete","&lt;create|update&gt;"],"effect":"allow","resources":["resources:articles:&lt;.*&gt;","resources:printer"],"conditions":{"remoteIPAddress":{"type":"CIDRCondition","options":{"cidr":"192.168.0.1/16"}}}}}'</span> http://127.0.0.1:8080/v1/policies</code></pre></div><p class="ztext-empty-paragraph"><br></p><p data-pid="Lw8XrAfH"><b>创建密钥，并从命令的输出中提取 secretID 和 secretKey</b></p><div class="highlight"><pre><code class="language-bash"> $ curl -s -XPOST -H<span class="s2">"Content-Type: application/json"</span> -H<span class="s2">"Authorization: Bearer </span><span class="nv">$token</span><span class="s2">"</span> -d<span class="s1">'{"metadata":{"name":"authztest"},"expires":0,"description":"admin secret"}'</span> http://127.0.0.1:8080/v1/secrets
 <span class="o">{</span><span class="s2">"metadata"</span>:<span class="o">{</span><span class="s2">"id"</span>:23,<span class="s2">"instanceID"</span>:<span class="s2">"secret-yj8m30"</span>,<span class="s2">"name"</span>:<span class="s2">"authztest"</span>,<span class="s2">"createdAt"</span>:<span class="s2">"2023-02-16T19:55:29.407+08:00"</span>,<span class="s2">"updatedAt"</span>:<span class="s2">"2023-02-16T19:55:29.407+08:00"</span><span class="o">}</span>,<span class="s2">"username"</span>:<span class="s2">"admin"</span>,<span class="s2">"secretID"</span>:<span class="s2">"Ouk0bP2SX36f5FgpGWnFZy6Tpom89VEljtUo"</span>,<span class="s2">"secretKey"</span>:<span class="s2">"uIhkIKQ7GA7eSCIdjNYQgvRoE3d6n9bo"</span>,<span class="s2">"expires"</span>:0,<span class="s2">"description"</span>:<span class="s2">"admin secret"</span><span class="o">}</span></code></pre></div><p class="ztext-empty-paragraph"><br></p><p data-pid="YmCEFcJO"><b>生成访问 iam-authz-server 的 token</b></p><p data-pid="ZasIKCd2">iamctl 提供了 jwt sigin 命令，可以根据 secretID 和 secretKey 签发 Token，方便你使用。</p><div class="highlight"><pre><code class="language-bash"> $ iamctl jwt sign Ouk0bP2SX36f5FgpGWnFZy6Tpom89VEljtUo uIhkIKQ7GA7eSCIdjNYQgvRoE3d6n9bo <span class="c1"># iamctl jwt sign $secretID $secretKey，替换成上一步创建的密钥对</span>
 eyJhbGciOiJIUzI1NiIsImtpZCI6Ik91azBiUDJTWDM2ZjVGZ3BHV25GWnk2VHBvbTg5VkVsanRVbyIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJpYW0uYXV0aHoubWFybW90ZWR1LmNvbSIsImV4cCI6MTY3NjU1NTg3NywiaWF0IjoxNjc2NTQ4Njc3LCJpc3MiOiJpYW1jdGwiLCJuYmYiOjE2NzY1NDg2Nzd9.CdbBrm9-mErgysb5xwa0EQPboQWnXJpXOBZZk6K6M9E</code></pre></div><p data-pid="m-7n5ivR">如果你的开发过程中有些重复性的操作，为了方便使用，也可以将这些操作以 iamctl 子命令的方式集成到 iamctl 命令行中。</p><p class="ztext-empty-paragraph"><br></p><p data-pid="1eJhfq3C"><b>测试资源授权是否通过</b></p><p data-pid="J1hCpSjo">我们可以通过请求 /v1/authz 来完成资源授权：</p><div class="highlight"><pre><code class="language-bash"> $ curl -s -XPOST -H<span class="s1">'Content-Type: application/json'</span> -H<span class="s1">'Authorization: Bearer eyJhbGciOiJIUzI1NiIsImtpZCI6Ik91azBiUDJTWDM2ZjVGZ3BHV25GWnk2VHBvbTg5VkVsanRVbyIsInR5cCI6IkpXVCJ9.eyJhdWQiOiJpYW0uYXV0aHoubWFybW90ZWR1LmNvbSIsImV4cCI6MTY3NjU1NTg3NywiaWF0IjoxNjc2NTQ4Njc3LCJpc3MiOiJpYW1jdGwiLCJuYmYiOjE2NzY1NDg2Nzd9.CdbBrm9-mErgysb5xwa0EQPboQWnXJpXOBZZk6K6M9E'</span> -d<span class="s1">'{"subject":"users:maria","action":"delete","resource":"resources:articles:ladon-introduction","context":{"remoteIPAddress":"192.168.0.5"}}'</span> http://127.0.0.1:9090/v1/authz
 <span class="o">{</span><span class="s2">"allowed"</span>:true<span class="o">}</span></code></pre></div><p data-pid="qfdcm3WV">如果授权通过会返回：<code>{"allowed":true}</code> 。</p><p class="ztext-empty-paragraph"><br></p><h3><b>安装和配置 iam-pump</b></h3><p data-pid="JdViBFnU">安装 iam-pump 步骤和安装 iam-apiserver、iam-authz-server 步骤基本一样，具体步骤如下。</p><p data-pid="QOmw-G7r"><b>第 1 步，安装 iam-pump 可执行程序。</b></p><div class="highlight"><pre><code class="language-bash"> $ <span class="nb">cd</span> <span class="nv">$IAM_ROOT</span>
 $ <span class="nb">source</span> scripts/install/environment.sh
 $ make build <span class="nv">BINS</span><span class="o">=</span>iam-pump
 $ sudo cp _output/platforms/linux/amd64/iam-pump <span class="si">${</span><span class="nv">IAM_INSTALL_DIR</span><span class="si">}</span>/bin</code></pre></div><p class="ztext-empty-paragraph"><br></p><p data-pid="8NUo61hM"><b>第 2 步，生成并安装 iam-pump 的配置文件（iam-pump.yaml）。</b></p><div class="highlight"><pre><code class="language-bash"> $ ./scripts/genconfig.sh scripts/install/environment.sh configs/iam-pump.yaml &gt; iam-pump.yaml
 $ sudo mv iam-pump.yaml <span class="si">${</span><span class="nv">IAM_CONFIG_DIR</span><span class="si">}</span></code></pre></div><p class="ztext-empty-paragraph"><br></p><p data-pid="G6vEBsKI"><b>第 3 步，创建并安装 iam-pump systemd unit 文件。</b></p><div class="highlight"><pre><code class="language-bash"> $ ./scripts/genconfig.sh scripts/install/environment.sh init/iam-pump.service &gt; iam-pump.service
 $ sudo mv iam-pump.service /etc/systemd/system/</code></pre></div><p class="ztext-empty-paragraph"><br></p><p data-pid="omn8vNMD"><b>第 4 步，启动 iam-pump 服务。</b></p><div class="highlight"><pre><code class="language-bash"> $ sudo systemctl daemon-reload
 $ sudo systemctl <span class="nb">enable</span> iam-pump
 $ sudo systemctl restart iam-pump
 $ systemctl status iam-pump <span class="c1"># 查看 iam-pump 运行状态，如果输出中包含 active (running)字样说明 iam-pump 成功启动。</span></code></pre></div><p class="ztext-empty-paragraph"><br></p><p data-pid="JllFp3Gt"><b>第 5 步，测试 iam-pump 是否成功安装。</b></p><div class="highlight"><pre><code class="language-bash"> $ curl http://127.0.0.1:7070/healthz
 <span class="o">{</span><span class="s2">"status"</span>: <span class="s2">"ok"</span><span class="o">}</span></code></pre></div><p data-pid="ZVsupl5-">经过上面这 5 个步骤，如果返回 <code>{“status”: “ok”}</code> 就说明 iam-pump 服务健康</p><p class="ztext-empty-paragraph"><br></p><h3><b>安装 man 文件</b></h3><p data-pid="RHAEzKbp">IAM 系统通过组合调用包：<a href="https://zhuanlan.zhihu.com/p/606959150/edit">github.com/cpuguy83/go-md2man/v2/md2man</a> 和 <a href="https://github.com/spf13/cobra" target="_blank">github.com/spf13/cobra</a> 的相关函数生成了各个组件的 man1 文件，主要分 3 步实现。</p><p data-pid="aRSLoqaj"><b>第 1 步，生成各个组件的 man1 文件。</b></p><div class="highlight"><pre><code class="language-bash"> $ <span class="nb">cd</span> <span class="nv">$IAM_ROOT</span>
 $ ./scripts/update-generated-docs.sh</code></pre></div><p class="ztext-empty-paragraph"><br></p><p data-pid="u3V1zsrz"><b>第 2 步，安装生成的 man1 文件。</b></p><div class="highlight"><pre><code class="language-bash"> $ sudo cp docs/man/man1/* /usr/share/man/man1/</code></pre></div><p class="ztext-empty-paragraph"><br></p><p data-pid="4PQGcT2z"><b>第 3 步，检查是否成功安装 man1 文件。</b></p><div class="highlight"><pre><code class="language-bash"> $ man iam-apiserver</code></pre></div><blockquote data-pid="MtrRm_qB"><b>执行 man iam-apiserver 命令后，会弹出 man 文档界面，如下图所示：</b></blockquote><figure data-size="normal"><img src="https://pic3.zhimg.com/v2-2bd2e766b90f49dd091e5a3d41b91006_r.jpg" data-caption="" data-size="normal" width="2563" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><p data-pid="1Ind_fG7">至此，IAM 系统所有组件都已经安装成功了，你可以通过 iamctl version 查看客户端和服务端版本，代码如下：</p><div class="highlight"><pre><code class="language-bash"> $ iamctl version -o yaml
 clientVersion:
   buildDate: <span class="s2">"2023-02-16T11:43:40Z"</span>
   compiler: gc
   gitCommit: f39d4105e563c01fb4869bbaf1b19f5afa944400
   gitTreeState: dirty
   gitVersion: f39d410
   goVersion: go1.18.3
   platform: linux/amd64
 serverVersion:
   buildDate: <span class="s2">"2023-02-16T11:18:53Z"</span>
   compiler: gc
   gitCommit: f39d4105e563c01fb4869bbaf1b19f5afa944400
   gitTreeState: dirty
   gitVersion: f39d410
   goVersion: go1.18.3
   platform: linux/amd64</code></pre></div><p class="ztext-empty-paragraph"><br></p><h2><b>一键安装</b></h2><p data-pid="1fADQAGU"><b>除此之外，还可以一键安装：</b></p><div class="highlight"><pre><code class="language-bash"> $ <span class="nb">export</span> <span class="nv">LINUX_PASSWORD</span><span class="o">=</span><span class="s1">'iam59!z </details> 
 <hr /> 
</span> <span class="c1"># 重要：这里要 export going 用户的密码</span>
 $ <span class="nv">version</span><span class="o">=</span>latest <span class="o">&amp;&amp;</span> curl https://marmotedu-1254073058.cos.ap-beijing.myqcloud.com/iam-release/<span class="si">${</span><span class="nv">version</span><span class="si">}</span>/iam.tar.gz <span class="p">|</span> tar -xz -C / tmp/       
 $ <span class="nb">cd</span> /tmp/iam/ <span class="o">&amp;&amp;</span> ./scripts/install/install.sh iam::install::install</code></pre></div><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h2><b>总结</b></h2><p data-pid="66Ps8vZb">⚠️ 所有组件设置的密码都是 <code>iam59!z$</code></p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic2.zhimg.com/v2-6b4ecffb1dce8a5c15e6609ac5a50ac5_r.jpg" data-caption="" data-size="normal" width="1088" referrerpolicy="no-referrer"></figure><p></p><p></p></div> </details> 
 <hr /> 

 #### - [go语言1.20发布 | 新特性](https://zhuanlan.zhihu.com/p/602834012) 
 <details><summary>توضیحات</summary> <p><img src="https://picx.zhimg.com/v2-20c7dc7d9fbceaed787f9c4a6bbf9490_720w.jpg?source=d16d100b"></p><div><ul><li data-pid="1ENaVezW"><a href="https://github.com/3293172751" target="_blank">author</a></li></ul><h2><b>go语言1.20发布</b></h2><ul><li data-pid="_2szrLzH"><a href="typora://app/README.md" target="_blank">回到目录</a></li><li data-pid="wKRNG-Ie"><a href="https://zhuanlan.zhihu.com/31.md">上一节</a></li></ul><blockquote data-pid="doXc1zg2">❤️  Go语言高级篇章,在此之前建议您先了解基础和进阶篇。Myblog:<a href="http://nsddd.top/" target="_blank">http://nsddd.top</a></blockquote><a data-draft-node="block" data-draft-type="link-card" href="https://github.com/3293172751/Block_Chain/blob/master/TOC.md" target="_blank">Go语言基础篇</a><p class="ztext-empty-paragraph"><br></p><a data-draft-node="block" data-draft-type="link-card" href="https://github.com/3293172751/Block_Chain/blob/master/Gomd_super/README.md" target="_blank">Go语言100篇进阶</a><h2><b>开始</b></h2><figure data-size="normal"><img src="https://pic2.zhimg.com/v2-94578b7958adc938c0ce7eb420c5e50d_r.jpg" data-size="normal" data-caption="" width="2718" referrerpolicy="no-referrer"></figure><p data-pid="PS3Xo30w">可以访问<a href="https://go.dev/dl/" target="_blank">下载页面</a>获取它</p><p data-pid="C1Y_PVYg"><b>向下兼容，无脑升就好了！Go 1.20 amd64 版本 95MB，相比 Go 1.19 144MB，以及 Go 1.18.10 138MB 来说，降幅达到了 49MB</b>。</p><p data-pid="SGJA5Ytb"><a href="https://tip.golang.org/doc/go1.19" target="_blank">最新的 Go 版本 1.20 在Go 1.19</a> 发布六个月后发布。它的大部分更改都在工具链、运行时和库的实现中。一如既往，该版本保持了 Go 1<a href="https://tip.golang.org/doc/go1compat" target="_blank">的兼容性承诺</a>。我们期望几乎所有的 Go 程序都能像以前一样继续编译和运行。</p><h2><b>语言的变化</b></h2><p data-pid="hI5JhS9g"><b>四个变化：</b></p><ol><li data-pid="yzuzFQAC">Go 1.17 添加了<a href="https://tip.golang.org/ref/spec#Conversions_from_slice_to_array_or_array_pointer" target="_blank">从切片到数组指针的转换</a>。Go 1.20 扩展了它以允许从切片到数组的转换：给定一个切片<code>x</code>,<code>[4]byte(x)</code>现在可以写成<code>*(*[4]byte)(x)</code>.</li><li data-pid="JdTHqrVo">该<code>f="https://tip.golang.org/ref/spec/#Package_unsafe"&gt;unsafe包定义了三个新函数SliceData、String和StringData。与 Go 1.17 一起Slice，这些函数现在提供了构建和解构切片和字符串值的完整能力，而不依赖于它们的确切表示。</code></li><li data-pid="ITbaQ99L">该规范现在定义结构值一次比较一个字段，按照它们在结构类型定义中出现的顺序考虑字段，并在第一个不匹配时停止。之前可以阅读规范，就好像所有字段都需要比较第一个不匹配之外的字段。类似地，该规范现在定义数组值按递增索引顺序一次比较一个元素。在这两种情况下，差异会影响某些比较是否必须恐慌。现有程序没有改变：新的规范措辞描述了实现一直所做的事情。</li><li data-pid="MhduIAsa"><a href="https://tip.golang.org/ref/spec#Comparison_operators" target="_blank">可比较的类型</a>（例如普通接口）现在可以满足<code>comparable</code>约束，即使类型参数不是严格可比较的（比较可能会在运行时崩溃）。这使得实例化受约束的类型参数<code>comparable</code> （例如，用户定义的通用映射键的类型参数）与非严格可比较的类型参数（例如接口类型或包含接口类型的复合类型）成为可能</li></ol><h2><b>性能提升</b></h2><p data-pid="MBnxL3bG">从 Go 1.21 开始，一些较旧的操作系统将不再受支持：这包括 Windows 7、8、Server 2008 和 Server 2012、macOS 10.13 High Sierra 和 10.14 Mojave。另一方面，Go 1.20 添加了对 RISC-V 上的 FreeBSD 的实验性支持。</p><ul><li data-pid="5XeAZBzE">编译器和垃圾收集器的改进减少了内存开销，并将整体 CPU 性能提高了 2%。</li><li data-pid="kY9TUT-G">专门针对编译时间的工作导致构建改进高达 10%。这使构建速度与 Go 1.17 保持一致。</li></ul><p class="ztext-empty-paragraph"><br></p><h2><b>OS 兼容版本</b></h2><p data-pid="6Y_OH5Na">很多还是 Windows7、8 的用户，赶紧升 Go 1.20  吧，这将是最后一个版本。</p><ul><li data-pid="oevG3DSN">Go 1.20 是将在 Windows 7、8、Server 2008 和 Server 2012 的任何版本上运行的最后一个版本。Go 1.21 将至少需要 Windows 10 或 Server 2016。</li><li data-pid="jXhLV2my">Go 1.20 是将在 macOS 10.13 High Sierra 或 10.14 Mojave 上运行的最后一个版本。Go 1.21 将需要 macOS 10.15 Catalina 或更高版本。</li></ul><h2><b>Tool</b></h2><ul><li data-pid="X7eIaqTx">该<code>ef="https://go.dev/testing/coverage"&gt;cover工具现在可以收集整个程序的覆盖率概况，而不仅仅是单元测试。</code></li><li data-pid="1PiUN0E7">该<code> href="https://go.dev/cmd/go"&gt;go工具不再依赖于$GOROOT/pkg目录中预编译的标准库包存档，并且它们不再随发行版一起提供，从而减少了下载量。相反，标准库中的包是根据需要构建的，并像其他包一样缓存在构建缓存中。</code></li><li data-pid="Xw2nuz48">的实施<code>go test -json</code>已得到改进，以使其在出现杂散写入时更加健壮<code>stdout</code>。</li><li data-pid="5U1Za6VR">、<code>go build</code>和<code>go install</code>其他与构建相关的命令现在接受一个<code>-pgo</code>启用配置文件引导优化的标志以及一个<code>-cover</code>用于整个程序覆盖率分析的标志。</li><li data-pid="PomYX86Q">该<code>go</code>命令现在默认在没有 C 工具链的系统上禁用<code>cgo</code>。因此，当 Go 安装在没有 C 编译器的系统上时，它现在将对标准库中的包使用纯 Go 构建，这些包可以选择使用 cgo，而不是使用预分发的包存档（已被删除，如上所述） .</li><li data-pid="G3zr98mg">该<code>href="https://go.dev/cmd/vet"&gt;vet工具报告了在并行运行的测试中可能发生的更多循环变量引用错误。</code></li></ul><h2><b>标准库</b></h2><ul><li data-pid="qQY0-koi">新<code><a href="https://go.dev/pkg/crypto/ecdh" target="_blank">crypto/ecdh</a></code>包明确支持 NIST 曲线和 Curve25519 上的椭圆曲线 Diffie-Hellman 密钥交换。</li><li data-pid="Zg6jounV">新函数返回一个包含错误列表的错误，如果错误类型实现了该方法<code><a href="https://go.dev/pkg/errors#Join" target="_blank">errors.Join</a></code>，则可以再次获取错误列表。<code>Unwrap() []error</code></li><li data-pid="fYDWRUDa">新<code><a href="https://go.dev/pkg/net/http#ResponseController" target="_blank">http.ResponseController</a></code>类型提供对接口未处理的扩展的按请求功能的 <code><a href="https://go.dev/pkg/net/http#ResponseWriter" target="_blank">http.ResponseWriter</a></code>访问。</li><li data-pid="6_e3Xkxx"><code><a href="https://go.dev/pkg/net/http/httputil#ReverseProxy" target="_blank">httputil.ReverseProxy</a></code> 转发代理包括一个新的钩子<code>Rewrite</code>函数，取代了以前的<code>Director</code>钩子。</li><li data-pid="BqnZpjiK">新<code><a href="https://go.dev/pkg/context#WithCancelCause" target="_blank">context.WithCancelCause</a></code>函数提供了一种方法来取消具有给定错误的上下文。可以通过调用新 <code><a href="https://go.dev/pkg/context#Cause" target="_blank">context.Cause</a></code>函数来检索该错误。</li><li data-pid="Cf28SEDG">新<code><a href="https://go.dev/pkg/os/exec#Cmd" target="_blank">os/exec.Cmd</a></code>字段<code><a href="https://go.dev/pkg/os/exec#Cmd.Cancel" target="_blank">Cancel</a></code> 并<code><a href="https://go.dev/pkg/os/exec#Cmd.WaitDelay" target="_blank">WaitDelay</a></code>指定 <code>Cmd</code>其关联<code>Context</code>被取消或进程退出时的行为。</li></ul><p class="ztext-empty-paragraph"><br></p><h2><b>其他的一些内容</b></h2><p data-pid="izfZ-YHs"><b>链接器：</b></p><p data-pid="V99h6uM8">Go 1.20 对编译器生成的符号使用<code>go:</code>and<code>type:</code>前缀，而不是<code>go.</code>and <code>type.</code>。这避免了名称以 . 开头的用户包的混淆<code>go.</code>。该<code><a href="https://tip.golang.org/pkg/debug/gosym" target="_blank">debug/gosym</a></code>软件包理解使用 Go 1.20 及更新版本构建的二进制文件的新命名约定。</p><ul><li data-pid="OaR7wuLB"><code>$GOROOT/pkg</code> 目录不再存储标准存档的预编译包存档，以减少 Go 发行版的大小。</li><li data-pid="SbW18X-5">go 命令现在定义架构功能 build flags，如 amd64.V2，以允许根据特定 CPU 架构功能的存在或不存在来选择包实现文件。这对于 x86_64 微架构特性级别的工作来说是个好消息。</li><li data-pid="h712YE8K">go build 和 go install 以及其他与构建相关的命令现在支持 “-cover” flag，用于启用带有 code coverage instrumentation 的构建。</li><li data-pid="De2ObwxF">由于在垃圾收集器上的工作，内存开销减少和 CPU 性能提高高达 2%。</li><li data-pid="TKLaRTpP">对 Profile Guided Optimizations (PGO) 的预览支持。</li><li data-pid="yx2IPlkG">在 Linux 上，linker 现在在链接时为 glibc 或 musl 选择动态解释器。</li><li data-pid="RHSA5nV8">一个新的 crypto/ecdh 包，为 NIST curves 和 Curve25519 上的 Elliptic Curve Diffie-Hellman 密钥交换提供明确支持。</li></ul><h2><b>END 链接</b></h2><p data-pid="QMCPARLF">请参考Go官方博客（<a href="https://go.dev/blog/go1.20" target="_blank"><span class="invisible">https://</span><span class="visible">go.dev/blog/go1.20</span><span class="invisible"></span></a>）和Go语言官方文档（<a href="https://tip.golang.org/doc/go1.20" target="_blank"><span class="invisible">https://</span><span class="visible">tip.golang.org/doc/go1.</span><span class="invisible">20</span><span class="ellipsis"></span></a>）了解更多关于Go语言1.20版本的详细信息。</p></div> </details> 
 <hr /> 

 #### - [一篇文章精通git协同开发工作流](https://zhuanlan.zhihu.com/p/602190234) 
 <details><summary>توضیحات</summary> <p><img src="https://picx.zhimg.com/v2-8bdbd6b85fcd3de0434de2b77b2b3f8b_720w.jpg?source=d16d100b"></p><div><h2>Git版本控制</h2><p data-pid="U7SiZpmj"><i>❓由一个很神奇的问题展开，git是什么，它仅仅是一个工具嘛？</i></p><p data-pid="gRI-Yddp">看完这一篇，你可以说你精通 git 啦！！！</p><blockquote data-pid="5BHZWAxZ">Git 是一个版本控制系统。<br>Git 可帮助您跟踪代码更改。<br>Git 用于在代码上进行协作。<br>Git 思想可以带入你的工程(docker | hub | ipfs | ……所有设计版本机制)</blockquote><p data-pid="OHOZ_4Oh"><b>在这里面，可以掌握git的基本操作，基本可以解决百分之九十的开发问题，而剩下的百分之十，对应的最新高级篇可以帮你。</b></p><p data-pid="3hrDtFxI"><b>又或许，我们希望掌握它的原理，或许我们可以从头构建一个git，不是嘛 </b></p><h2>建立你自己的<code>Git</code></h2><ul><li data-pid="E93ofmVU"><b>="<a href="http://stefan.saasen.me/articles/git-clone-in-haskell-from-the-bottom-up/" target="_blank"><span class="invisible">http://</span><span class="visible">stefan.saasen.me/articl</span><span class="invisible">es/git-clone-in-haskell-from-the-bottom-up/</span><span class="ellipsis"></span></a>"&gt;Haskell：在 Haskell 中自下而上重新实现 “git clone”</b></li><li data-pid="aTvO9guE"><b><a href="h&lt;/b&gt;ttp://gitlet.maryrosecook.com/docs/gitlet.html">JavaScript : 小程序</a></b></li><li data-pid="ZUwQbTX_"><b><a href="h&lt;/b&gt;ttps://kushagra.dev/blog/build-git-learn-git/">JavaScript : 制造 GIT - 学习 GIT</a></b></li><li data-pid="Mqo_tEB7"><b>f="<a href="https://benhoyt.com/writings/pygit/" target="_blank"><span class="invisible">https://</span><span class="visible">benhoyt.com/writings/py</span><span class="invisible">git/</span><span class="ellipsis"></span></a>"&gt;Python : 一个 Git 客户端就其创建、提交并转发到 GitHub 上</b></li><li data-pid="fNk51gaJ"><b>f="<a href="https://wyag.thb.lt/" target="_blank"><span class="invisible">https://</span><span class="visible">wyag.thb.lt/</span><span class="invisible"></span></a>"&gt;Python：给自己写一个 Git！</b></li><li data-pid="RtlQPvnR"><b>ref="<a href="https://robots.thoughtbot.com/rebuilding-git-in-ruby" target="_blank"><span class="invisible">https://</span><span class="visible">robots.thoughtbot.com/r</span><span class="invisible">ebuilding-git-in-ruby</span><span class="ellipsis"></span></a>"&gt;Ruby : 在 Ruby 中重建 Git</b></li></ul><h2>实现git</h2><blockquote data-pid="WoPI0BB2">为了实施<code>git clone</code>，将涵盖以下领域：</blockquote><ul><li data-pid="pI_y5l4n"><b>git 协议</b>用于使git 客户端能够使用各种传输机制（本机 git 协议、ssh、http）从远程 git 服务器检索所需的更改集，</li><li data-pid="wGmDKsdn"><b>包文件</b>格式，用于将最少量的数据从服务器传输到客户端（更普遍地用于有效地将打包对象存储在存储库中），</li><li data-pid="jlTjyrbk">git 用于以 blob 形式存储提交、树、标签和实际文件内容的底层<b>对象存储</b></li><li data-pid="oZUXmPPA">以及用于跟踪工作目录中文件更改的<b>索引格式。</b></li></ul><p class="ztext-empty-paragraph"><br></p><ul><li data-pid="12vm-Ki0"> 如何实现<code>clone</code></li></ul><h2>最新 – 进阶</h2><blockquote data-pid="if1WAvtD">git基础篇会解决我们日常的百分之九十的问题，但是总是有那么一些问题需要我们注意的。比如说某一个，我开发的项目的某一个模块感觉这个模块没有之前的好了，那么我想切换回以前的模块。这个时候我们可以用<code>git log 指定项目目录</code> 得到以前的提交记录，然后<code>git switch 想要的版本hash \指定的目录</code> 最后就是<code>git commit -m "checkout ...."</code> 。<br>2022年9月10日 17:47:28<br><b>进阶篇存在的目的或许不仅仅是git语法层面的，就比如说我们需要删除一个分支，可能很简单的两个命令就可以解决</b><br># 用两行命令删除分支 ## 删除本地分支 git branch -d localBranchName  ## 删除远程分支 git push origin --delete remoteBranchName<br><b>但是我们很疑惑它们的用法</b> ️❌&lt;<b>br/&gt;1. 什么时候需要删除分支</b><br>一个 Git 仓库常常有不同的分支，开发者可以在各个分支处理不同的特性，或者在不影响主代码库的情况下修复 bug。<br>仓库常常有一个 <code>master</code> 分支，表示主代码库。开发人员创建其他分支，处理不同的特性。<br>开发人员完成处理一个特性之后，常常会删除相应的分支。&lt;<b>br/&gt;2. 本地删除分支</b><br>如果你还在一个分支上，那么 Git 是不允许你删除这个分支的。所以，请记得退出分支：<code>git checkout master</code>。<br>通过 <code>git branch -d &lt;branch&amp;</code>gt;删除一个分支，比如：<code>git branch -d fix/authentication</code>。<br>当一个分支被推送并合并到远程分支后，<code>-d</code> 才会本地删除该分支。如果一个分支还没有被推送或者合并，那么可以使用<code>-D</code>强制删除它。<br>这就是本地删除分支的方法。&lt;<b>br/&gt;3. 删除远程分支</b><br>使用这个命令可以远程删除分支：<code>git push &lt;remote&gt; --delete &lt;branch&amp;</code>gt;。<br>比如： <code>git push origin --delete fix/authentication</code>，这个分支就被远程删除了。<br>你也可以使用这行简短的命令来远程删除分支：<code>git push &lt;remote&gt; :&lt;branch&amp;</code>gt;，比如：<code>git push origin :fix/authentication</code>。<br>如果你得到以下错误消息，可能是因为其他人已经删除了这个分支。<br>error: unable to push to unqualified destination: remoteBranchName The destination refspec neither matches an existing ref on the remote nor begins with refs/, and we are unable to guess a prefix based on the source ref. error: failed to push some refs to 'git@repository_name'<br>使用以下命令同步分支列表：<br>git fetch -p&lt;<code>br/&gt;-p</code> 的意思是“精简”。这样，你的分支列表里就不会显示已远程被删除的分支了。</blockquote><ul><li data-pid="Z5bDeOS1"><a href="https://github.com/cubxxw/awesome-cs-course/blob/master/Git/markdown/super.md" target="_blank">  Git高级部分</a></li><li data-pid="LuRzheJ_"><a href="https://github.com/cubxxw/awesome-cs-course/blob/master/Git/markdown/move.md" target="_blank">  移动提交记录 — 自由修改提交树</a></li><li data-pid="czux0ctx"><a href="https://github.com/cubxxw/awesome-cs-course/blob/master/Git/markdown/commit.md" target="_blank">  Git提交技巧</a></li><li data-pid="lGiYT8Go"><a href="https://github.com/cubxxw/awesome-cs-course/blob/master/Git/markdown/tags.md" target="_blank">  Git — tags</a></li><li data-pid="9x10tUxB"><a href="https://github.com/cubxxw/awesome-cs-course/blob/master/Git/markdown/rebase.md" target="_blank">  Git — 多次rebase</a></li><li data-pid="KoA_P9jP"><a href="https://github.com/cubxxw/awesome-cs-course/blob/master/Git/markdown/module.md" target="_blank">  Git — module</a></li><li data-pid="CC6MvZhD"><a href="https://github.com/cubxxw/awesome-cs-course/blob/master/Git/markdown/git-script.md" target="_blank">  Git — Script自动推送脚本</a></li></ul><blockquote data-pid="qxQlwoaA"><code>git - module</code>不仅仅很有用，而且里面的实现也值得学习<br><code>git - Script</code>脚本能让我们更快的、更方便推动项目</blockquote><h2>github教程</h2><ul><li data-pid="m8iV4MA9"><a href="https://nsddd.top/archives/actions" target="_blank">基于 Github Action 的 CI/CD 流程</a></li><li data-pid="JBBGJBOi"><a href="http://nsddd.top/archives/git-fork" target="_blank">保持自己github的forks自动和上游仓库同步并推送到 gitee</a></li></ul><h2>基础部分</h2><blockquote data-pid="eOnl0PY8">有时候我们需要撤销上一次的<code>add</code>或者<code>commit</code>怎么办?</blockquote><ul><li data-pid="zuBLvQ-I">我们使用<code>git reset HEAD</code> 这样只是撤销了上一次<code>add</code></li><li data-pid="QjTWu8T4">我们使用：<code>git reset --soft HEAD^</code> 这样就成功撤销了<code>commit</code>。</li><li data-pid="UoX2CwLw">使用<code>git reset --hard HEAD^</code> 这样连<code>add</code>也撤销了。</li></ul><p data-pid="ldVIzsyi">即使是一个简单的推送，或许我们并不赞成强行推送，但是实际确是：我们总是需要去强行推送某一个分支，就比如用npm build搭建出网页推送上去，每一次打包都需要覆盖之前的操作：<br>git push --force origin master</p><ul><li data-pid="vdhNRHdG">  ️ <a href="https://github.com/cubxxw/awesome-cs-course/blob/master/Git/markdown/github%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86.md" target="_blank">1. github基础命令大全</a></li><li data-pid="jGLmBh6U">  ️ <a href="https://github.com/cubxxw/awesome-cs-course/blob/master/Git/markdown/git%E5%92%8Csvn%E5%AF%B9%E6%AF%94.md" target="_blank">2. git和svn对比</a></li><li data-pid="n-2bh7d2">  ️ <a href="https://github.com/cubxxw/awesome-cs-course/blob/master/Git/markdown/git%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86.md" target="_blank">3. git工作原理</a></li><li data-pid="SW9SzWuY">  ️ <a href="https://github.com/cubxxw/awesome-cs-course/blob/master/Git/markdown/git%E5%88%86%E6%94%AF.md" target="_blank">4. git分支</a></li><li data-pid="Yf-R2bOu">  ️ <a href="https://github.com/cubxxw/awesome-cs-course/blob/master/Git/markdown/git%E4%B8%8A%E4%BC%A0.md" target="_blank">5. git上传</a></li><li data-pid="dZkJ93TX">  ️ <a href="https://github.com/cubxxw/awesome-cs-course/blob/master/Git/markdown/%E8%8F%9C%E9%B8%9Fgit.md" target="_blank">6. git（菜鸟）</a></li><li data-pid="D3cJArat">  ️ <a href="https://github.com/cubxxw/awesome-cs-course/blob/master/Git/markdown/git%E5%88%86%E6%94%AF%E4%B8%8E%E5%90%88%E5%B9%B6.md" target="_blank">7. git分支与合并</a></li><li data-pid="Q3AsDgH8">  ️ <a href="https://github.com/cubxxw/awesome-cs-course/blob/master/Git/markdown/git%E7%89%88%E6%9C%AC%E5%9B%9E%E9%80%80.md" target="_blank">8. git版本回退</a></li><li data-pid="8Xb4Blw-">  ️ <a href="https://github.com/cubxxw/awesome-cs-course/blob/master/Git/markdown/git%E6%AF%94%E8%BE%83%E4%B8%A4%E4%B8%AA%E5%88%86%E6%94%AF%E5%B7%AE%E5%BC%82.md" target="_blank">9. git比较两个分支差异</a></li><li data-pid="HrXaLtGI">  ️ <a href="https://github.com/cubxxw/awesome-cs-course/blob/master/Git/markdown/Git%E5%BF%BD%E7%95%A5%E5%92%8Cgitignore.md" target="_blank">10. Git忽略和 .gitignore</a></li><li data-pid="U70iKGOs">  ️ <a href="https://github.com/cubxxw/awesome-cs-course/blob/master/Git/markdown/git-adds.md" target="_blank">11. 提交到多个远程仓库</a></li><li data-pid="nZXihLQf">  ️ <a href="https://github.com/cubxxw/awesome-cs-course/blob/master/Git/markdown/git-contributor.md" target="_blank">12. 贡献代码</a></li></ul><h2>  开源社区实习经历篇</h2><blockquote data-pid="w7A1r2Ev">记录下参与开源社区的一些记录</blockquote><ul><li data-pid="pzigqg5j"><a href="https://nsddd.top/archives/sealos-one" target="_blank">记录</a></li></ul><blockquote data-pid="WQG3EY7U">统一格式：<br>统一格式：git commit -m 'type(scope): 描述(#issue)'</blockquote><p data-pid="6ppwRq4z">我们在提交的时候带上邮箱信息：<code>-s</code></p><p data-pid="kYAFgq56">git commit -s -m "..."</p><blockquote data-pid="rVCOqXEz"><code>git commit</code>艺术：<br>&lt;类型&gt;[可选 范围]: &lt;描述&gt; [可选 正文] [可选 脚注]<br><code>git commit</code>提交类型可以是如下：</blockquote><ol><li data-pid="e3Vae3Ap"><code>feat</code>：新功能（feature）</li><li data-pid="iWIi_cS-"><code>fix</code>：修补bug</li><li data-pid="2phFgb_2"><code>docs</code>：文档（documentation）</li><li data-pid="zXQGm4jS"><code>style</code>： 格式（不影响代码运行的变动）</li><li data-pid="Z7A2F74e"><code>refactor</code>：重构（即不是新增功能，也不是修改bug的代码变动）</li><li data-pid="CBmYzXdo"><code>test</code>：增加测试</li><li data-pid="EAGywqhf"><code>chore</code>：构建过程或辅助工具的变动</li><li data-pid="6BfrWfVD"><code>perf</code>：性能优化</li><li data-pid="FkPvLixQ"><code>revert</code>：回滚</li><li data-pid="2Ment-j5"><code>build</code>：构建</li><li data-pid="Cjf95DFf"><code>ci</code>：持续集成</li><li data-pid="GsBcme1W"><code>update</code>：更新</li><li data-pid="GQ-tQoj5"><code>add</code>：添加</li><li data-pid="sqYzRL7Q"><code>delete</code>：删除</li><li data-pid="uNK5xoCs"><code>init</code>：初始化</li><li data-pid="PQWnomK7"><code>merge</code>：合并</li><li data-pid="W5fI3kbE"><code>move</code>：移动</li><li data-pid="IgQvyQNA"><code>rename</code>：重命名</li><li data-pid="3fTyjDLL"><code>sync</code>：同步</li><li data-pid="hDa81lb3"><code>release</code>：发布</li><li data-pid="JLPw5lJt"><code>hotfix</code>：修复线上问题</li><li data-pid="nTsEBPTh"><code>optimize</code>：优化</li></ol><p class="ztext-empty-paragraph"><br></p><p data-pid="gNja2Wvv">我们或许可以基于远程<code>origin</code>分支创建一个新的分支<code>bug-xiongxinwei</code></p><p data-pid="QW-E0-M0">git checkout -b bug-xiongxinwei origin</p><p data-pid="C8F0E5lF">如果你有多次提交</p><div class="highlight"><pre><code class="language-text">git rebase -i	&lt;commit-id&gt;  # 如果你的pr有多次提交</code></pre></div><p data-pid="tidc-oen">合并：想要把master分支合并到feature分支</p><p data-pid="rnC5_HRm">git checkout feature git rebase master  //这两条命令等价于git rebase master feature</p><p data-pid="q0nKTr3g"><code>origin</code>“和”<code>bug-xiongxinwei</code>“这两个分支各自 前进 了</p><p data-pid="Iwqh4ftv">在这里，你可以用”<code>pull</code>“命令把”<code>origin</code>“分支上的修改拉下来并且和你的修改合并； 结果看起来就像一个新的”合并的提交”(merge commit)</p><p data-pid="xJjicG1m">但是，如果你想让”<code>mywork</code>“分支历史看起来像没有经过任何合并一样，也可以用 <code>git rebase</code>，如下所示:</p><div class="highlight"><pre><code class="language-text">git checkout mywork
git rebase origin</code></pre></div><p data-pid="t08L4cW1">这些命令会把你的”<code>mywork</code>“分支里的每个提交(commit)取消掉，并且把它们临时 保存为补丁(patch)(这些补丁放到”<code>.git/rebase</code>“目录中)，然后把”<code>mywork</code>“分支更新 到最新的”<code>origin</code>“分支，最后把保存的这些补丁应用到”<code>mywork</code>“分支上。</p><h2>我的工作流</h2><p data-pid="LHjBIP3P">在经历几年的 git 使用后，我形成了自己的 git 工作流，配合 GitHub CLI 的使用，<a href="https://nsddd.top/archives/gh" target="_blank">如果你想了解 Github CLI，这篇文章可以帮助到你</a></p><p data-pid="evtLmEHT">最开始使用的是 <b>中心式协同流</b>，下面两个仓库陪伴着我使用最久，也是学习仓库，或许对你们有帮助可以 star：</p><ul><li data-pid="Ds7LBilW"><a href="https://github.com/cubxxw/CS-NativeCloud-Blockchain-awesome" target="_blank">cubxxw/CS-NativeCloud-Blockchain-awesome</a> -   菜鸟成长手册  CS系列 、云原生系列、区块链系列、web3系列 、Golang系列 ...... (2 days ago)</li><li data-pid="mCYbSJAQ"><a href="https://github.com/cubxxw/awesome-cs-course" target="_blank">cubxxw/awesome-cs-course</a> -  awesome：Linux、csapp、os、leetcode、web、html、css、JavaScript、git、java、python、C/C++、mysql、mongodb、golang、blockchain、markdown (6 days ago)</li></ul><p data-pid="24CwEY6q">这个过程一般是下面这个样子的：</p><ol><li data-pid="bFBF5r0W">从服务器上做git pull origin master把代码同步下来</li><li data-pid="F1GgSriM">改完后，git commit到本地仓库中</li><li data-pid="PZtedraG">然后git push origin master到远程仓库中，这样其他同学就可以得到你的代码了</li></ol><p data-pid="hUvXPmKM">如果在第 3 步发现 push 失败，因为别人已经提交了，那么你需要先把服务器上的代码给 pull 下来，为了避免有 merge 动作，你可以使用 git pull --rebase 。这样就可以把服务器上的提交直接合并到你的代码中：</p><ul><li data-pid="mFMVz4qh">先把你本地提交的代码放到一边</li><li data-pid="Rhy3NYrV">然后把服务器上的改动下载下来</li><li data-pid="bW4Q6chs">然后在本地把你之前的改动再重新一个一个地做 commit，直到全部成功</li></ul><p data-pid="G888ddcQ">如果有冲突，那么你要先解决冲突，然后做 git rebase --continue</p><p data-pid="sz2RJKpt">⚠️ 适用于小项目，后面我尝试使用 <b>功能分支协同流</b>：</p><h3>功能分支</h3><p data-pid="Wco4LcRR">引入“功能分支”。这个协同工作流的开发过程如下：</p><ol><li data-pid="kOqOLjpz">首先使用 git checkout -b new-feature 创建 “new-feature”分支</li><li data-pid="o7z9UZsI">然后共同开发这个功能的程序员就在这个分支上工作，进行 add、commit 等操作</li><li data-pid="sv433MqQ">然后通过 git push -u origin new-feature 把分支代码 push 到服务器上</li><li data-pid="vXItyd0p">其他程序员可以通过git pull --rebase来拿到最新的这个分支的代码</li><li data-pid="jJW-rh_t">最后通过 Pull Request 的方式做完 Code Review 后合并到 Master 分支上</li></ol><figure data-size="normal"><img src="https://pic4.zhimg.com/v2-ba87a6a53107f464b900bade812d8b27_r.jpg" data-caption="" data-size="normal" width="1024" referrerpolicy="no-referrer"></figure><p data-pid="NuMz_yIL">但是在生产环境中，这样的开发也是没有办法满足需求的，所以我们出现了一个 GitFlow 协同工作流，但是由于 git flow 太复杂，很乱，所以后面又有了 GitHub Flow 。</p><blockquote data-pid="nAPmFVxB">其中有个问题就是因为分支太多，所以会出现 git log 混乱的局面。具体来说，主要是 git-flow 使用git merge --no-ff来合并分支，在 git-flow 这样多个分支的环境下会让你的分支管理的 log 变得很难看。</blockquote><p data-pid="v76MOu-8">⚠️ 因此，最终我选择的工作流方式是 GitHub Flow ，因为不了解 GitLab，所以对于 GitLab 工作流不做评价。</p><h3>GitHub Flow</h3><p data-pid="rBdArPni">所谓 GitHub Flow，其实也叫 Forking flow，也就是 GitHub 上的那个开发方式。</p><ol><li data-pid="lvOnBxFI">每个开发人员都把 “官方库” 的代码 fork 到自己的代码仓库中。</li><li data-pid="icslyJv6">然后，开发人员在自己的代码仓库中做开发，想干啥干啥。</li><li data-pid="6bzPaQOb">因此，开发人员的代码库中，需要配两个远程仓库，一个是自己的库，一个是官方库（用户的库用于提交代码改动，官方库用于同步代码）。</li><li data-pid="QA3EGKQy">然后在本地建 “功能分支”，在这个分支上做代码开发。</li><li data-pid="UDBF841C">这个功能分支被 push 到开发人员自己的代码仓库中。</li><li data-pid="Si7CCBPU">然后，向 “官方库” 发起 pull request，并做 Code Review。</li></ol><p data-pid="vv5hAxt0">这就是 GitHub 的工作流程。</p><p data-pid="yklnugAg">如果你有 “官方库” 的权限，那么就可以直接在 “官方库” 中建功能分支开发，然后提交 pull request。通过 Code Review 后，合并进 Master 分支，而 Master 一旦有代码被合并就可以马上 release。</p><p data-pid="6lVplIvq">这是一种非常 Geek 的玩法。这需要一个自动化的 CI/CD 工具做辅助。是的，CI/CD 应该是开发中的标配了。</p><p data-pid="dSTKJJLZ"><a href="https://nsddd.top/archives/actions" target="_blank">关于 CI/CD action 可以看这篇文章</a>，当然，所有笔记在上面的仓库中都有介绍，有心人自然能找到。</p><h3>找到适合你的</h3><p data-pid="nIerz_QR">我们知道软件开发的趋势一定是下面这个样子的：</p><ul><li data-pid="s-65Udgq">以微服务或是 SOA 为架构的方式。一个大型软件会被拆分成若干个服务，那么，我们的代码应该也会跟着服务拆解成若干个代码仓库。这样一来，我们的每个代码仓库都会变小，于是我们的协同工作流程就会变简单。<br>对于每个服务的代码仓库，我们的开发和迭代速度也会变得很快，开发团队也会跟服务一样被拆分成多个小团队。这样一来， GitFlow 这种协同工作流程就非常重了，而 GitHub 这种方式或是功能分支这种方式会更适合我们的开发。</li><li data-pid="SQw-M1wi">以 DevOps 为主的开发流程。DevOps 关注于 CI/CD，需要我们有自动化的集成测试和持续部署的工具。这样一来，我们的代码发布速度就会大大加快，每一次提交都能很快地被完整地集成测试，并很快地发布到生产线上。</li></ul><p data-pid="86au2Sad">我在想，是否有一种工作流，可以面对我们现实工作中的各种情况。但是，我想这个世界太复杂了，应该不存在一种一招鲜吃遍天的放之四海皆准的银弹方案。所以，我们还要根据自己的实际情况来挑选适合我们的协同工作的方式。</p></div> </details> 
 <hr /> 

 #### - [Go语言框架三件套（Web/RPC/GORM)](https://zhuanlan.zhihu.com/p/601286934) 
 <details><summary>توضیحات</summary> <p><img src="https://picx.zhimg.com/v2-8b20b14c5c966403f294dd154dfaf73b_720w.jpg?source=d16d100b"></p><div><ul><li data-pid="mPzz-N6_"><a href="https://github.com/3293172751" target="_blank">author</a></li></ul><h2>第29节 Go语言框架三件套（Web/RPC/GORM)</h2><h3>ORM、GORM</h3><figure data-size="normal"><img src="https://pic2.zhimg.com/v2-f7a6d910b6f99427003f2a470908e6d5_r.jpg" data-size="normal" width="1910" referrerpolicy="no-referrer"><figcaption>image-20230120210000499</figcaption></figure><p data-pid="ucsb0BsH">ORM全称是：Object Relational Mapping(<b>对象关系映射</b>)，其主要作用是在编程中，把<b>面向对象</b>的概念跟数据库中<b>表的概念</b>对应起来。</p><p data-pid="wApxfHq0"><i>举例来说就是，我定义一个对象，那就对应着一张表，这个对象的实例，就对应着表中的一条记录。</i></p><p data-pid="MJ4ptc_l">GORM：是Golang语言中一款<b>性能极好</b>的ORM库，对开发人员相对是比较友好的。</p><h3>GROM</h3><h3>GORM特性</h3><ul><li data-pid="3RleEp8n">全功能 ORM</li><li data-pid="SeZCDswR">关联 (Has One，Has Many，Belongs To，Many To Many，多态，单表继承)</li><li data-pid="Xm6eupMm">Create，Save，Update，Delete，Find 中钩子方法</li><li data-pid="0wUm9s5x">支持 <code>Preload</code>、<code>Joins</code> 的预加载</li><li data-pid="E6-yOgAF">事务，嵌套事务，Save Point，Rollback To Saved Point</li><li data-pid="0rXULdd9">Context、预编译模式、DryRun 模式</li><li data-pid="X3e4nuOn">批量插入，FindInBatches，Find/Create with Map，使用 SQL 表达式、Context Valuer 进行 CRUD</li><li data-pid="izio2oEH">SQL 构建器，Upsert，数据库锁，Optimizer/Index/Comment Hint，命名参数，子查询</li><li data-pid="G_rlwFQm">复合主键，索引，约束</li><li data-pid="bQpATlre">Auto Migration</li><li data-pid="V_V4B-IS">自定义 Logger</li><li data-pid="VraakrvM">灵活的可扩展插件 API：Database Resolver（多数据库，读写分离）、Prometheus…</li><li data-pid="wVdaqE8K">每个特性都经过了测试的重重考验</li><li data-pid="ipKNj97h">开发者友好</li></ul><h3>驱动方式链接</h3><p data-pid="hxc7HEAK"><b>GORM 是通过驱动的方式来链接数据库的，目前支持 Mysql、SQLSever、PostgreSQL、SQLite。如果需要链接其他类型的数据库，可以 复用/自行 开发驱动。</b></p><ul><li data-pid="GTfv7PzY">驱动，是指软件驱动程序。是一种中间件，它能够将应用程序与硬件或其他系统之间的信息进行转换。在数据库领域中，驱动程序就是一种软件，它能够将应用程序与数据库之间的信息进行转换。</li><li data-pid="bBwMlzCd">驱动程序通常提供一组标准的数据库连接接口。这些接口包括连接数据库、执行 SQL 语句、获取结果集等。应用程序可以使用这些接口与数据库进行交互。</li></ul><p data-pid="A1CLM5q6">在 GORM 中，驱动程序是将 Go 语言与数据库之间的信息进行转换的软件。 GORM 库使用驱动程序来连接数据库，并使用驱动程序提供的接口来进行数据库操作。这样，GORM 库就不用关心数据库是哪种数据库，只要有驱动程序就可以连接数据库。</p><p data-pid="uvpb8cT2">驱动是一种软件，它能够将 Go 语言与数据库之间的信息进行转换。驱动通过一组标准的数据库连接接口来提供连接数据库的功能。</p><p data-pid="MIdH3ze1">GORM 的设计原则是对数据库访问进行封装，而不是对 SQL 语句进行封装。这样可以让开发人员专注于业务逻辑，而不用关心数据库的细节。</p><p data-pid="uYvCTfPv"><b>以驱动的方式链接数据库的好处是：</b></p><ul><li data-pid="iQ-Rj9wg">使用驱动可以支持多种数据库，而不用对 GORM 进行修改。</li><li data-pid="lO1pA8Yq">使用驱动可以更好地支持数据库的新特性。</li><li data-pid="FSRgWf-e">使用驱动可以更好地进行数据库性能优化。</li></ul><h3>DSN</h3><p data-pid="Lkv_Ksiw">[[DSN]] 是 Data Source Name 的缩写，是一种数据库连接字符串，它提供了连接数据库所需的所有信息。</p><p data-pid="W9auVztN">DSN 的格式通常包括数据库类型、数据库名称、用户名、密码和连接地址等信息。</p><p data-pid="kWAcPXsC">例如对于 <a href="https://github.com/go-sql-driver/mysql" target="_blank">mysql 数据库</a>来说，DSN 格式如下:</p><div class="highlight"><pre><code class="language-go"><span class="nx">user</span><span class="p">:</span><span class="nx">password</span><span class="err">@</span><span class="nf">tcp</span><span class="p">(</span><span class="nx">host</span><span class="p">:</span><span class="nx">port</span><span class="p">)</span><span class="o">/</span><span class="nx">dbname</span>
</code></pre></div><p data-pid="lA-5bRue">其中:</p><ul><li data-pid="KSXohvw6"><code>user</code>: 数据库用户名</li><li data-pid="T4rsu0QC"><code>password</code>: 数据库密码</li><li data-pid="MbmRVi3c"><code>host</code>: 数据库地址</li><li data-pid="UXGuUNX5"><code>port</code>: 数据库端口</li><li data-pid="6EVfMcci"><code>dbname</code>: 数据库名称</li></ul><p data-pid="21o-hA6q">DSN 字符串的格式可能因数据库类型而异。</p><p data-pid="yR77Fi-O">使用DSN字符串连接数据库是一种常用的方式，因为它简化了连接数据库的过程，并且使用DSN字符串连接的数据库驱动程序通常支持多种数据库类型，这样就不用写多个连接数据库的函数了。</p><h3>安装和简单实用</h3><p data-pid="N-a9wg4j"><b>GORM安装</b>：</p><div class="highlight"><pre><code class="language-powershell"><span class="n">go</span> <span class="n">get</span> <span class="n">-u</span> <span class="n">gorm</span><span class="p">.</span><span class="n">io</span><span class="p">/</span><span class="n">gorm</span>
<span class="n">go</span> <span class="n">get</span> <span class="n">-u</span> <span class="n">gorm</span><span class="p">.</span><span class="n">io</span><span class="p">/</span><span class="n">driver</span><span class="p">/</span><span class="n">sqlite</span></code></pre></div><p data-pid="iZRo0Zvq"><b>Quick Start</b>：</p><div class="highlight"><pre><code class="language-go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
  <span class="s">"gorm.io/gorm"</span>
  <span class="s">"gorm.io/driver/sqlite"</span>
<span class="p">)</span>

<span class="c1">// 创建数据模型
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Product</span> <span class="kd">struct</span> <span class="p">{</span>
  <span class="nx">gorm</span><span class="p">.</span><span class="nx">Model</span>
  <span class="nx">Code</span>  <span class="kt">string</span>
  <span class="nx">Price</span> <span class="kt">uint</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="nx">db</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">gorm</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="nx">sqlite</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="s">"test.db"</span><span class="p">),</span> <span class="o">&amp;</span><span class="nx">gorm</span><span class="p">.</span><span class="nx">Config</span><span class="p">{})</span>
  <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nb">panic</span><span class="p">(</span><span class="s">"failed to connect database"</span><span class="p">)</span>
  <span class="p">}</span>

  <span class="c1">// 迁移 schema
</span><span class="c1"></span>  <span class="nx">db</span><span class="p">.</span><span class="nf">AutoMigrate</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">Product</span><span class="p">{})</span>

  <span class="c1">// Create
</span><span class="c1"></span>  <span class="nx">db</span><span class="p">.</span><span class="nf">Create</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">Product</span><span class="p">{</span><span class="nx">Code</span><span class="p">:</span> <span class="s">"D42"</span><span class="p">,</span> <span class="nx">Price</span><span class="p">:</span> <span class="mi">100</span><span class="p">})</span>

  <span class="c1">// Read
</span><span class="c1"></span>  <span class="kd">var</span> <span class="nx">product</span> <span class="nx">Product</span>
  <span class="nx">db</span><span class="p">.</span><span class="nf">First</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">product</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// 根据整型主键查找
</span><span class="c1"></span>  <span class="nx">db</span><span class="p">.</span><span class="nf">First</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">product</span><span class="p">,</span> <span class="s">"code = ?"</span><span class="p">,</span> <span class="s">"D42"</span><span class="p">)</span> <span class="c1">// 查找 code 字段值为 D42 的记录
</span><span class="c1"></span>
  <span class="c1">// Update - 将 product 的 price 更新为 200
</span><span class="c1"></span>  <span class="nx">db</span><span class="p">.</span><span class="nf">Model</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">product</span><span class="p">).</span><span class="nf">Update</span><span class="p">(</span><span class="s">"Price"</span><span class="p">,</span> <span class="mi">200</span><span class="p">)</span>
  <span class="c1">// Update - 更新多个字段
</span><span class="c1"></span>  <span class="nx">db</span><span class="p">.</span><span class="nf">Model</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">product</span><span class="p">).</span><span class="nf">Updates</span><span class="p">(</span><span class="nx">Product</span><span class="p">{</span><span class="nx">Price</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span> <span class="nx">Code</span><span class="p">:</span> <span class="s">"F42"</span><span class="p">})</span> <span class="c1">// 仅更新非零值字段
</span><span class="c1"></span>  <span class="nx">db</span><span class="p">.</span><span class="nf">Model</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">product</span><span class="p">).</span><span class="nf">Updates</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}{</span><span class="s">"Price"</span><span class="p">:</span> <span class="mi">200</span><span class="p">,</span> <span class="s">"Code"</span><span class="p">:</span> <span class="s">"F42"</span><span class="p">})</span>

  <span class="c1">// Delete - 删除 product
</span><span class="c1"></span>  <span class="nx">db</span><span class="p">.</span><span class="nf">Delete</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">product</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p data-pid="eAj9ObZ1"><b>Mysql 的 简单的一个案例如下：</b></p><div class="highlight"><pre><code class="language-go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">"fmt"</span>

    <span class="s">"github.com/jinzhu/gorm"</span>
    <span class="nx">_</span> <span class="s">"github.com/jinzhu/gorm/dialects/mysql"</span>
<span class="p">)</span>

<span class="c1">// 定义数据模型
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Product</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">ID</span>    <span class="kt">uint</span>   <span class="s">`gorm:"primary_key"`</span>
    <span class="nx">Name</span>  <span class="kt">string</span> <span class="s">`gorm:"size:255"`</span>
    <span class="nx">Price</span> <span class="kt">uint</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="c1">// 建立数据库连接
</span><span class="c1"></span>    <span class="nx">db</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">gorm</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="s">"mysql"</span><span class="p">,</span> <span class="s">"root:password@/dbname?charset=utf8&amp;parseTime=True&amp;loc=Local"</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nb">panic</span><span class="p">(</span><span class="s">"连接数据库失败"</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">defer</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

    <span class="c1">// 自动迁移数据库结构
</span><span class="c1"></span>    <span class="nx">db</span><span class="p">.</span><span class="nf">AutoMigrate</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">Product</span><span class="p">{})</span>

    <span class="c1">// 创建一条数据
</span><span class="c1"></span>    <span class="nx">db</span><span class="p">.</span><span class="nf">Create</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">Product</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="s">"面包"</span><span class="p">,</span> <span class="nx">Price</span><span class="p">:</span> <span class="mi">3</span><span class="p">})</span>

    <span class="c1">// 查询所有数据
</span><span class="c1"></span>    <span class="kd">var</span> <span class="nx">products</span> <span class="p">[]</span><span class="nx">Product</span>
    <span class="nx">db</span><span class="p">.</span><span class="nf">Find</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">products</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">"所有产品："</span><span class="p">,</span> <span class="nx">products</span><span class="p">)</span>

    <span class="c1">// 更新一条数据
</span><span class="c1"></span>    <span class="nx">db</span><span class="p">.</span><span class="nf">Model</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">Product</span><span class="p">{}).</span><span class="nf">Where</span><span class="p">(</span><span class="s">"name = ?"</span><span class="p">,</span> <span class="s">"面包"</span><span class="p">).</span><span class="nf">Update</span><span class="p">(</span><span class="s">"price"</span><span class="p">,</span> <span class="mi">4</span><span class="p">)</span>

    <span class="c1">// 删除一条数据
</span><span class="c1"></span>    <span class="nx">db</span><span class="p">.</span><span class="nf">Where</span><span class="p">(</span><span class="s">"name = ?"</span><span class="p">,</span> <span class="s">"面包"</span><span class="p">).</span><span class="nf">Delete</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">Product</span><span class="p">{})</span>
<span class="p">}</span>
</code></pre></div><blockquote data-pid="lTWyImAN">   对上面的解释：<br> </blockquote><ol><li data-pid="_sZ6IbLD">在 main 函数中，我们通过调用 gorm.Open("mysql", "root:password@/dbname?charset=utf8&amp;parseTime=True&amp;loc=Local") 来建立数据库连接。</li><li data-pid="5AQuOVSI">我们使用 db.AutoMigrate(&amp;Product{}) 来自动迁移数据库结构，即自动根据 Product 结构体创建数据表。</li><li data-pid="yeK3kL30">我们使用 db.Create(&amp;Product{Name: "面包", Price: 3}) 来创建一条数据。</li><li data-pid="D0T69F4d">使用 db.Find(&amp;products) 来查询所有数据并将其存入 products 变量中。</li><li data-pid="inYHEH8f">我们使用 db.Model(&amp;Product{}).Where("name = ?", "面包").Update("price", 4) 来更新名称为 "面包" 的产品的价格。</li><li data-pid="HiXY1ASs">我们使用 db.Where("name = ?", "面包").Delete(&amp;Product{}) 来删除名称为 "面包" 的产品。</li><li data-pid="tDJCQxww">最后，通过 defer db.Close() 关闭数据库连接。</li></ol><p class="ztext-empty-paragraph"><br></p><p data-pid="SfYEq7L2">更细节的操作可以参考：<a href="https://gorm.io/zh_CN/docs/index.html" target="_blank">GORM 指南 | GORM - The fantastic ORM library for Golang, aims to be developer friendly</a>.</p><p data-pid="UVVh9X7s">可以使用gorm.Open()函数打开数据库连接。 例如：</p><div class="highlight"><pre><code class="language-go"><span class="nx">db</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">gorm</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="s">"mysql"</span><span class="p">,</span> <span class="s">"user:password@/dbname?charset=utf8&amp;parseTime=True&amp;loc=Local"</span><span class="p">)</span>
</code></pre></div><p data-pid="gzDA2LO8">这里是一些基本的GORM用法，尝试使用它来 <b>创建、读取、更新和删除</b> 数据库记录。</p><div class="highlight"><pre><code class="language-go"><span class="c1">// create
</span><span class="c1"></span><span class="nx">db</span><span class="p">.</span><span class="nf">Create</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">Product</span><span class="p">{</span><span class="nx">Code</span><span class="p">:</span> <span class="s">"L1212"</span><span class="p">,</span> <span class="nx">Price</span><span class="p">:</span> <span class="mi">1000</span><span class="p">})</span>

<span class="c1">// read
</span><span class="c1"></span><span class="kd">var</span> <span class="nx">product</span> <span class="nx">Product</span>
<span class="nx">db</span><span class="p">.</span><span class="nf">First</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">product</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// find product with id 1
</span><span class="c1"></span>
<span class="c1">// update
</span><span class="c1"></span><span class="nx">db</span><span class="p">.</span><span class="nf">Model</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">product</span><span class="p">).</span><span class="nf">Update</span><span class="p">(</span><span class="s">"Price"</span><span class="p">,</span> <span class="mi">2000</span><span class="p">)</span>

<span class="c1">// delete
</span><span class="c1"></span><span class="nx">db</span><span class="p">.</span><span class="nf">Delete</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">product</span><span class="p">)</span>
</code></pre></div><h3>解决数据冲突</h3><p data-pid="aZpWr4P1">在 GORM 中，使用 OnConflict 方法可以解决数据冲突问题。这个方法可以让你指定在冲突时应该采取的操作。</p><p data-pid="Q-ZxHopZ">一般来说，在执行插入操作时可能会因为主键重复而导致数据冲突。使用 OnConflict 方法可以解决这个问题。</p><p data-pid="eqXnrvB8"> 简单的一个案例如下：</p><div class="highlight"><pre><code class="language-go"><span class="nx">db</span><span class="p">.</span><span class="nf">Save</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">Product</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="s">"面包"</span><span class="p">,</span> <span class="nx">Price</span><span class="p">:</span> <span class="mi">3</span><span class="p">}).</span><span class="nf">OnConflict</span><span class="p">(</span><span class="s">"(name) DO UPDATE SET price = excluded.price"</span><span class="p">)</span>
</code></pre></div><p data-pid="cUITE7b4">这行代码表示 <b>如果 name 列重复时，将执行更新操作来更新 price 列。</b></p><p data-pid="9GqGDOHv">还可以使用 <code>OnConflict("(name) DO NOTHING")</code> 来让重复的数据不做任何操作。</p><p data-pid="JorcJJFQ">OnConflict 方法非常有用，因为它可以帮助你解决数据冲突问题，并让你更好地控制你的数据库。</p><h3>使用默认值</h3><p data-pid="x_25MGzL">GORM 支持在数据库中设置默认值。这可以通过在结构体中使用 "default" 标签来实现。</p><div class="highlight"><pre><code class="language-go"><span class="kd">type</span> <span class="nx">Product</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">gorm</span><span class="p">.</span><span class="nx">Model</span>
    <span class="nx">Name</span>  <span class="kt">string</span>
    <span class="nx">Price</span> <span class="kt">int</span> <span class="s">`gorm:"default:0"`</span>
<span class="p">}</span>
</code></pre></div><p data-pid="aoskBdwZ">这样的话，在创建或更新数据时，如果没有指定 Price 列的值，那么会自动将其设置为 0。</p><p data-pid="pFSc5C8S">默认值还可以使用SQL表达式和函数来进行设置。</p><p data-pid="G38wcOn1">例如，如果你想让 <code>created_at</code> 列默认值为当前时间，你可以这样定义：</p><div class="highlight"><pre><code class="language-go"><span class="kd">type</span> <span class="nx">Product</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">gorm</span><span class="p">.</span><span class="nx">Model</span>
    <span class="nx">Name</span>  <span class="kt">string</span>
    <span class="nx">Price</span> <span class="kt">int</span> <span class="s">`gorm:"default:0"`</span>
    <span class="nx">CreatedAt</span>  <span class="nx">time</span><span class="p">.</span><span class="nx">Time</span> <span class="s">`gorm:"default:now()"`</span>
<span class="p">}</span>
</code></pre></div><p data-pid="8nwegkfx">设置默认值是非常有用的，它可以帮助你简化代码并减少错误。</p><h3>First 使用详细</h3><p data-pid="T2gQUtEC"><code>First</code> 是 GORM 中查询数据的一种方法，它可以返回第一条符合条件的数据。使用 <code>First</code> 方法时需要传递一个参数，这个参数可以是模型结构体的指针或接口。</p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic1.zhimg.com/v2-6f83ee313cf1b2cb8f0e4f82ec7c1c98_r.jpg" data-size="normal" width="2060" referrerpolicy="no-referrer"><figcaption>image-20230127160958022</figcaption></figure><p class="ztext-empty-paragraph"><br></p><p data-pid="e0H6HCqc">例如，如果你想查询第一条名称为 "Apple" 的产品数据，你可以这样写：</p><div class="highlight"><pre><code class="language-go"><span class="kd">var</span> <span class="nx">product</span> <span class="nx">Product</span>
<span class="nx">db</span><span class="p">.</span><span class="nf">First</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">product</span><span class="p">,</span> <span class="s">"name = ?"</span><span class="p">,</span> <span class="s">"Apple"</span><span class="p">)</span>
</code></pre></div><p data-pid="7LBW1qGo">这里的参数是一个模型结构体的指针，第二个参数是查询条件，第三个参数是条件的值。</p><p data-pid="R9uyQq0s"><b>也可以使用链式查询来实现这个操作</b>，如下：</p><div class="highlight"><pre><code class="language-go"><span class="kd">var</span> <span class="nx">product</span> <span class="nx">Product</span>
<span class="nx">db</span><span class="p">.</span><span class="nf">Where</span><span class="p">(</span><span class="s">"name = ?"</span><span class="p">,</span> <span class="s">"Apple"</span><span class="p">).</span><span class="nf">First</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">product</span><span class="p">)</span>
</code></pre></div><blockquote data-pid="GRz6zhvt"> ⚠️ <b>在链式调用的时候，需要注意~！</b></blockquote><p data-pid="m69VC-fX">使用时需要注意，如果查询不到符合条件的数据，<code>First</code> 方法将不会返回错误，而是返回一个空结构体。所以需要在使用时自己判断是否查询到数据。</p><div class="highlight"><pre><code class="language-go"><span class="kd">var</span> <span class="nx">product</span> <span class="nx">Product</span>
<span class="nx">err</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Where</span><span class="p">(</span><span class="s">"name = ?"</span><span class="p">,</span> <span class="s">"Apple"</span><span class="p">).</span><span class="nf">First</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">product</span><span class="p">).</span><span class="nx">Error</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p data-pid="W_c02UXJ">如果想要在查询不到数据时返回错误，可以使用 <code>FirstOrInit</code> 和 <code>FirstOrCreate</code> 方法，它们在查询不到数据时会返回错误。</p><p data-pid="LiHxm84h">在使用 First 方法时, 如果传入的结构体中有组合索引，但没有使用 Where 函数来限制组合索引的值会触发。</p><div class="highlight"><pre><code class="language-go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">"fmt"</span>
    <span class="s">"github.com/jinzhu/gorm"</span>
    <span class="nx">_</span> <span class="s">"github.com/jinzhu/gorm/dialects/mysql"</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">User</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">ID</span>   <span class="kt">int</span>
    <span class="nx">Name</span> <span class="kt">string</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">db</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">gorm</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="s">"mysql"</span><span class="p">,</span> <span class="s">"root:password@tcp(127.0.0.1:3306)/test?charset=utf8&amp;parseTime=True&amp;loc=Local"</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">defer</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

    <span class="c1">// 查询第一条ID为1的用户
</span><span class="c1"></span>    <span class="kd">var</span> <span class="nx">user</span> <span class="nx">User</span>
    <span class="nx">db</span><span class="p">.</span><span class="nf">First</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">user</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">user</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p data-pid="LczDoC30">这里我们使用了GORM的<code>First</code>方法来查询第一条ID为1的用户。需要注意的是，如果查询不到符合条件的记录，<code>First</code>方法会返回<code>ecordNotFound</code>错误。</p><p data-pid="0ZxXZfEK">使用时需要注意，如果传递的参数是结构体指针，gorm会将查询结果赋值到结构体上，而传递结构体则不会有赋值操作。</p><p data-pid="ugFE-Z1c">另外，在使用<code>First</code>方法查询时，如果没有符合条件的记录，返回的错误是<code>RecordNotFound</code>,需要在业务代码中特判这个错误。</p><h3>Find</h3><p data-pid="Z_NZQMw8"><code>Find</code> 方法用来查询符合条件的记录，并以切片的形式返回。</p><p data-pid="aXX0U0E9">下面是一个示例代码，假设有一个名为<code>users</code>的表，你需要查询所有年龄大于30岁的用户：</p><div class="highlight"><pre><code class="language-go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">"fmt"</span>
    <span class="s">"github.com/jinzhu/gorm"</span>
    <span class="nx">_</span> <span class="s">"github.com/jinzhu/gorm/dialects/mysql"</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">User</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">ID</span>       <span class="kt">int</span>
    <span class="nx">Name</span>     <span class="kt">string</span>
    <span class="nx">Age</span>      <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">db</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">gorm</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="s">"mysql"</span><span class="p">,</span> <span class="s">"root:password@/dbname?charset=utf8&amp;parseTime=True&amp;loc=Local"</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nb">panic</span><span class="p">(</span><span class="s">"failed to connect database"</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">defer</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

    <span class="kd">var</span> <span class="nx">users</span> <span class="p">[]</span><span class="nx">User</span>
    <span class="nx">db</span><span class="p">.</span><span class="nf">Where</span><span class="p">(</span><span class="s">"age &gt; ?"</span><span class="p">,</span> <span class="mi">30</span><span class="p">).</span><span class="nf">Find</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">users</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">users</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p data-pid="W40YculN">在上面的代码中，我们首先打开了一个数据库链接，然后定义了一个<code>User</code>结构体，用来存储查询到的用户信息。</p><p data-pid="mQCSc4Nm">接着我们使用<code>Where</code>方法限定查询条件，并调用<code>Find</code>方法查询数据。<code>Find</code>方法的第一个参数是一个结构体切片的指针，用来存储查询到的记录。</p><p data-pid="m0HBNiQm">最后我们打印出查询到的用户信息。</p><p data-pid="9CLpu5fw">⚠️ 注意：如果没有符合条件的记录，<code>Find</code>方法会返回一个空的切片。</p><h3>First 和 Find</h3><p data-pid="rPQLWYVS"><code>First</code>方法和<code>Find</code>方法都是用来查询记录的，但是它们的用法和返回结果有所不同。</p><p data-pid="r4VRKMB5"><code>First</code>方法会查询并返回第一条符合条件的记录。它的返回值是一个结构体，如果没有符合条件的记录，会返回<code>RecordNotFound</code>错误。</p><p data-pid="kOz14lSe"><code>Find</code>方法会查询所有符合条件的记录，并将它们以切片的形式返回。它的返回值是一个结构体切片，如果没有符合条件的记录，会返回一个空的切片。</p><p data-pid="Jx1jxJVR">举个例子，如果你要查询一个表中的第一条记录，可以使用<code>First</code>方法；如果你要查询一个表中所有符合条件的记录，可以使用<code>Find</code>方法。</p><p data-pid="qErbPL6m">总的来说，如果你只需要查询一条记录，使用<code>First</code>方法会更加高效，因为它只会查询一条记录；如果你需要查询多条记录，使用<code>Find</code>方法会更加方便。</p><h3>更新数据</h3><p data-pid="6XTcioud">Gorm 提供了 <code>Save</code> 、 <code>Updates</code> 和 <code>Update</code> 方法用来更新数据。</p><ul><li data-pid="_aIPxywh"><code>Save</code> 方法更新所有字段，如果没有主键或者自增字段会新增一条记录。</li><li data-pid="XC3y-L8E"><code>Updates</code> 方法用来更新指定字段。</li><li data-pid="fFKuyjPz"><code>Update</code> 方法用来更新指定字段并且指定更新条件。</li></ul><p data-pid="Lb7AZypj">下面是一个示例代码，假设有一个名为<code>users</code>的表，你需要更新id为1的用户的姓名为 "John Doe"</p><div class="highlight"><pre><code class="language-go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">"fmt"</span>
    <span class="s">"github.com/jinzhu/gorm"</span>
    <span class="nx">_</span> <span class="s">"github.com/jinzhu/gorm/dialects/mysql"</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">User</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">ID</span>       <span class="kt">int</span>
    <span class="nx">Name</span>     <span class="kt">string</span>
    <span class="nx">Age</span>      <span class="kt">int</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">db</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">gorm</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="s">"mysql"</span><span class="p">,</span> <span class="s">"root:password@/dbname?charset=utf8&amp;parseTime=True&amp;loc=Local"</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nb">panic</span><span class="p">(</span><span class="s">"failed to connect database"</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">defer</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

    <span class="kd">var</span> <span class="nx">user</span> <span class="nx">User</span>
    <span class="nx">db</span><span class="p">.</span><span class="nf">First</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">user</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span> <span class="c1">// find user with id 1
</span><span class="c1"></span>    <span class="nx">user</span><span class="p">.</span><span class="nx">Name</span> <span class="p">=</span> <span class="s">"John Doe"</span>
    <span class="nx">db</span><span class="p">.</span><span class="nf">Save</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">user</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">user</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p data-pid="dzZdkgVJ">在上面的代码中，我们首先打开了一个数据库链接，然后定义了一个<code>User</code>结构体，用来存储查询到的用户信息。</p><p data-pid="tAjBER8i">接着我们使用<code>First</code>方法查询id 为1的用户，并更新用户的姓名。</p><p data-pid="CIQjxfy8">最后我们使用<code>Save</code>方法更新数据。</p><p data-pid="ePyuDZHQ">如果只需要更新一些字段，可以使用 <code>Updates</code> 方法,例如:</p><div class="highlight"><pre><code class="language-go"><span class="nx">db</span><span class="p">.</span><span class="nf">Model</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">user</span><span class="p">).</span><span class="nf">Updates</span><span class="p">(</span><span class="kd">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kd">interface</span><span class="p">{}{</span><span class="s">"name"</span><span class="p">:</span> <span class="s">"John Doe"</span><span class="p">,</span> <span class="s">"age"</span><span class="p">:</span> <span class="mi">25</span><span class="p">})</span>
</code></pre></div><p data-pid="yaZqF9YA"><b>Gorm 更新数据有两种方式：</b></p><ol><li data-pid="X5ULCGAr">使用 Update 方法：</li></ol><div class="highlight"><pre><code class="language-go"><span class="nx">db</span><span class="p">.</span><span class="nf">Model</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">user</span><span class="p">).</span><span class="nf">Update</span><span class="p">(</span><span class="s">"name"</span><span class="p">,</span> <span class="s">"new_name"</span><span class="p">)</span>
</code></pre></div><p data-pid="kqJG7i-w">这种方式可以对指定字段进行更新，而不会影响其他字段的值。</p><ol><li data-pid="Re8cYE7G">使用 Save 方法：</li></ol><div class="highlight"><pre><code class="language-go"><span class="nx">user</span><span class="p">.</span><span class="nx">Name</span> <span class="p">=</span> <span class="s">"new_name"</span>
<span class="nx">db</span><span class="p">.</span><span class="nf">Save</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">user</span><span class="p">)</span>
</code></pre></div><p data-pid="qh6ds8De">这种方式会更新整个结构体。</p><p data-pid="s7_hDmpV">在使用这些方法之前，需要确保记录已经在数据库中存在。如果需要在更新之前判断记录是否存在，可以使用 <code>FirstOrCreate</code> 方法。</p><p data-pid="nVea8Mbg">注意，在使用 Save 方法时，如果结构体中有没有被赋值的字段，那么这些字段可能会被赋上空值，所以需要特别小心。</p><p data-pid="GrTOE0nY">顺便提一下，在更新数据时，Gorm 会自动跟踪更新时间，如果更新时间字段名为 <code>updated_at</code>，则自动更新，如果需要自定义字段名，需要手动设置。</p><h3>删除</h3><p data-pid="8YOEc-BV">Gorm 提供了 Delete 方法来删除数据。</p><p data-pid="qwG8shND">使用 Delete 方法可以删除一条记录，方法的参数是要删除的记录的指针。</p><div class="highlight"><pre><code class="language-go"><span class="nx">db</span><span class="p">.</span><span class="nf">Delete</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">user</span><span class="p">)</span>
</code></pre></div><p data-pid="GAz5Q-b-">这个方法会将这条记录从数据库中删除，删除之后该记录就不再是有效的。</p><p data-pid="d9T4-3A2">如果要删除多条记录，可以使用 Where 方法限制删除范围。</p><div class="highlight"><pre><code class="language-go"><span class="nx">db</span><span class="p">.</span><span class="nf">Where</span><span class="p">(</span><span class="s">"age &gt; ?"</span><span class="p">,</span> <span class="mi">20</span><span class="p">).</span><span class="nf">Delete</span><span class="p">(</span><span class="nx">User</span><span class="p">{})</span>
</code></pre></div><p data-pid="bg8ENS8s">这个方法会删除年龄大于20岁的所有用户。</p><p data-pid="Is1Ad-Ky">注意，在删除数据时，Gorm 不会自动跟踪删除时间，如果需要记录删除时间，需要手动设置。</p><h3>物理删除和软删除</h3><p data-pid="HU33q3xm">物理删除和软删除是 Gorm 提供的两种不同的删除方式。</p><ol><li data-pid="XZDHgNeH"><b>物理删除就是直接从数据库中删除记录</b>，不管有没有其他业务逻辑的依赖，这种方式删除的数据不可恢复，需要谨慎使用。</li><li data-pid="AwyaUAON">软删除是通过在数据表中添加一个删除标记来标记记录被删除，这种方式删除的数据可以恢复，适用于不需要永久删除数据的场景。</li></ol><p data-pid="aFRt96aM">Gorm 提供了一些辅助方法来支持软删除，比如 DeletedAt 字段，在使用 Delete 方法删除数据时会自动设置这个字段，可以通过 Unscoped 方法来忽略这个字段来进行物理删除。</p><p data-pid="XQYhgRTj"><b>Gorm默认不支持软删除，需要手动支持。Gorm 提供了 gorm.DeletedAt 用于帮助用户实现软删除</b></p><div class="highlight"><pre><code class="language-go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">"fmt"</span>
    <span class="s">"time"</span>

    <span class="s">"github.com/jinzhu/gorm"</span>
    <span class="nx">_</span> <span class="s">"github.com/jinzhu/gorm/dialects/sqlite"</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">User</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">ID</span>        <span class="kt">uint</span> <span class="s">`gorm:"primary_key"`</span>
    <span class="nx">Name</span>      <span class="kt">string</span>
    <span class="nx">Age</span>       <span class="kt">uint</span>
    <span class="nx">DeletedAt</span> <span class="o">*</span><span class="nx">time</span><span class="p">.</span><span class="nx">Time</span> <span class="s">`sql:"index"`</span> <span class="c1">// 定义软删除字段
</span><span class="c1"></span><span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">db</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">gorm</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="s">"sqlite3"</span><span class="p">,</span> <span class="s">"test.db"</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
        <span class="k">return</span>
    <span class="p">}</span>
    <span class="k">defer</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

    <span class="c1">// 开启软删除
</span><span class="c1"></span>    <span class="nx">db</span><span class="p">.</span><span class="nf">AutoMigrate</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">User</span><span class="p">{}).</span><span class="nf">Delete</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">User</span><span class="p">{},</span> <span class="s">"deleted_at is not null"</span><span class="p">)</span>
    <span class="nx">db</span><span class="p">.</span><span class="nf">Callback</span><span class="p">().</span><span class="nf">Delete</span><span class="p">().</span><span class="nf">Add</span><span class="p">(</span><span class="s">"gorm:delete"</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">scope</span> <span class="o">*</span><span class="nx">gorm</span><span class="p">.</span><span class="nx">Scope</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">!</span><span class="nx">scope</span><span class="p">.</span><span class="nf">HasError</span><span class="p">()</span> <span class="p">{</span>
            <span class="kd">var</span> <span class="nx">extraOption</span> <span class="kt">string</span>
            <span class="k">if</span> <span class="nx">str</span><span class="p">,</span> <span class="nx">ok</span> <span class="o">:=</span> <span class="nx">scope</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">"gorm:delete_option"</span><span class="p">);</span> <span class="nx">ok</span> <span class="p">{</span>
                <span class="nx">extraOption</span> <span class="p">=</span> <span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprint</span><span class="p">(</span><span class="nx">str</span><span class="p">)</span>
            <span class="p">}</span>

            <span class="nx">deletedOnField</span><span class="p">,</span> <span class="nx">hasDeletedOnField</span> <span class="o">:=</span> <span class="nx">scope</span><span class="p">.</span><span class="nf">FieldByName</span><span class="p">(</span><span class="s">"DeletedAt"</span><span class="p">)</span>

            <span class="k">if</span> <span class="p">!</span><span class="nx">scope</span><span class="p">.</span><span class="nx">Search</span><span class="p">.</span><span class="nx">Unscoped</span> <span class="o">&amp;&amp;</span> <span class="nx">hasDeletedOnField</span> <span class="p">{</span>
                <span class="nx">scope</span><span class="p">.</span><span class="nf">Raw</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span>
                    <span class="s">"UPDATE %v SET %v=%v%v%v"</span><span class="p">,</span>
                    <span class="nx">scope</span><span class="p">.</span><span class="nf">QuotedTableName</span><span class="p">(),</span>
                    <span class="nx">scope</span><span class="p">.</span><span class="nf">Quote</span><span class="p">(</span><span class="nx">deletedOnField</span><span class="p">.</span><span class="nx">DBName</span><span class="p">),</span>
                    <span class="nx">scope</span><span class="p">.</span><span class="nf">AddToVars</span><span class="p">(</span><span class="nx">time</span><span class="p">.</span><span class="nf">Now</span><span class="p">()),</span>
                    <span class="nf">addExtraSpaceIfExist</span><span class="p">(</span><span class="nx">scope</span><span class="p">.</span><span class="nf">CombinedConditionSql</span><span class="p">()),</span>
                    <span class="nf">addExtraSpaceIfExist</span><span class="p">(</span><span class="nx">extraOption</span><span class="p">),</span>
                <span class="p">)).</span><span class="nf">Exec</span><span class="p">()</span>
            <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
                <span class="nx">scope</span><span class="p">.</span><span class="nf">Raw</span><span class="p">(</span><span class="nx">fmt</span><span class="p">.</span><span class="nf">Sprintf</span><span class="p">(</span>
                    <span class="s">"DELETE FROM %v%v%v"</span><span class="p">,</span>
                    <span class="nx">scope</span><span class="p">.</span><span class="nf">QuotedTableName</span><span class="p">(),</span>
                    <span class="nf">addExtraSpaceIfExist</span><span class="p">(</span><span class="nx">scope</span><span class="p">.</span><span class="nf">CombinedConditionSql</span><span class="p">()),</span>
                    <span class="nf">addExtraSpaceIfExist</span><span class="p">(</span><span class="nx">extraOption</span><span class="p">),</span>
                <span class="p">)).</span><span class="nf">Exec</span><span class="p">()</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">})</span>

    <span class="c1">// 创建用户
</span><span class="c1"></span>    <span class="nx">user</span> <span class="o">:=</span> <span class="nx">User</span><span class="p">{</span><span class="nx">Name</span><span class="p">:</span> <span class="s">"John"</span><span class="p">,</span> <span class="nx">Age</span><span class="p">:</span> <span class="mi">20</span><span class="p">}</span>
    <span class="nx">db</span><span class="p">.</span><span class="nf">Create</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">user</span><span class="p">)</span>

    <span class="c1">// 软删除用户
</span><span class="c1"></span>    <span class="nx">db</span><span class="p">.</span><span class="nf">Delete</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">user</span><span class="p">)</span>

    <span class="c1">// 查询已被软删除的用户
</span><span class="c1"></span>    <span class="kd">var</span> <span class="nx">deletedUser</span> <span class="nx">User</span>
    <span class="nx">db</span><span class="p">.</span><span class="nf">Unscoped</span><span class="p">().</span><span class="nf">First</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">deletedUser</span><span class="p">,</span> <span class="s">"name = ?"</span><span class="p">,</span> <span class="s">"John"</span><span class="p">)</span>
    <span class="nx">fmt</span><span class="p">.</span><span class="nf">Printf</span><span class="p">(</span><span class="s">"Deleted user: %+v\n"</span><span class="p">,</span> <span class="nx">deletedUser</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h3>事务</h3><p data-pid="t7Uctf9N">Gorm支持多种方式来管理数据库的事务。一种常用的方式是使用<code>db.Begin()</code>来开启一个事务，然后使用<code>tx.Commit()</code>或<code>tx.Rollback()</code>来结束事务。</p><p data-pid="hbuzveZE">在GORM中，事务是通过DB对象的<code>Begin()</code>方法来开始一个事务，该方法返回一个<code>TX</code>对象。然后你可以在TX对象上执行数据库操作，最后调用<code>Commit()</code>或<code>Rollback()</code>来结束事务。</p><div class="highlight"><pre><code class="language-go"><span class="nx">tx</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Begin</span><span class="p">()</span>
<span class="c1">// 注意在后面从这里开始，你应该使用 `tx` 而不是 `db`
</span><span class="c1"></span><span class="k">defer</span> <span class="kd">func</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">if</span> <span class="nx">r</span> <span class="o">:=</span> <span class="nb">recover</span><span class="p">();</span> <span class="nx">r</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nx">tx</span><span class="p">.</span><span class="nf">Rollback</span><span class="p">()</span>
    <span class="p">}</span>
<span class="p">}()</span>
<span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tx</span><span class="p">.</span><span class="nx">Error</span><span class="p">;</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>

<span class="c1">// 执行数据库操作
</span><span class="c1"></span><span class="k">if</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">tx</span><span class="p">.</span><span class="nf">Commit</span><span class="p">().</span><span class="nx">Error</span><span class="p">;</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
    <span class="nb">panic</span><span class="p">(</span><span class="nx">err</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p data-pid="DK0_3txP">或者 使用 <code>db.Transaction(func(tx *gorm.DB) error{})</code> 来进行事务操作</p><p data-pid="wqj4lFkB">如果你需要在一组数据库操作之间开始和结束事务，可以使用<code>db.Transaction(func(tx *gorm.DB) error{})</code> 来进行事务操作</p><p data-pid="y5BaSHhO"><code>tansaction</code> 方法用于自动提交事务，避免用户漏写 Commit、Rollbcak</p><div class="highlight"><pre><code class="language-go"><span class="nx">err</span> <span class="o">:=</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Transaction</span><span class="p">(</span><span class="kd">func</span><span class="p">(</span><span class="nx">tx</span> <span class="o">*</span><span class="nx">gorm</span><span class="p">.</span><span class="nx">DB</span><span class="p">)</span> <span class="kt">error</span> <span class="p">{</span>
    <span class="c1">// 执行数据库操作
</span><span class="c1"></span>    <span class="k">return</span> <span class="kc">nil</span>
<span class="p">})</span>
</code></pre></div><p data-pid="_zqZ6mVr">注意：如果返回值为nil，事务会提交，如果返回值非nil，事务会回滚。</p><h3>GORM Hook</h3><p data-pid="nqc1Annh">GORM Hook是GORM中的一种事件钩子机制，它允许在对数据库进行操作时，在特定的时间点执行额外的代码。</p><p data-pid="vOhPKY4X">GORM Hook提供了多种事件类型，如创建、更新、查询和删除等。</p><p data-pid="cEZK4Aoi">可以使用<code>db.Callback()</code>来定义Hook，如下所示：</p><div class="highlight"><pre><code class="language-go"><span class="kn">package</span> <span class="nx">main</span>

<span class="kn">import</span> <span class="p">(</span>
    <span class="s">"fmt"</span>
    <span class="s">"github.com/jinzhu/gorm"</span>
    <span class="nx">_</span> <span class="s">"github.com/jinzhu/gorm/dialects/sqlite"</span>
<span class="p">)</span>

<span class="kd">type</span> <span class="nx">Product</span> <span class="kd">struct</span> <span class="p">{</span>
    <span class="nx">gorm</span><span class="p">.</span><span class="nx">Model</span>
    <span class="nx">Code</span>  <span class="kt">string</span>
    <span class="nx">Price</span> <span class="kt">uint</span>
<span class="p">}</span>

<span class="kd">func</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="nx">db</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">gorm</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="s">"sqlite3"</span><span class="p">,</span> <span class="s">"test.db"</span><span class="p">)</span>
    <span class="k">if</span> <span class="nx">err</span> <span class="o">!=</span> <span class="kc">nil</span> <span class="p">{</span>
        <span class="nb">panic</span><span class="p">(</span><span class="s">"failed to connect database"</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">defer</span> <span class="nx">db</span><span class="p">.</span><span class="nf">Close</span><span class="p">()</span>

    <span class="nx">db</span><span class="p">.</span><span class="nf">AutoMigrate</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">Product</span><span class="p">{})</span>
    <span class="c1">// 定义钩子
</span><span class="c1"></span>    <span class="nx">db</span><span class="p">.</span><span class="nf">Callback</span><span class="p">().</span><span class="nf">Create</span><span class="p">().</span><span class="nf">Before</span><span class="p">(</span><span class="s">"gorm:begin_transaction"</span><span class="p">).</span>
        <span class="nf">Register</span><span class="p">(</span><span class="s">"gorm:before_create"</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">scope</span> <span class="o">*</span><span class="nx">gorm</span><span class="p">.</span><span class="nx">Scope</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">"在创建之前执行的代码"</span><span class="p">)</span>
        <span class="p">})</span>
    <span class="nx">db</span><span class="p">.</span><span class="nf">Callback</span><span class="p">().</span><span class="nf">Create</span><span class="p">().</span><span class="nf">After</span><span class="p">(</span><span class="s">"gorm:commit_or_rollback_transaction"</span><span class="p">).</span>
        <span class="nf">Register</span><span class="p">(</span><span class="s">"gorm:after_create"</span><span class="p">,</span> <span class="kd">func</span><span class="p">(</span><span class="nx">scope</span> <span class="o">*</span><span class="nx">gorm</span><span class="p">.</span><span class="nx">Scope</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">fmt</span><span class="p">.</span><span class="nf">Println</span><span class="p">(</span><span class="s">"在创建之后执行的代码"</span><span class="p">)</span>
        <span class="p">})</span>
    <span class="c1">// 创建一个Product实例并保存
</span><span class="c1"></span>    <span class="nx">db</span><span class="p">.</span><span class="nf">Create</span><span class="p">(</span><span class="o">&amp;</span><span class="nx">Product</span><span class="p">{</span><span class="nx">Code</span><span class="p">:</span> <span class="s">"L1212"</span><span class="p">,</span> <span class="nx">Price</span><span class="p">:</span> <span class="mi">1000</span><span class="p">})</span>
<span class="p">}</span>
</code></pre></div><p data-pid="jPqHoKKa">上面这个例子，当数据库创建操作时会触发<code>gorm:before_create</code>事件，并执行函数中的代码</p><p data-pid="aMkifuS9">可以使用如下的事件类型：</p><ul><li data-pid="-_uBDtij"><code>Before/After("gorm:create")</code></li><li data-pid="uhifPWnY"><code>Before/After("gorm:query")</code></li><li data-pid="6lp9hVBh"><code>Before/After("gorm:update")</code></li><li data-pid="FOSTEa3W"><code>Before/After("gorm:delete")</code></li></ul><p data-pid="JqzZqE_Y">通过这些事件类型，可以在对数据库进行操作时，对数据进行预处理或后处理，也可以在数据库操作失败时进行错误处理。</p><h3>Gorm 性能提高</h3><p data-pid="C_g5r5yE">GORM是一个ORM库，它会在运行时执行很多操作，因此其运行性能可能不如直接使用原生SQL。但是，还是有一些方法可以提高GORM的性能。</p><ol><li data-pid="lnAJaLiq">使用缓存: GORM支持对数据库的缓存，如果你的应用程序需要频繁读取数据库中的同一数据，可以考虑使用缓存来提高性能。</li><li data-pid="CgbvTfS6">尽量减少查询次数: GORM在查询数据库时会执行很多操作，如果你可以通过减少查询次数来提高性能，就应该尽量这样做。</li><li data-pid="mpbJHLay">尽量减少使用高级功能: GORM支持很多高级功能，如果你不需要这些功能，可以考虑不使用它们，以提高性能。</li><li data-pid="iGC9jscw">尽量使用批量操作: GORM支持对多个对象批量进行操作，如果你需要对多个对象进行相同的操作，可以考虑使用批量操作来提高性能。</li><li data-pid="ePiZivdu">数据库连接池: GORM默认使用数据库连接池来管理数据库连接，但是默认的连接池大小可能不够，可以通过调整连接池大小来提高性能。</li></ol><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic3.zhimg.com/v2-7b56f4de7c652ecfa0c2ec8b714ee926_r.jpg" data-size="normal" width="2060" referrerpolicy="no-referrer"><figcaption>image-20230127170840505</figcaption></figure><p class="ztext-empty-paragraph"><br></p><h3>缓存预编译</h3><p data-pid="F0wbmgYy">预编译是一种将 SQL 语句编译为数据库可以识别的语句的过程。这种编译过程可以提高查询性能，因为数据库不需要在每次执行查询时都重新编译 SQL 语句。</p><p data-pid="zTnOIHCd">GORM 中可以使用预编译语句来提高查询性能。使用预编译语句的方法是将 SQL 语句传递给 gorm.DB.Exec 或 gorm.DB.Query，并将需要传递给 SQL 语句的参数作为第二个参数传递。</p><p data-pid="nB7TWNZr"> 简单的一个案例如下：</p><div class="highlight"><pre><code class="language-go"><span class="nx">db</span><span class="p">.</span><span class="nf">Exec</span><span class="p">(</span><span class="s">"INSERT INTO users (name, age) VALUES (?, ?)"</span><span class="p">,</span> <span class="s">"John Doe"</span><span class="p">,</span> <span class="mi">30</span><span class="p">)</span>
</code></pre></div><p data-pid="qzMTBpoZ">其中，第一个参数是预编译的 SQL 语句，第二个参数是要传递给 SQL 语句的参数。</p><p data-pid="JiDlU1aT">缓存预编译是一种优化查询性能的方法，它可以将预编译过的 SQL 语句存储在缓存中，以便在需要执行相同的查询时可以重用已编译的语句。这可以减少数据库编译 SQL 的开销，提高性能。</p><div class="highlight"><pre><code class="language-go"><span class="nx">db</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">gorm</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="s">"mysql"</span><span class="p">,</span> <span class="s">"user:password@/dbname?charset=utf8&amp;parseTime=True&amp;loc=Local&amp;strict=true&amp;cache=true"</span><span class="p">)</span>
</code></pre></div><p data-pid="1YxYlQXI">其中，<code>strict=true</code> 参数告诉 GORM 在每次操作时都启用事务，<code>cache=true</code> 参数告诉 GORM 缓存预编译语句。</p><p data-pid="7MItGkGw">使用缓存预编译语句可以显著提高查询性能，特别是对于执行相同的查询的情况。</p><h3>关闭默认事务</h3><p data-pid="kwoSkdAU">GORM 默认在每次数据库操作时都会启用事务，但是有时候我们不需要这样。</p><p data-pid="yfqs6dRh">在 GORM 中关闭默认事务可以使用 gorm.Open 方法打开数据库连接时的参数。</p><div class="highlight"><pre><code class="language-go"><span class="nx">db</span><span class="p">,</span> <span class="nx">err</span> <span class="o">:=</span> <span class="nx">gorm</span><span class="p">.</span><span class="nf">Open</span><span class="p">(</span><span class="s">"mysql"</span><span class="p">,</span> <span class="s">"user:password@/dbname?charset=utf8&amp;parseTime=True&amp;loc=Local&amp;autocommit=true"</span><span class="p">)</span>
</code></pre></div><p data-pid="wYoMD1ba">其中，<code>autocommit=true</code> 参数告诉 GORM 在每次操作时不启用事务。如果不需要事务，这样做可以提高性能。</p><p data-pid="xjXJx6FU">注意：关闭事务后需要自己手动管理事务，如果需要事务支持，请不要关闭默认事务。</p><h3>GORM生态</h3><table data-draft-node="block" data-draft-type="table" data-size="normal" data-row-style="normal"><tbody><tr><th>扩展名称</th><th>描述</th><th>GitHub地址</th></tr><tr><td>GORM 代码生成工具</td><td>可以根据数据库表结构自动生成 Go 代码，帮助使用 GORM 的用户更快速地开发</td><td><a href="https://github.com/go-gorm/gen" target="_blank"><span class="invisible">https://</span><span class="visible">github.com/go-gorm/gen</span><span class="invisible"></span></a></td></tr><tr><td>GORM 分片库方案</td><td>对 GORM 进行的分片库扩展，可以帮助用户管理分片数据库</td><td><a href="https://github.com/go-gorm/sharding" target="_blank"><span class="invisible">https://</span><span class="visible">github.com/go-gorm/shar</span><span class="invisible">ding</span><span class="ellipsis"></span></a></td></tr><tr><td>GORM 手动索引</td><td>帮助用户在 GORM 中手动创建索引</td><td><a href="https://github.com/go-gorm/hints" target="_blank"><span class="invisible">https://</span><span class="visible">github.com/go-gorm/hint</span><span class="invisible">s</span><span class="ellipsis"></span></a></td></tr><tr><td>GORM 乐观锁</td><td>对 GORM 进行的乐观锁扩展，可以帮助用户处理并发冲突</td><td><a href="https://github.com/go-gorm/optimisticlock" target="_blank"><span class="invisible">https://</span><span class="visible">github.com/go-gorm/opti</span><span class="invisible">misticlock</span><span class="ellipsis"></span></a></td></tr><tr><td>GORM 读写分离</td><td>对 GORM 进行的读写分离扩展，可以帮助用户优化数据库性能</td><td><a href="https://github.com/go-gorm/dbresolver" target="_blank"><span class="invisible">https://</span><span class="visible">github.com/go-gorm/dbre</span><span class="invisible">solver</span><span class="ellipsis"></span></a></td></tr><tr><td>GORM OpenTelemetry 扩展</td><td>对 GORM 进行的 OpenTelemetry 扩展，可以帮助用户对 GORM 的性能进行监控和追踪</td><td><a href="https://github.com/go-gorm/opentelemetry" target="_blank"><span class="invisible">https://</span><span class="visible">github.com/go-gorm/open</span><span class="invisible">telemetry</span><span class="ellipsis"></span></a></td></tr></tbody></table><p data-pid="913nXv1C">更多用法：<a href="https://gorm.cn/" target="_blank">https://gorm.cn</a></p><h3>Kitex</h3><ul><li data-pid="LLK5HcP7">[x] <a href="https://github.com/cloudwego/kitex/" target="_blank">github地址</a></li></ul><p data-pid="Fr7liSp5">Kitex是字节内部的Golang微服务PRC框架。</p><p data-pid="DSr8_l-S">Kitex是一个高性能的开源网络库，它具有高性能、低延迟和高可靠性特点。它支持多种协议，如TCP、UDP、HTTP和RPC等，可以用于构建分布式系统、微服务和云计算等应用。 Kitex的主要用途是在应用程序中提供高性能的网络通信支持，并帮助开发人员更轻松地实现分布式应用程序和微服务。</p><p data-pid="CivNJiiO">Kitex 目前对 Windows 的支持不完善，如果本地开发环境是 windows 的话需要用到 虚拟机或者是 WSL2。</p><p data-pid="VbWhNI7C"><b>安装代码生成工具：</b></p><div class="highlight"><pre><code class="language-text">go install github.com/cloudwego/kitex/tool/cmd/kitex@latest
go install github.com/cloudwego/thriftgo@latest</code></pre></div><p data-pid="TP3xuNQL"><b>验证：</b></p><div class="highlight"><pre><code class="language-text">kitex -version</code></pre></div><h3>定义 IDL</h3><p data-pid="9eorfywO">IDL (Interface Definition Language) 是指接口定义语言，是用于描述远程过程调用（RPC）或对象请求代理（ORP）接口的语言。 IDL 中定义了远程对象的接口，其中包括方法名称、参数类型和返回值类型等信息。这些信息可以用于生成代码来实现远程调用。常见的 IDL 标准有 CORBA 和 Microsoft COM/DCOM。</p><h3>生成代码</h3><p data-pid="yP_d0uOo">使用下面的命令生成代码：</p><div class="highlight"><pre><code class="language-bash">kitex -module example -service example echo.thrift</code></pre></div><p data-pid="TzDRQEI7">RPC（Remote Procedure Call Protocol）远程过程调用协议。一个通俗的描述是：客户端在不知道调用细节的情况下，调用存在于远程计算机上的某个对象，就像调用本地应用程序中的对象一样。比较正式的描述是：一种通过网络从远程计算机程序上请求服务，而不需要了解底层网络技术的协议。</p><div class="highlight"><pre><code class="language-go"><span class="c1">// 使用IDL定义服务与接口
</span><span class="c1"></span><span class="cm">/*
</span><span class="cm">如果我们要进行PRC，就需要知道对方的接口是什么，需要传什么参数，同时也需要知道返回值时什么样的，这个时候，就需要通过IDL来约定双方的协议，就像在写代码的时候需要调用某个函数，我们需要知道函数签名一样。
</span><span class="cm">*/</span>
<span class="c1">// Thrift: https://thrift.apache.org/docs/idl
</span><span class="c1">// Proto3: https://developers.google.com/protocol-buffers/docs/proto3
</span><span class="c1"></span>
<span class="nx">namespace</span> <span class="k">go</span> <span class="nx">api</span>

<span class="kd">struct</span> <span class="nx">Request</span> <span class="p">{</span>
    <span class="mi">1</span><span class="p">:</span> <span class="kt">string</span> <span class="nx">message</span>
<span class="p">}</span>

<span class="kd">struct</span> <span class="nx">Response</span> <span class="p">{</span>
    <span class="mi">1</span><span class="p">:</span> <span class="kt">string</span> <span class="nx">message</span>
<span class="p">}</span>

<span class="nx">service</span> <span class="nx">Echo</span> <span class="p">{</span>
    <span class="nx">Response</span> <span class="nf">echo</span><span class="p">(</span><span class="mi">1</span><span class="p">:</span> <span class="nx">Request</span> <span class="nx">req</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><p data-pid="eayMDza0"><b>文件说明</b>：</p><ul><li data-pid="ryeUgv5K">build.sh：构建脚本</li><li data-pid="9ziFfDCa">kitex_gen：IDL内容相关的生成代码，主要是基础的Server/Client代码</li><li data-pid="vzYMP3Un">main.go：程序入口</li><li data-pid="fF2FQgkF">handler.go：用户在该文件里实现IDLservice定义的方法</li></ul><p data-pid="vlnuohxN">服务默认监听8888端口；</p><p data-pid="0y4weguQ">Kitex Client发起请求：</p><ul><li data-pid="YkD1ARo-">创建Client</li><li data-pid="bXz-yek6">发起请求</li></ul><p data-pid="zXXg3zlD">Kitex服务注册与发现：</p><p data-pid="_4KUx26p">目前Kitex的服务注册与发现已经对接了主流的服务注册与发现中心，如ETCD，Nacos等；</p><p data-pid="NtH59oYn">Kitex生态：</p><p data-pid="ANPb8MOj">详见：<code>https://www.cloudwego.io/zh/docs/kitex/</code></p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic2.zhimg.com/v2-88b58b3d68ec14142771ef5c2c2dc01d_r.jpg" data-size="normal" width="2060" referrerpolicy="no-referrer"><figcaption>image-20230127204236167</figcaption></figure><p class="ztext-empty-paragraph"><br></p><p data-pid="459tu3E5"><b>发起请求：</b></p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic4.zhimg.com/v2-5f917ea103992f5cf9142b66ebc19537_r.jpg" data-size="normal" width="2060" referrerpolicy="no-referrer"><figcaption>image-20230127204252098</figcaption></figure><p class="ztext-empty-paragraph"><br></p><h3>Kitex 服务注册与发现</h3><p data-pid="_VrhtZ3k">目前的 Kitex 的服务注册与发现已经对接了主流的服务注册与发现中心，如 ETCD 、Nacos</p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic4.zhimg.com/v2-9a75daa0721f73cdbee35661d6dc0dd3_r.jpg" data-size="normal" width="2060" referrerpolicy="no-referrer"><figcaption>image-20230127204301522</figcaption></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic3.zhimg.com/v2-85fc056b4d3a2392244ef23267e32b92_r.jpg" data-size="normal" width="2060" referrerpolicy="no-referrer"><figcaption>image-20230127204312988</figcaption></figure><p class="ztext-empty-paragraph"><br></p><h3>生态</h3><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic4.zhimg.com/v2-f4935a5e7bc0442e53b158097c67089b_r.jpg" data-size="normal" width="2060" referrerpolicy="no-referrer"><figcaption>image-20230127204326966</figcaption></figure><p class="ztext-empty-paragraph"><br></p><h3>Hertz</h3><p data-pid="dmFPRkQW">Hertz 是字节内部的 HTTP 框架。</p><p data-pid="a4Sxqa_0">Hertz 是字节跳动服务框架团队研发的超大规模的企业级微服务 HTTP 框架，具有 <b>高易用性、易扩展、低时延</b> 等特点。在经过了字节跳动内部一年多的使用和迭代，如今已在 CloudWeGo 正式开源。目前，<code>Hertz</code> 已经成为了字节跳动内部最大的 <code>HTTP</code> 框架，线上接入的服务数量超过 1 万，峰值 QPS 超过 4 千万。除了各个业务线的同学使用外，也服务于内部很多基础组件，<b>如：</b> 函数计算平台 <code>FaaS</code>、压测平台、各类网关、<code>Service Mesh</code> 控制面等，均收到不错的使用反馈。在如此大规模的场景下，<code>Hertz</code> 拥有极强的稳定性和性能，在内部实践中某些典型服务，如框架占比较高的服务、网关等服务，迁移 <code>Hertz</code> 后相比 Gin 框架，资源使用显著减少，CPU 使用率随流量大小降低 <code>30%-60%</code>，时延也有明显降低。</p><p data-pid="yjvXB022">Hertz 坚持内外维护一套代码，为开源使用提供了强有力的保障。通过开源， Hertz 也将丰富云原生的 Golang 中间件体系，完善 CloudWeGo 生态矩阵，为更多开发者和企业搭建云原生化的大规模分布式系统，提供一种现代的、资源高效的的技术方案。</p><h3>项目源码</h3><p data-pid="t8aBx4nN">最初，字节跳动内部的 HTTP 框架是对 Gin 框架的封装，具备不错的易用性、生态完善等优点。随着内部业务的不断发展，高性能、多场景的需求日渐强烈。而 Gin 是对 Golang 原生 net/http 进行的二次开发，在按需扩展和性能优化上受到很大局限。因此，为了满足业务需求，更好的服务各大业务线，2020 年初，字节跳动服务框架团队经过内部使用场景和外部主流开源 HTTP 框架 Fasthttp、Gin、Echo 的调研后，开始基于自研网络库 Netpoll 开发内部框架 Hertz，让 Hertz 在面对企业级需求时，有更好的性能及稳定性表现，也能够满足业务发展和应对不断演进的技术需求。</p><h3>架构设计</h3><p data-pid="3-iKI0tJ">Hertz 设计之初调研了大量业界优秀的 HTTP 框架，同时参考了近年来内部实践中积累的经验。为了保证框架整体上满足：1. 极致性能优化的可能性；2. 面对未来不可控需求的扩展能力， Hertz 采用了 4 层分层设计，保证各个层级功能内聚，同时通过层级之间的接口达到灵活扩展的目标。整体架构图如图 1 所示。</p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic4.zhimg.com/v2-d0b2a1d66cc7460f5c21589b65afb0a3_r.jpg" data-size="normal" width="1294" referrerpolicy="no-referrer"><figcaption>image-20230127215358335</figcaption></figure><p class="ztext-empty-paragraph"><br></p><p data-pid="Gh2kIaBo">Hertz 从上到下分为：应用层、路由层、协议层和传输层，每一层各司其职，同时公共能力被统一抽象到公共层（common），做到跨层级复用。另外，同主库一同发布的还有作为子模块的 Hz 脚手架，它能够协助使用者快速搭建出项目核心骨架以及提供实用的构建工具链。</p><h3>应用层</h3><p data-pid="KBubZzys">应用层是和用户直接交互的一层，提供丰富易用的 API，主要包括 Server、Client 和一些其他通用抽象。Server 提供了注册 HandlerFunc、Binding、Rendering 等能力；Client 提供了调用下游和服务发现等能力；以及抽象一个 HTTP 请求所必须涉及到的请求（Request）、响应（Response）、上下文（RequestContext）、中间件（Middleware）等等。Hertz 的 Server 和 Client 都能够提供中间件这样的扩展能力。</p><p data-pid="Z1-LxF2h">应用层中一个非常重要的抽象就是对 Server HandlerFunc 的抽象。早期，Hertz 路由的处理函数 （HandlerFunc）中并没有接收标准的 <code>context.Context</code>，我们在大量的实践过程中发现，业务方通常需要一个标准的上下文在 RPC Client 或者日志、Tracing 等组件间传递，但由于请求上下文（RequestContext）生命周期局限于一次 HTTP 请求之内，而以上提到的场景往往存在异步的传递和处理，导致如果直接传递请求上下文，会导致出现一些数据不一致的问题。为此我们做了诸多尝试，但是因为核心原因在于请求上下文（RequestContext）的生命周期无法优雅的按需延长，最终在各种设计权衡下，我们在路由的处理函数签名中增加一个标准的上下文入参，通过分离出生命周期长短各异的两个上下文的方式，从根本上解决各种因为上下文生命周期不一致导致的异常问题，即：</p><div class="highlight"><pre><code class="language-go"><span class="kd">type</span> <span class="nx">HandlerFunc</span> <span class="kd">func</span><span class="p">(</span><span class="nx">c</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">ctx</span> <span class="o">*</span><span class="nx">app</span><span class="p">.</span><span class="nx">RequestContext</span><span class="p">)</span>
</code></pre></div><h3>路由层</h3><p data-pid="KyUEClRZ">路由层负责根据 URI 匹配对应的处理函数。</p><p data-pid="yRPRUCP7">起初，Hertz 的路由基于 httprouter 开发，但随着使用的用户越来越多，httprouter 渐渐不能够满足需求，主要体现在 httprouter 不能够同时注册静态路由和参数路由，即 /a/b，/:c/d 这两个路由不能够同时注册；甚至有一些更特殊的需求，如/a/b、/:c/b ，当匹配 /a/b 路由时，两个路由都能够匹配上。</p><p data-pid="Sx4IrjdA">Hertz 为满足这些需求重新构造了路由树，用户在注册路由时拥有很高的自由度：支持静态路由、参数路由的注册；支持按优先级匹配，如上述例子会优先匹配静态路由 /a/b ；支持路由回溯，如注册 /a/b、/:c/d，当匹配 /a/d 时仍然能够匹配上；支持尾斜线重定向，如注册 /a/b，当匹配 /a/b/ 时能够重定向到 /a/b 上。Hertz 提供了丰富的路由能力来满足用户的需求，更多的功能可以参考 Hertz 配置文档。</p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic4.zhimg.com/v2-90335d18eed633d449b38ee6302762e3_r.jpg" data-size="normal" width="2060" referrerpolicy="no-referrer"><figcaption>image-20230127220436931</figcaption></figure><p class="ztext-empty-paragraph"><br></p><h3>协议层</h3><p data-pid="Kn7EDlNc">协议层负责不同协议的实现和扩展。</p><p data-pid="oUk47DTJ">Hertz 支持协议的扩展，用户只需要实现下面的接口便可以按照自己的需求在引擎（Engine） 上扩展协议，同时也支持通过 ALPN 协议协商的方式注册。Hertz 首批只开源了 <code>HTTP1</code> 实现，未来会陆续开源 <code>HTTP2</code>、QUIC 等实现。协议层扩展提供的灵活性甚至可以超越 HTTP 协议的范畴，用户完全可以按需注册任意符合自身需求的协议层实现，并且加入到 Hertz 的引擎中来，同时，也能够无缝享受到传输层带来的极致性能。</p><div class="highlight"><pre><code class="language-go"><span class="kd">type</span> <span class="nx">ServerFactory</span> <span class="kd">interface</span> <span class="p">{</span>
   <span class="nf">New</span><span class="p">(</span><span class="nx">core</span> <span class="nx">Core</span><span class="p">)</span> <span class="p">(</span><span class="nx">server</span> <span class="nx">protocol</span><span class="p">.</span><span class="nx">Server</span><span class="p">,</span> <span class="nx">err</span> <span class="kt">error</span><span class="p">)</span>
<span class="p">}</span>

<span class="kd">type</span> <span class="nx">Server</span> <span class="kd">interface</span> <span class="p">{</span>
   <span class="nf">Serve</span><span class="p">(</span><span class="nx">c</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">conn</span> <span class="nx">network</span><span class="p">.</span><span class="nx">Conn</span><span class="p">)</span> <span class="kt">error</span>
<span class="p">}</span>
</code></pre></div><h3>传输层</h3><p data-pid="iKfTTkE-">传输层负责底层的网络库的抽象和实现。</p><p data-pid="CbsO6X_4">Hertz 支持底层网络库的扩展。Hertz 原生完美适配 Netpoll，在时延方面有很多深度的优化，非常适合时延敏感的业务接入。Netpoll 对 TLS 能力的支持有待完善，而 TLS 能力又是 HTTP 框架必备能力，为此 Hertz 底层同时支持基于 Golang 标准网络库的实现适配，支持网络库的一键切换，用户可根据自己的需求选择合适的网络库进行替换。如果用户有更加高效的网络库或其他网络库需求，也完全可以根据需求自行扩展。</p><h3>Hz 脚手架</h3><p data-pid="eJOaitOa">与 Hertz 一并开源的还有一个易用的命令行工具 Hz，用户只需提供一个 IDL，根据定义好的接口信息，Hz 便可以一键生成项目脚手架，让 Hertz 达到开箱即用的状态；Hz 也支持基于 IDL 的更新能力，能够基于 IDL 变动智能地更新项目代码。目前 Hz 支持了 Thrift 和 Protobuf 两种 IDL 定义。命令行工具内置丰富的选项，可以根据自己的需求使用。同时它底层依赖 Protobuf 官方的编译器和自研的 Thriftgo 的编译器，两者都支持自定义的生成代码插件。如果默认模板不能够满足需求，完全能够按需定义。</p><p data-pid="kX5i9Wwm">未来，我们将继续迭代 Hz，持续集成各种常用的中间件，提供更高层面的模块化构建能力。给 Hertz 的用户提供按需调整的能力，通过灵活的自定义配置打造一套满足自身开发需求的脚手架。</p><h3>Common 组件</h3><p data-pid="1rdE_Ixz">Common 组件主要存放一些公共的能力，比如错误处理、单元测试能力、可观测性相关能力（Log、Trace、Metrics 等）。对于服务可观测性的能力，Hertz 提供了默认的实现，用户可以按需装配；如果用户有特殊的需求，也可以通过 Hertz 提供的接口注入。比如对于 Trace 能力，Hertz 提供了默认的实现，也提供了将 Hertz 和 Kitex 串起来的 Example。如果想注入自己的实现，也可以实现下面的接口：</p><p data-pid="bDmfzPPE">复制</p><div class="highlight"><pre><code class="language-go"><span class="c1">// Tracer is executed at the start and finish of an HTTP.
</span><span class="c1"></span><span class="kd">type</span> <span class="nx">Tracer</span> <span class="kd">interface</span> <span class="p">{</span>
        <span class="nf">Start</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">c</span> <span class="o">*</span><span class="nx">app</span><span class="p">.</span><span class="nx">RequestContext</span><span class="p">)</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span>
        <span class="nf">Finish</span><span class="p">(</span><span class="nx">ctx</span> <span class="nx">context</span><span class="p">.</span><span class="nx">Context</span><span class="p">,</span> <span class="nx">c</span> <span class="o">*</span><span class="nx">app</span><span class="p">.</span><span class="nx">RequestContext</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div><h3>Hertz 中间件</h3><p data-pid="q8kO6Te4">Hertz 除了提供 Server 的中间件能力，还提供了 Client 中间件能力。用户可以使用中间件能力将通用逻辑（如：日志记录、性能统计、异常处理、鉴权逻辑等等）和业务逻辑区分开，让用户更加专注于业务代码。Server 和 Client 中间件使用方式相同，使用 Use 方法注册中间件，中间件执行顺序和注册顺序相同，同时支持预处理和后处理逻辑。</p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic2.zhimg.com/v2-ea10510d4921361a43da0f7834293235_r.jpg" data-size="normal" width="2060" referrerpolicy="no-referrer"><figcaption>image-20230127221552419</figcaption></figure><p class="ztext-empty-paragraph"><br></p><p data-pid="4oDN8Aw0">Server 和 Client 的中间件实现方式并不相同。对于 Server 来说，我们希望减少栈的深度，同时也希望中间件能够默认的执行下一个，用户需要手动终止中间件的执行。因此，我们将 Server 的中间件分成了两种类型，即不在同一个函数调用栈（该中间件调用完后返回，由上一个中间件调用下一个中间件，如图 2 中 B 和 C）和在同一个函数调用栈的中间件（该中间件调用完后由该中间件继续调用下一个中间件，如图 2 中 C 和 Business Handler）。</p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic2.zhimg.com/v2-c81f81a83d8be3c7f82e9e41bc021fa9_r.jpg" data-size="normal" width="1294" referrerpolicy="no-referrer"><figcaption>image-20230127220729078</figcaption></figure><p class="ztext-empty-paragraph"><br></p><p data-pid="ewG-Al8w">其核心是需要一个地方存下当前的调用位置 index，并始终保持其递增。恰好 RequestContext 就是一个存储 index 合适的位置。但是对于 Client，由于没有合适的地方存储 index，我们只能退而求其次，抛弃 index 的实现，将所有的中间件构造在同一调用链上，需要用户手动调用下一个中间件。</p><h3>Hertz代码生成工具</h3><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic3.zhimg.com/v2-98212703ef15b36c13a21be1796401d2_r.jpg" data-size="normal" width="2060" referrerpolicy="no-referrer"><figcaption>image-20230127221632637</figcaption></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic3.zhimg.com/v2-e2000f85aa3e52cf8b42d78620bcb67a_r.jpg" data-size="normal" width="2060" referrerpolicy="no-referrer"><figcaption>image-20230127221625700</figcaption></figure><p class="ztext-empty-paragraph"><br></p><h3>Hertz 性能</h3><p data-pid="7QRUfHde">hertz 的性能非常不错</p><p data-pid="Gg-HALT5">Hertz 使用字节跳动自研高性能网络库 Netpoll，在提高网络库效率方面有诸多实践，参考已发布文章字节跳动在 Go 网络库上的实践。除此之外，Netpoll 还针对 HTTP 场景进行优化，通过减少拷贝和系统调用次数提高吞吐以及降低时延。为了衡量 Hertz 性能指标，我们选取了社区中有代表性的框架 Gin（net/http）和 Fasthttp 作为对比，可以看到，Hertz 的极限吞吐、TP99 等指标均处于业界领先水平。未来，Hertz 还将继续和 Netpoll 深度配合，探索 HTTP 框架性能的极限。</p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic2.zhimg.com/v2-bf704171dbe91d672e71bda232079b49_r.jpg" data-size="normal" width="1294" referrerpolicy="no-referrer"><figcaption>image-20230127222150908</figcaption></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic2.zhimg.com/v2-c032eab7124bcf40a042b0011deaacc9_r.jpg" data-size="normal" width="2060" referrerpolicy="no-referrer"><figcaption>image-20230127222008547</figcaption></figure><p class="ztext-empty-paragraph"><br></p><h3>笔记项目</h3><ul><li data-pid="0iFtXvR8"><a href="https://github.com/cloudwego/kitex-examples/tree/main/bizdemo/easy_note" target="_blank"><span class="invisible">https://</span><span class="visible">github.com/cloudwego/ki</span><span class="invisible">tex-examples/tree/main/bizdemo/easy_note</span><span class="ellipsis"></span></a></li></ul><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic4.zhimg.com/v2-bedb36b15676b1286f1c2d34c48c5abf_r.jpg" data-size="normal" width="1777" referrerpolicy="no-referrer"><figcaption>image-20230127222247737</figcaption></figure><p class="ztext-empty-paragraph"><br></p><table data-draft-node="block" data-draft-type="table" data-size="normal" data-row-style="normal"><tbody><tr><th>Service Name</th><th>Usage</th><th>Framework</th><th>protocol</th><th>Path</th><th>IDL</th></tr><tr><td>demoapi</td><td>http interface</td><td>kitex/hertz</td><td>http</td><td>bizdemo/easy_note/cmd/api</td><td></td></tr><tr><td>demouser</td><td>user data management</td><td>kitex/gorm</td><td>protobuf</td><td>bizdemo/easy_note/cmd/user</td><td>bizdemo/easy_note/idl/user.proto</td></tr><tr><td>demonote</td><td>note data management</td><td>kitex/gorm</td><td>thrift</td><td>bizdemo/easy_note/cmd/note</td><td>bizdemo/easy_note/idl/note.thrift</td></tr></tbody></table><p data-pid="S7ZVOjPd"><b>项目模板：</b></p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic1.zhimg.com/v2-62e587ad1de0b248679a901a14554780_r.jpg" data-size="normal" width="959" referrerpolicy="no-referrer"><figcaption>image-20230127222531947</figcaption></figure><p class="ztext-empty-paragraph"><br></p><p data-pid="3Z1gjKRN"><b>项目调用关系：</b></p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic1.zhimg.com/v2-39b35c05cc28467a39d09e7785ffaeac_r.jpg" data-size="normal" width="2060" referrerpolicy="no-referrer"><figcaption>image-20230127222554091</figcaption></figure><p class="ztext-empty-paragraph"><br></p><p data-pid="R5-j2dur">API 并不是和数据库打交道的，这样好处是可以复用接口，可扩展性强。</p><p data-pid="6XHcuOLR"><b>技术栈：</b></p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic4.zhimg.com/v2-1253c0e485e8accb4c6adfbadd715f7f_r.jpg" data-size="normal" width="2060" referrerpolicy="no-referrer"><figcaption>image-20230127222808115</figcaption></figure><p class="ztext-empty-paragraph"><br></p><h3>END 链接</h3><ul><li data-pid="n38052z-"><a href="https://github.com/3293172751/Block_Chain/blob/master/Git/git-contributor.md" target="_blank">参与贡献❤️  </a></li></ul></div> </details> 
 <hr /> 

 #### - [GitHub CLI 命令行工具（gh)](https://zhuanlan.zhihu.com/p/601200139) 
 <details><summary>توضیحات</summary> <p><img src="https://pica.zhimg.com/v2-6639f5532051dc06975b996482e391b2_720w.jpg?source=d16d100b"></p><div><h2><b>开始</b></h2><ul><li data-pid="-SqZKDFL"><a href="https://github.com/cli/cli#installation" target="_blank">GitHub CLI 仓库地址</a></li></ul><p data-pid="eD3UTo5K">[[Github CLI]] 是一个非常好用的命令行工具，可以让开发者通过命令行于 GitHub 进行无缝的协同工作，也就是我们直接在命令行终端上就可以进行 pull requests、issues 等其他功能。</p><figure data-size="normal"><img src="https://pic3.zhimg.com/v2-d30d3b4ca1f64c0b1ae4dbefd9e9fb92_r.jpg" data-caption="" data-size="normal" width="2038" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p data-pid="j7S70gNp"><b>基于我目前处于 2.0 版本，主要介绍 2.0 的使用：</b></p><div class="highlight"><pre><code class="language-bash"> C:<span class="se">\U</span>sers<span class="se">\s</span>mile&gt;gh version
 gh version 2.20.0 <span class="o">(</span>2022-11-08<span class="o">)</span>
 https://github.com/cli/cli/releases/tag/v2.20.0</code></pre></div><p data-pid="Tzia0xwT">GitHub CLI 2.0 支持扩展，允许任何人创建基于 GitHub CLI 核心功能的自定义命令。</p><p data-pid="lpAmR1e-">我们使用<a href="https://github.blog/2020-09-17-github-cli-1-0-is-now-available/" target="_blank">GitHub CLI 1.0</a>的目标是构建令人惊叹的工具，使您能够更无缝地端到端地在终端中完成最常见的开发人员工作流程。我们继续在此基础上构建，为脚本编写和使用<a href="https://github.blog/2021-04-15-work-with-github-actions-in-your-terminal-with-github-cli/" target="_blank">GitHub Actions</a>提供更好<a href="https://github.blog/2021-03-11-scripting-with-github-cli/" target="_blank">的支持</a>。但我们知道，一种放之四海而皆准的工具永远无法满足每个开发人员的需求。</p><p class="ztext-empty-paragraph"><br></p><p data-pid="Vl5Y3Cbi"><b> 不仅如此，我们在 github 中也可以发现，GitHub CLI 是用 Go语言写的一个命令行工具，目前的贡献者已经快达到 400 人，甚至对于我们来说，这也是一个很好的学习机会，我们可以对此进行 PR 。</b></p><h2><b>开始</b></h2><h3><b>安装</b></h3><p data-pid="orWMMhvp">GitHub仓库中有详细的  <a href="https://github.com/cli/cli#installation" target="_blank">️安装信息</a></p><blockquote data-pid="ZW3OgG5O">由于本身已经使用 windown 安装过，接下来使用 Linux 记录测试并且记录安装过程 ️ </blockquote><p data-pid="hqePI-vy">我选择使用 二进制进行安装，这样的在Linux环境中是通用的，版本是：<a href="https://github.com/cli/cli/releases/download/v2.22.0/gh_2.22.0_linux_386.tar.gz" target="_blank"><span class="invisible">https://</span><span class="visible">github.com/cli/cli/rele</span><span class="invisible">ases/download/v2.22.0/gh_2.22.0_linux_386.tar.gz</span><span class="ellipsis"></span></a></p><p data-pid="JCo7X3n4">安装完成后直接在命令行中执行 <code>gh</code> 命令，看到如下所示的信息就证明已经安装完成：</p><p class="ztext-empty-paragraph"><br></p><h3><b>登陆验证</b></h3><p data-pid="WJGzfkxp"><b>使用命令登陆：</b></p><div class="highlight"><pre><code class="language-bash"> C:<span class="se">\U</span>sers<span class="se">\s</span>mile&gt;gh auth login
 ? What account <span class="k">do</span> you want to log into? GitHub.com
 ? What is your preferred protocol <span class="k">for</span> Git operations? HTTPS
 ? Authenticate Git with your GitHub credentials? Yes
 ? How would you like to authenticate GitHub CLI? Login with a web browser
 ​
 ! First copy your one-time code: CC38-2C29
 Press Enter to open github.com in your browser...
 ✓ Authentication complete.
 - gh config <span class="nb">set</span> -h github.com git_protocol https
 ✓ Configured git protocol
 ✓ Logged in as cubxxw</code></pre></div><p class="ztext-empty-paragraph"><br></p><p data-pid="hed826Zy"><b>网页端验证即可：</b></p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic4.zhimg.com/v2-4b8dea98532c7912aa3aaf83090c7d6b_r.jpg" data-caption="" data-size="normal" width="2880" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>令牌登陆验证</b></h3><p data-pid="ObhfzMVJ">选择 token 方式登陆验证，GitHub创建token，粘贴即可：</p><div class="highlight"><pre><code class="language-bash"> root@cubmaster01:~/workspces/sealer# gh auth login 
 ? What account <span class="k">do</span> you want to log into? GitHub.com
 ? What is your preferred protocol <span class="k">for</span> Git operations? HTTPS
 ? Authenticate Git with your GitHub credentials? Yes
 ? How would you like to authenticate GitHub CLI? Paste an authentication token
 Tip: you can generate a Personal Access Token here https://github.com/settings/tokens
 The minimum required scopes are <span class="s1">'repo'</span>, <span class="s1">'read:org'</span>, <span class="s1">'workflow'</span>.
 ? Paste your authentication token: ****************************************
 - gh config <span class="nb">set</span> -h github.com git_protocol https
 ✓ Configured git protocol
 ✓ Logged in as cubxxw</code></pre></div><p class="ztext-empty-paragraph"><br></p><h2><b>使用 gh repo</b></h2><p data-pid="dlEHWXRU">开始在命令行中使用 GitHub。 例如，使用 <code>gh issue status</code> 或 <code>gh issue list --assignee @me</code> 查找要处理的问题。 使用 <code>gh pr create</code> 创建拉取请求。 使用 <code>gh pr checkout</code>、<code>gh pr diff</code> 和 <code>gh pr review</code> 查看拉取请求。</p><p data-pid="dE46VDLO"><code>gh repo</code> 命令是 GitHub CLI 的一部分，它可以帮助你在命令行中管理 GitHub 仓库。</p><p data-pid="9MWnDzgy">具体而言，<code>gh repo</code> 命令包括以下子命令：</p><ul><li data-pid="1ymaAX4Q"><code>gh repo clone</code>: 克隆一个存储库到本地</li><li data-pid="1xCrWKEs"><code>gh repo create</code>: 创建一个新的存储库</li><li data-pid="0Uj-ZWv1"><code>gh repo fork</code>: 将一个存储库复制到自己的账户下</li><li data-pid="t06777dq"><code>gh repo list</code>: 列出自己的所有存储库</li><li data-pid="AWTePUxs"><code>gh repo set-default</code>: 设置默认的存储库</li><li data-pid="kwqSa_X1"><code>gh repo view</code>: 查看存储库的详细信息</li></ul><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>设置默认的远程仓库</b></h3><p data-pid="bG55bO44"><code>gh repo set-default</code> 命令是 GitHub CLI 的一部分，它可以帮助你设置默认的远程存储库。这样，在使用 GitHub CLI 的其他命令时，就可以省略存储库的名称。</p><p data-pid="0v2DqLdK"><b>命令格式：</b></p><div class="highlight"><pre><code class="language-text"> gh repo set-default [OWNER]/[REPO]</code></pre></div><p data-pid="QV0pok7T">其中，OWNER 是存储库所有者的用户名，REPO 是存储库名称。</p><p class="ztext-empty-paragraph"><br></p><p data-pid="YQQxN00y"> 简单的一个案例如下：</p><div class="highlight"><pre><code class="language-bash"> <span class="o">[</span>root@dev sealos<span class="o">]</span><span class="c1"># gh repo set-default</span>
 This <span class="nb">command</span> sets the default remote repository to use when querying the
 GitHub API <span class="k">for</span> the locally cloned repository.
 ​
 gh uses the default repository <span class="k">for</span> things like:
 ​
  - viewing and creating pull requests
  - viewing and creating issues
  - viewing and creating releases
  - working with Actions
  - adding repository and environment secrets
 ​
 ? Which repository should be the default? cubxxw/sealos
 ✓ Set cubxxw/sealos as the default repository <span class="k">for</span> the current directory</code></pre></div><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>克隆仓库</b></h3><div class="highlight"><pre><code class="language-bash"> smile@DESKTOP-N9GOOM4 MINGW64 /d/文档/git
 $ gh repo clone cubxxw/cubxxw
 Cloning into <span class="s1">'cubxxw'</span>...
 remote: Enumerating objects: 1755, <span class="k">done</span>.
 remote: Counting objects: 100% <span class="o">(</span>1755/1755<span class="o">)</span>, <span class="k">done</span>.
 remote: Compressing objects: 100% <span class="o">(</span>565/565<span class="o">)</span>, <span class="k">done</span>.</code></pre></div><blockquote data-pid="2u9RJNPO">如果是自己的仓库可以省略 用户名 cubxxw</blockquote><p class="ztext-empty-paragraph"><br></p><p data-pid="WB5IYeG-">我们可以使用 <code>gh</code> 命令来过滤 issue，比如过滤带有 <code>gitment</code> 标签的问题：</p><p class="ztext-empty-paragraph"><br></p><h3><b>显示仓库 README 文件</b></h3><p data-pid="z83xtp2m"><code>gh repo view</code> 命令</p><div class="highlight"><pre><code class="language-bash"> gh repo view <span class="o">[</span>OWNER<span class="o">]</span>/<span class="o">[</span>REPO<span class="o">]</span></code></pre></div><p data-pid="8wpPloOJ">'gh repo view' 命令可以帮助你查看存储库的详细信息。 你可以使用这个命令来查看诸如存储库名称、描述、语言、活跃度、贡献者等信息。</p><blockquote data-pid="Es3zrCI_">如果不加 <code>[OWNER]/[REPO]</code> ，那么默认选中的是当前所在目录的 README 文件。</blockquote><p data-pid="7XQTH3t9"><b> 简单的一个案例如下：</b></p><div class="highlight"><pre><code class="language-text"> gh repo view cubxxw/cubxxw</code></pre></div><p class="ztext-empty-paragraph"><br></p><h2><b>gh issue</b></h2><p data-pid="U_tVoyGS"><code>gh issue</code> 命令是 GitHub CLI 的一部分，它可以帮助你在命令行中管理 GitHub 上的 issues。</p><p data-pid="u2mO0eX0"><b>语法</b>：</p><div class="highlight"><pre><code class="language-text"> gh issue &lt;subcommand&gt; [options] [args]</code></pre></div><p data-pid="8jnrFbMq">其中，subcommand 是执行操作的子命令，options 是可选参数，args 是需要传入的参数。</p><p data-pid="kxpURvHr">所有可用的子命令如下：</p><ul><li data-pid="tTWb1QMx"><code>gh issue create</code>: 创建一个 issue</li><li data-pid="QAIVtArR"><code>gh issue list</code>: 列出当前仓库中的 issues</li><li data-pid="FaMsAnUF"><code>gh issue view</code>: 查看一个 issue 的详情</li><li data-pid="skVCw3qs"><code>gh issue update</code>: 更新一个 issue</li><li data-pid="zbcH0-tQ"><code>gh issue close</code>: 关闭一个 issue</li><li data-pid="_MsmPdiI"><code>gh issue reopen</code>: 重新打开一个 issue</li></ul><p class="ztext-empty-paragraph"><br></p><h3><b>创建一个 issue</b></h3><p data-pid="GgdfqZh5">例如，如果你想创建一个新的 issue，可以使用以下命令：</p><div class="highlight"><pre><code class="language-bash"> gh issue create -t <span class="s2">"New Feature"</span> -b <span class="s2">"This is a new feature"</span></code></pre></div><p data-pid="laeAnwPG">这将会在当前仓库中创建一个标题为 "New Feature"，描述为 "This is a new feature" 的 issue。</p><p class="ztext-empty-paragraph"><br></p><h3><b>列出所有 issue</b></h3><p data-pid="HssYK89X">再比如：列出当前仓库下的所有 issue：</p><div class="highlight"><pre><code class="language-bash"> <span class="o">[</span>root@dev sealer<span class="o">]</span><span class="c1"># gh issue list</span>
 ​
 Showing <span class="m">30</span> of <span class="m">173</span> open issues in sealerio/sealer
 ​
 <span class="c1">#1989  COPY ${ARCH} is not support in Kubefile                          kind/bug            about 8 days ago</span>
 <span class="c1">#1986  APP instruction with remote file address will generate tmp f...  kind/bug            about 9 days ago</span>
 <span class="c1">#1978  [Feature] k3s runtime design                         </span>
 .......</code></pre></div><p class="ztext-empty-paragraph"><br></p><h3><b>查看某个 issue</b></h3><p data-pid="v5gAB0DX"><b>我们可以查看 1989 这个 issue：</b></p><div class="highlight"><pre><code class="language-text"> gh issue view 1989</code></pre></div><p class="ztext-empty-paragraph"><br></p><h2><b>gh pr</b></h2><p data-pid="lol-bMlZ">创建一个分支，在提交几次代码后修复了 issue 中描述的 BUG 后，然后可以使用 <code>gh</code> 命令来创建一个 pull request 来提交我们贡献的代码：</p><div class="highlight"><pre><code class="language-text"> gh pr &lt;subcommand&gt; [options] [args]</code></pre></div><p data-pid="WTsTYio3">其中，subcommand 是执行操作的子命令，options 是可选参数，args 是需要传入的参数。</p><p data-pid="DSMKAAoO">所有可用的子命令如下：</p><ul><li data-pid="IXm5BMai"><code>gh pr create</code>: 创建一个 pull request</li><li data-pid="Ef_vJ2X-"><code>gh pr list</code>: 列出当前仓库中的 pull requests</li><li data-pid="GIYcFRTs"><code>gh pr view</code>: 查看一个 pull request 的详情</li><li data-pid="rsNwmGH-"><code>gh pr update</code>: 更新一个 pull request</li><li data-pid="C2sk1LfM"><code>gh pr merge</code>: 合并一个 pull request</li><li data-pid="hhsy96zb"><code>gh pr close</code>: 关闭一个 pull request</li><li data-pid="z659G6RT"><code>gh pr reopen</code>: 重新打开一个 pull request</li></ul><p class="ztext-empty-paragraph"><br></p><h3><b>创建一个 pr</b></h3><p data-pid="k2YMVG5S"><b>例如，最常见的，我们去创建一个 pr :</b></p><div class="highlight"><pre><code class="language-bash"> gh pr create -b <span class="s2">"feature-branch"</span> -h <span class="s2">"master"</span> -t <span class="s2">"New Feature"</span> -b <span class="s2">"This is a new feature"</span>
 <span class="c1">#################################################### </span>
 gh pr create -b &lt;分支名&gt; -h &lt;目标分支名&gt; -t &lt;标题&gt; -b &lt;描述&gt; -r &lt;远程仓库名&gt;</code></pre></div><p data-pid="jaoJym4t">这将会在当前仓库中创建一个源分支为 "feature-branch"，目标分支为 "master"，标题为 "New Feature"，描述为 "This is a new feature" 的 pull request。</p><p data-pid="ExsjEG7q">其中：</p><ul><li data-pid="jt7gykyG"><code>-b &lt;分支名&gt;</code>: 你本地仓库的源分支名称，比如 feature-branch。</li><li data-pid="Mm3zF0EV"><code>-h &lt;目标分支名&gt;</code>: 目标仓库的目标分支名称，比如 master。</li><li data-pid="EbD6ipea"><code>-t &lt;标题&gt;</code>: pull request 的标题，例如 "New Feature"。</li><li data-pid="h6f1URh7"><code>-b &lt;描述&gt;</code>: pull request 的描述，例如 "This is a new feature".</li><li data-pid="ygX7n_cs"><code>-r &lt;远程仓库名&gt;</code>: 远程仓库的名称，例如 origin</li></ul><p class="ztext-empty-paragraph"><br></p><h3><b>查看状态</b></h3><div class="highlight"><pre><code class="language-bash"> <span class="o">[</span>root@dev sealer<span class="o">]</span><span class="c1"># gh pr status</span>
 ​
 Relevant pull requests in sealerio/sealer
 ​
 Current branch
   There is no pull request associated with <span class="o">[</span>cubxxw:main<span class="o">]</span>
 ​
 Created by you
   You have no open pull requests
 ​
 Requesting a code review from you
   You have no pull requests to review</code></pre></div><p class="ztext-empty-paragraph"><br></p><h3><b>解决冲突 gh pr checkout</b></h3><p data-pid="0IeyKL9j"><code>gh pr checkout</code> 命令用于检出对应的 pull request 分支。该命令会自动拉取远程仓库中的最新代码并创建一个新的本地分支。</p><div class="highlight"><pre><code class="language-bash"> gh pr checkout &lt;pull-request-number&gt;</code></pre></div><p data-pid="nte8VeGZ">参数说明:</p><ul><li data-pid="1k9Y-WXz"><code>pull-request-number</code>：指定要检出的 pull request 的编号。</li></ul><p class="ztext-empty-paragraph"><br></p><p data-pid="biGSxBNp"><b>即使是使用  git ，最让我头疼的也是解决冲突：</b></p><p data-pid="LkET-9L2">解决冲突可以使用 <code>gh pr checkout</code> 命令来检出对应的 pull request 分支，然后在本地进行合并和解决冲突，最后使用 <code>git push</code> 将解决完冲突的代码推送到 GitHub。</p><p data-pid="6pQ3ctf-">具体来说，可以运行以下命令来解决冲突：</p><ol><li data-pid="pdEKXDoZ"><code>gh pr checkout &lt;pull-request-number&gt;</code>，检出对应的 pull request 分支。</li><li data-pid="Z7DUF2q_"><code>git pull &lt;remote-name&gt; &lt;base-branch&gt;</code>，将远程仓库中的最新代码拉取到本地。</li><li data-pid="bwcriagi"><code>git merge &lt;remote-name&gt;/&lt;base-branch&gt;</code> 或者 <code>git rebase &lt;remote-name&gt;/&lt;base-branch&gt;</code> 合并或者重构你本地的代码，解决冲突</li><li data-pid="UOpxtQ_F"><code>git push &lt;remote-name&gt; &lt;branch-name&gt;</code>，将解决完冲突的代码推送到 GitHub。</li><li data-pid="OgD49oRl"><code>gh pr merge</code> 合并代码到目标分支</li></ol><p data-pid="NC5YLnp2">注意：如果你使用了 <code>git pull</code> 命令，请务必使用 <code>git push --force</code> 将解决完冲突的代码推送到 GitHub，因为这样才能覆盖远程仓库中的冲突代码。</p><p data-pid="j9tB6N9B">如果你不确定remote-name 和base-branch 可以使用 <code>git remote -v</code> 查看远程仓库地址和分支信息。</p><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h2><b>使用 gh workflow</b></h2><p data-pid="mSt9D-s3">GitHub workflow 是 GitHub 的一个功能，允许你自动化项目中的工作流程。 使用 GitHub workflow，你可以设置触发器来执行特定的操作，如在提交代码时运行测试、在发布新版本时部署应用程序等。</p><p data-pid="RhM8c2P7">在你的项目中，你可以在 <code>.github/workflows</code> 目录中创建一个新的 workflow 文件。这些文件是使用 YAML 格式编写的，定义了触发器和要执行的操作。</p><p data-pid="OKCIDKTf"><code>gh workflow</code> 命令是 GitHub CLI 的一部分，它可以帮助你在命令行中管理 GitHub Actions 工作流。</p><p data-pid="-VnwYV19">具体而言，<code>gh workflow</code> 命令包括以下子命令：</p><ul><li data-pid="DAFd3c2P"><code>gh workflow run</code>: 运行一个工作流</li><li data-pid="o0DZc8Ks"><code>gh workflow list</code>: 列出存储库中的所有工作流</li><li data-pid="W6VvzBkU"><code>gh workflow view</code>: 查看工作流的详细信息</li></ul><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>运行工作流</b></h3><p data-pid="eD9lxpdX"><code>gh workflow run</code> 命令可以在命令行中触发 GitHub Actions 工作流的运行。</p><div class="highlight"><pre><code class="language-text"> gh workflow run &lt;workflow-name&gt; [flags]</code></pre></div><p class="ztext-empty-paragraph"><br></p><h3><b>列出所有的工作流</b></h3><div class="highlight"><pre><code class="language-text"> [root@dev sealos]# gh workflow list -a
 CI                       active  38929179
 Build Controllers image  active  38929180
 Release                  active  38314128
 Semgrep                  active  38929181
 Build Services image     active  39123670
 Sync Docs                active  38929182
 Build Webhooks image     active  39123671</code></pre></div><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>显示工作流</b></h3><p data-pid="GWrlhKu5"><code>gh workflow view</code> 命令可以帮助你查看项目中的特定 workflow 的详细信息。 你可以使用这个命令来查看 workflow 的名称、状态、触发器、步骤、日志等信息。</p><div class="highlight"><pre><code class="language-bash"> gh workflow view <span class="o">[</span>OWNER<span class="o">]</span>/<span class="o">[</span>REPO<span class="o">]</span> <span class="o">[</span>WORKFLOW_ID<span class="o">]</span></code></pre></div><p data-pid="m1dBZQOO">其中，OWNER 是存储库所有者的用户名，REPO 是存储库名称，WORKFLOW_ID 是 workflow 的唯一标识符。</p><p class="ztext-empty-paragraph"><br></p><h2><b>gh config 命令</b></h2><p data-pid="FuFxoUcZ"><code>gh config</code> 命令是 GitHub CLI 的一部分，它可以帮助你管理 GitHub CLI 的配置。</p><p data-pid="lxC58mFD">具体而言，<code>gh config</code> 命令包括以下子命令：</p><ul><li data-pid="OpGSPaZx"><code>gh config set</code>: 设置配置项的值</li><li data-pid="CyyFCYau"><code>gh config get</code>: 获取配置项的值</li><li data-pid="uZvTqASo"><code>gh config unset</code>: 删除配置项</li><li data-pid="Usv6B-2v"><code>gh config list</code>: 列出所有配置项</li></ul><p data-pid="Z0hGr69N">例如，如果你想设置 GitHub CLI 的默认 API URL 为 "<a href="https://my-github-enterprise.com/api/v3" target="_blank"><span class="invisible">https://</span><span class="visible">my-github-enterprise.com</span><span class="invisible">/api/v3</span><span class="ellipsis"></span></a>"，可以使用以下命令：</p><div class="highlight"><pre><code class="language-bash"> gh config <span class="nb">set</span> api.url https://my-github-enterprise.com/api/v3</code></pre></div><p data-pid="ZU9GUn14">这将会更新配置文件中的 api.url 项</p><p class="ztext-empty-paragraph"><br></p><h3><b>gh config set 命令</b></h3><p data-pid="7NhT2YIA"><code>gh config set</code> 命令是 GitHub CLI 的一部分，它可以帮助你设置 GitHub CLI 的配置项。</p><div class="highlight"><pre><code class="language-bash"> gh config <span class="nb">set</span> &lt;key&gt; &lt;value&gt;</code></pre></div><p data-pid="E964Wb6Q">其中，key 是配置项的名称，value 是要设置的值。</p><p data-pid="olp5PV1b">告诉 GitHub CLI 哪个文本编辑器用于打开文本编辑器的命令。 例如，输入 <code>gh config set editor "code -w"</code> 将首选文本编辑器设置为 Visual Studio Code。 有关详细信息，请参阅 <code><a href="https://cli.github.com/manual/gh_config_set" target="_blank">gh config set</a></code>。</p><p class="ztext-empty-paragraph"><br></p><h2><b>gh 扩展 gh extension</b></h2><blockquote data-pid="9ntB2C30">  GitHub CLI 2.0 支持扩展，允许任何人创建基于 GitHub CLI 核心功能的自定义命令。</blockquote><p data-pid="V0tEFruE"><code>gh extension</code> 命令是 GitHub CLI 的一部分，它可以帮助你管理和使用 GitHub CLI 的扩展。</p><div class="highlight"><pre><code class="language-bash"> gh extension &lt;subcommand&gt; <span class="o">[</span>options<span class="o">]</span> <span class="o">[</span>args<span class="o">]</span></code></pre></div><p data-pid="TIQnZail">其中，subcommand 是执行操作的子命令，options 是可选参数，args 是需要传入的参数。</p><p data-pid="TFTzuvuG">所有可用的子命令如下：</p><ul><li data-pid="D4Qlmtv0"><code>gh extension install</code>: 安装一个扩展</li><li data-pid="ZPWjSpzP"><code>gh extension list</code>: 列出已安装的扩展</li><li data-pid="22oq3ULX"><code>gh extension update</code>: 更新一个扩展</li><li data-pid="E3CFdIyE"><code>gh extension uninstall</code>: 卸载一个扩展</li></ul><p data-pid="6Kka3HPX">若要从当前目录安装开发中的扩展，使用 <code>.</code> 作为 <code>repo</code> 参数的值。</p><div class="highlight"><pre><code class="language-text"> gh extension install repo</code></pre></div><p data-pid="a2ZVp6r-">如果已安装同名的扩展，则该命令将失败。 例如，如果已安装 <code>octocat/gh-whoami</code>，则必须在安装 <code>hubot/gh-whoami</code> 之前卸载它。</p><p data-pid="R3PGZEZq"><b>更多关于 gh extension 标签都可以前往 github 搜索 <a href="https://github.com/topics/gh-extension" target="_blank">gh-extension</a></b></p><p class="ztext-empty-paragraph"><br></p><h3><b><code><a href="https://github.com/vilmibm/gh-user-status" target="_blank">gh user-status</a></code></b></h3><p data-pid="9fnWhmsu">此扩展允许您从终端快速设置 GitHub 用户状态，让其他人知道您何时不可用或处于焦点模式。</p><p data-pid="AXtzexf_"><b>安装：</b></p><div class="highlight"><pre><code class="language-text"> gh extension install vilmibm/gh-user-status</code></pre></div><p class="ztext-empty-paragraph"><br></p><h3><b><code><a href="https://github.com/mislav/gh-branch" target="_blank">gh branch</a></code></b></h3><p data-pid="q-bvVML-">此扩展是一个模糊查找器分支切换器，它按新近度对分支进行排序并显示有关任何相关拉取请求的信息。</p><p data-pid="SmbD6uTB"><b>安装：</b></p><div class="highlight"><pre><code class="language-text"> gh extension install mislav/gh-branch</code></pre></div><p class="ztext-empty-paragraph"><br></p><h3><b><code><a href="https://github.com/vilmibm/gh-contribute" target="_blank">gh contribute</a></code></b></h3><p data-pid="BbXYuW_B">使用 contribute 扩展快速找到要在开源项目中处理的问题。这会找到在过去一年中创建的问题<code>help wanted</code>或<code>good first issue</code>标签，并且还没有关联的拉取请求。</p><p class="ztext-empty-paragraph"><br></p><h3><b><code><a href="https://github.com/samcoe/gh-triage" target="_blank">gh triage</a></code></b></h3><p data-pid="RdrNnyX-">我们的分类扩展采用我们的流程来分类我们开源存储库中的问题，并使其更广泛地可用。与其直接使用它，您可能会从中获得灵感来构建您自己的更具体到您的项目流程的分类扩展。</p><p class="ztext-empty-paragraph"><br></p><h3><b>更新扩展</b></h3><p data-pid="UmnWosD8">若要更新扩展，请使用 <code>extensions upgrade</code> 子命令。 将 <code>extension</code> 参数替换为扩展的名称。</p><div class="highlight"><pre><code class="language-text"> gh extension upgrade extension</code></pre></div><p data-pid="UlIM3eJp">若要更新所有已安装的扩展，请使用 <code>--all</code> 标志。</p><div class="highlight"><pre><code class="language-text"> gh extension upgrade --all</code></pre></div><p class="ztext-empty-paragraph"><br></p><h3><b>卸载扩展</b></h3><p data-pid="CuahpphV">若要卸载扩展，请使用 <code>extensions remove</code> 子命令。 将 <code>extension</code> 参数替换为扩展的名称。</p><div class="highlight"><pre><code class="language-text"> gh extension remove extension</code></pre></div><p class="ztext-empty-paragraph"><br></p><h3><b>alias 设置别名</b></h3><p data-pid="oHhLnlDo">为通常运行的命令定义别名。 例如，如果运行 <code>gh alias set prd "pr create --draft"</code>，则你可以运行 <code>gh prd</code> 以快速打开草稿拉取请求。 </p><p></p></div> </details> 
 <hr /> 

 #### - [项目管理从理论到实践（含GitHub Projects）](https://zhuanlan.zhihu.com/p/598930020) 
 <details><summary>توضیحات</summary> <p><img src="https://picx.zhimg.com/v2-50f4db50cfde4410ecd2cfb1ea36cbed_720w.jpg?source=d16d100b"></p><div><h2><b>项目管理从理论到实践</b></h2><p data-pid="_eQ-g0vW"><b>理论介绍</b></p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic2.zhimg.com/v2-9e96b6439d52b9594e76ef518e19e2c9_r.jpg" data-caption="" data-size="normal" width="1191" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p data-pid="WaJIcQuk"><b>瀑布模型：</b></p><figure data-size="normal"><img src="https://pic3.zhimg.com/v2-d0ba861494814f300610308dc02f73f6_r.jpg" data-caption="" data-size="normal" width="2060" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><p data-pid="XP3zktsc"><b>敏捷模型：</b></p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic3.zhimg.com/v2-d411ae01abca75593965175fdca926ba_r.jpg" data-caption="" data-size="normal" width="2060" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><p data-pid="mVgA3sde"><b>Scrum框架：</b></p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic2.zhimg.com/v2-c30d75e856918b4e0c04ea91defb1f29_r.jpg" data-caption="" data-size="normal" width="2060" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>传统和敏捷差异</b></h3><p data-pid="8D4l_AwG"><b>传统项目管理方法通常按照线性流程进行，通过预先制定的计划、监督和控制来实现项目目标。敏捷项目管理方法则更加灵活，通过迭代和持续的改进来实现项目目标。敏捷方法强调团队合作、适应变化、快速交付价值。</b></p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic4.zhimg.com/v2-23c171ef612a5b7769a69c3aeb36b5c7_r.jpg" data-caption="" data-size="normal" width="2060" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>项目管理十大知识领域</b></h3><p data-pid="J3Q3Ab9m">项目管理的十大知识领域包括：</p><ol><li data-pid="oubR4wD0">项目范围管理：确定项目的目标和边界，并确保项目在进行过程中不会超出这些范围。</li><li data-pid="Fn0O7XVP">项目时间管理：确定项目的时间计划，并确保项目按时完成。</li><li data-pid="hPGEfVEV">项目成本管理：确定项目的预算，并确保项目在预算范围内完成。</li><li data-pid="JVcP1Fld">项目质量管理：确保项目产品、服务或结果符合质量标准。</li><li data-pid="4r3_98Ld">项目资源管理：确定项目所需的人员、设备和材料，并确保这些资源得到有效利用。</li><li data-pid="VZMYAHy-">项目沟通管理：确定项目的信息需求，并确保项目信息得到有效传递。</li><li data-pid="btfPu2it">项目风险管理：识别、评估和应对项目中的风险。</li><li data-pid="SXkMilep">项目采购管理：确定项目所需的外部产品、服务或结果，并确保这些外部要素得到有效管理。</li><li data-pid="uAEN0u1G">项目合同管理：管理项目中的合同，包括签订合同、监督合同履行和结束合同。 </li><li data-pid="HyeXDDjI">项目结项管理: 记录项目成果，并对项目进行评估，以确定未来项目的改进点。</li></ol><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic1.zhimg.com/v2-90019ac0ae39aa879f32b1b0e97c6b40_r.jpg" data-caption="" data-size="normal" width="2060" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic3.zhimg.com/v2-e74bba45fec0070352370a01cca77332_r.jpg" data-caption="" data-size="normal" width="2060" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>项目管理的五大过程组</b></h3><p data-pid="6rn1PMXe">项目管理的五大过程组是：</p><ol><li data-pid="D6ClWfAX">开始过程组：在项目启动之前进行的活动，包括项目的范围、目标、预算和资源的确定。</li><li data-pid="BBBO2l4n">规划过程组：为项目的成功制定计划，包括项目时间、成本、质量、资源、沟通、风险、采购和合同管理计划。 </li><li data-pid="qYTfpaNq">执行过程组：将计划转化为具体行动，通过项目团队的协作来完成项目的任务。 </li><li data-pid="1cC4XFCd">监控和控制过程组：监督项目的进展，并对变化做出反应，以确保项目按照计划完成。</li><li data-pid="QI_bJerJ">关闭过程组：完成项目并归档项目文件。</li></ol><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic1.zhimg.com/v2-c1420e1da48e461451dc58dc2b9cbb34_r.jpg" data-caption="" data-size="normal" width="2060" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p data-pid="Ezdv3iuN"><b>监控负责产品项目的整个生命周期。</b></p><p class="ztext-empty-paragraph"><br></p><h2><b>启动：项目如何高效启动</b></h2><h3><b>项目启动</b></h3><p data-pid="RRwXTA1F">上面我们看到项目管理的五大过程：启动、规划、执行、监控和收尾，毫无疑问的是，如何高效启动项目的重要性不容置疑~</p><p data-pid="mL29iMqv"><b>先看一下贯穿始终的一个表：</b></p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic3.zhimg.com/v2-975892a387cf6a8c1a09437056307d1e_r.jpg" data-caption="" data-size="normal" width="2060" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><p data-pid="WoxNLNzk"><b>我们针对启动过程中的两个关键过程：</b></p><ol><li data-pid="IKrZoUvO">制定项目章程</li><li data-pid="PuzeIQ50">识别干系人</li></ol><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic2.zhimg.com/v2-a2e91d1fcc078a0290c9ba79777150d9_r.jpg" data-caption="" data-size="normal" width="2060" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>应用</b></h3><p data-pid="9fAhQCz1"><b>⚠️ 项目启动阶段应该要做的事情包括：</b></p><ol><li data-pid="n_ECyANT">确定项目目标：明确项目的目的、范围和成果，确保项目与组织的战略目标一致。</li><li data-pid="9PLzTz9n">组建项目团队：确定项目团队的成员，并建立合适的团队沟通和协作结构。</li><li data-pid="ki9ymeRH">制定项目章程：明确项目的责任和权限，并制定项目章程，确保项目运作有序。</li><li data-pid="SkFKsjOO">确定项目预算：根据项目的范围和目标制定项目预算，并确定项目的资金来源。</li><li data-pid="UZ5_oBzG">确定项目时间表：根据项目的范围和目标制定项目时间表，并确定项目的里程碑。</li><li data-pid="_2zvSgeG">评估风险: 评估项目中可能存在的风险，并制定风险应对策略。</li><li data-pid="qewki0Wm">获取资源: 确定项目所需的人员、设备和材料，并获取这些资源。</li><li data-pid="hu8MT8q7">审批启动文件: 审批并签署项目启动文件,确保项目有了正式的许可开始进行.</li><li data-pid="3kw0esac">沟通计划：制定项目沟通计划，确保项目中的信息得到有效传递。</li><li data-pid="AwBJiXHL">合同管理：管理项目中的合同，包括签订合同、监督合同履行和结束合同。</li><li data-pid="aztr5knc">项目管理计划：制定项目管理计划，确保项目管理过程有序、高效。</li><li data-pid="xxjZrcQI">开始执行项目：根据项目管理计划和项目章程开始项目执行。</li><li data-pid="3CVffLeD">持续监控项目的进展,进行调整和控制，确保项目按计划进行。</li></ol><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic2.zhimg.com/v2-e1ba074c18ca24e3baa7892c747c5189_r.jpg" data-caption="" data-size="normal" width="2060" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>定事</b></h3><p data-pid="sqWm-upW"><b> 简单的一个案例如下：</b></p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic3.zhimg.com/v2-134c6e2b034fca3334311fbe14ce93f2_r.jpg" data-caption="" data-size="normal" width="2060" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>定人</b></h3><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic3.zhimg.com/v2-5da3586c0e69e6926713982c9fa9bf1a_r.jpg" data-caption="" data-size="normal" width="2060" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic1.zhimg.com/v2-7543bfa1cdb7fbf6dcef9f46e88bab20_r.jpg" data-caption="" data-size="normal" width="2060" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><p data-pid="mc7L8G88"><b> 简单的一个案例如下：</b></p><figure data-size="normal"><img src="https://pic4.zhimg.com/v2-5b443eec3a5f1fca63a1a8604f9ef283_r.jpg" data-caption="" data-size="normal" width="2060" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>概念认证（POC）</b></h3><ul><li data-pid="MJlqqy11"><a href="https://zh.wikipedia.org/zh-cn/%E6%A6%82%E5%BF%B5%E9%AA%8C%E8%AF%81" target="_blank">中文维基百科~</a></li></ul><p data-pid="APV9vVHP"><b>概念验证</b>（英语：Proof of concept，简称POC）是对某些想法的一个较短而不完整的实现，以证明其<a href="https://zh.wikipedia.org/w/index.php?title=%E5%8F%AF%E8%A1%8C%E6%80%A7&amp;action=edit&amp;redlink=1" target="_blank">可行性</a>，示范其<a href="https://zh.wikipedia.org/wiki/%E5%8E%9F%E7%90%86" target="_blank">原理</a>，其目的是为了验证一些概念或理论。概念验证通常被认为是一个有里程碑意义的实现的原型 。</p><p data-pid="CC6pzRfI">在项目生命周期中，POC 通常出现在项目的规划阶段或开始阶段。 在项目的规划阶段中，POC 可用于评估新技术的可行性和成本效益，以确定是否在项目中使用。 如果 POC 结果表明新技术是可行的并符合项目需求，那么就可以在项目的开始阶段中进行更全面的实施。</p><p data-pid="cgOqSpbi">POC 可以帮助项目团队确定新技术是否符合公司的需求，并能够在实际应用中取得成功，在项目规划阶段和开始阶段能够更好地评估技术可行性和成本效益。</p><blockquote data-pid="dr8l5Xab"><b>极简抖音 POC 概念验证：</b></blockquote><ol><li data-pid="EQTVXaUZ">需求分析：分析极简版抖音应用的用户需求，确定应用的功能和性能要求。</li><li data-pid="D1P-lrnE">技术选型：选择适合应用开发的技术，如语言，框架等</li><li data-pid="2QdjtogG">制定原型：根据需求分析和技术选型制定应用的原型，确定应用的界面和交互方式。</li><li data-pid="54f2G3iZ">构建 POC：根据原型进行 POC 的开发，确保应用能够满足用户需求和性能要求。</li><li data-pid="X2OpVyTN">测试验证：对 POC 进行测试，验证应用的功能和性能是否符合要求。</li><li data-pid="FxhjWCYk">评估结果：评估 POC 的结果，确定是否继续开发该应用。</li><li data-pid="8GgbHDqW">文件记录：将 POC 的过程和结果记录下来，以便将来参考。</li><li data-pid="daA6EJWX">优化计划：如果 POC 结果是可行的，制定完善应用的计划，确定实际开发的任务和进度。</li><li data-pid="cokV_4bZ">执行计划：按照计划进行项目的执行，使用 POC 的结果作为基础。</li><li data-pid="RihZ4Stl">持续监控和管理：在项目实施过程中持续监控和管理项目的进度和质量，及时调整和控制项目。</li><li data-pid="Ufnfv6NY">项目结束：完成项目并归档项目文件。</li><li data-pid="nBXNDobG">反馈和改进：根据项目结束后的反馈结果，对项目进行改进，并记录下来以便以后参考。</li></ol><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h2><b>规划：项目规划如何制定</b></h2><p data-pid="UWQ15VuK">项目规划是项目管理中的重要环节，它是项目成功的关键。制定项目规划需要遵循以下步骤：</p><ol><li data-pid="Tm2HatXq">明确项目目标: 首先需要明确项目的目标和成功标准，并将其转化为具体的项目目标。</li><li data-pid="JR6T9iep">分析项目需求: 通过与相关人员进行沟通和协商，确定项目需要完成的任务和交付物。</li><li data-pid="67HTlkkd">制定项目计划: 根据项目目标和需求，制定项目计划，包括项目进度、费用、资源和风险管理等。</li><li data-pid="RPCp8Wao">制定项目文件: 根据项目计划，制定项目文件，如项目章程、说明书、项目管理计划等。</li><li data-pid="7Ex4i3TA">执行项目计划: 按照项目计划和文件执行项目，并不断监控项目进度和绩效。</li><li data-pid="owEZwdLN">更新项目计划: 随着项目进展，可能需要对项目计划进行更新和调整。</li><li data-pid="XvFq7sJN">风险管理: 在项目进行过程中，需要对项目的风险进行识别、评估和应对。这包括对项目所面临的各种可能风险进行识别、对风险的影响进行评估、制定风险应对策略和实施风险应对措施。</li><li data-pid="eyc_Lseu">沟通管理: 项目沟通管理是项目管理中重要的环节之一。在项目进行过程中，需要建立有效的沟通机制，确保项目相关人员之间的信息沟通和协调。</li><li data-pid="3NDv2LKj">监控与控制: 按照项目计划和文件进行项目监控和控制。包括对项目进度、质量、费用、风险等进行监控和控制。</li><li data-pid="qciAqZUB">项目结束: 当项目完成后，需要进行项目结束检查，对项目进行评估，并对项目进行总结。这将有助于改进未来项目管理的效率和质量。</li></ol><p class="ztext-empty-paragraph"><br></p><h3><b>规划管理</b></h3><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic4.zhimg.com/v2-33f6fe72b84e69c1fd304c650f258b5f_r.jpg" data-caption="" data-size="normal" width="2060" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>创建 WBS</b></h3><ul><li data-pid="Ovwfnxuj"><a href="https://zh.wikipedia.org/zh-cn/%E5%B7%A5%E4%BD%9C%E5%88%86%E8%A7%A3%E7%BB%93%E6%9E%84" target="_blank">WBS 维基百科-ZH</a></li></ul><p data-pid="fJ7yXSTW">WBS (Work Breakdown Structure) 意为工作分解结构。它是一种组织和管理项目任务的工具，通过将项目的总体目标划分成较小的、可管理的部分来帮助项目组织者更好地控制项目的进度和质量。</p><p data-pid="nIiE6Pcn">WBS通常以树状结构的形式组织，顶层是项目的总体目标，下面是分解出来的各个子任务，以此类推。每一层的任务都是上一层任务的细分。这样做的目的是为了确保每一个子任务都能够独立完成，而且也能够追踪项目的总体进度。</p><p data-pid="HDAvaEod">WBS可以帮助项目组织者更好地掌握项目的范围、进度和风险，并且可以用来确定项目的资源需求和安排任务。</p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic3.zhimg.com/v2-210b96160212238c280ba13e198985d6_r.jpg" data-caption="" data-size="normal" width="2060" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>规划管理图</b></h3><p data-pid="qnUV8Gap"><b>项目规划图可以统计出项目开发周期，一目了然~</b></p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic3.zhimg.com/v2-bedaa9ac398804469a68c2393f505a86_r.jpg" data-caption="" data-size="normal" width="2060" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>甘特图</b></h3><p data-pid="4NBAP1hd">甘特图(Gantt chart) 是一种项目管理工具，用来表示项目的进度和资源分配。它是一种图形化的工具，通常由水平的时间轴和垂直的任务条组成。</p><p data-pid="K6dcwO5N">在甘特图上，每个任务都对应一个水平的条形图，表示任务的开始时间和结束时间。通过看甘特图，可以很容易地了解项目的进度、任务之间的依赖关系和资源分配情况。</p><p data-pid="Q-oJV9VP">甘特图可以帮助项目组织者更好地掌握项目进度，调整项目计划，更好地控制项目进度和资源分配。同时也可以让项目的其他成员更好的了解项目的进展情况。</p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic3.zhimg.com/v2-e20a27e56928310289768139d330379e_r.jpg" data-caption="" data-size="normal" width="2060" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>核心步骤</b></h3><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic3.zhimg.com/v2-8957ed0b17050a3c13b94e778c4b7092_r.jpg" data-caption="" data-size="normal" width="2060" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>规划管理-案例分析</b></h3><p data-pid="tvZt4umW"><b>[[MVP版本]]：</b></p><blockquote data-pid="C6QZKLPN">MVP的概念是Eric Ries 《精益创业》里提出的概念。简单地说，就是指开发团队通过提供<b>最小化可行产品</b>获取用户反馈，并在这个最小化可行产品上<b>持续快速迭代</b>，直到产品<b>到达一个相对稳定的阶段</b>。MVP对于创业团队来说是很重要的，可以快速验证团队的目标，快速试错。</blockquote><p data-pid="G4ni12kJ"><b>项目背景：</b> 随着公司战略发展需要，A业务必须立项重点项目</p><p data-pid="4WPAnTbC"><b>项目内容：</b> 是基于xx公司现有能力，开发一款新的APP在新的国家市场发布。</p><p data-pid="WajQzwCU"><b>项目目标：</b> 5个月完成MVP版本APP开发</p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic2.zhimg.com/v2-4f811beea96b4a57cdc0ea05dd995e21_r.jpg" data-caption="" data-size="normal" width="2060" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p data-pid="T345zurX"><b>一些名词：</b></p><ul><li data-pid="zMKEIcZL">自测[[case]] (Self-Testing Case) 指的是在软件开发过程中，由开发人员自己制定和执行的测试用例。<br></li><ul><li data-pid="Cl63NmCP">自测case 是一种非常重要的质量保证手段，它可以帮助开发人员更早期地发现和修复软件中的错误和缺陷。自测case 通常包括了功能测试、性能测试、可靠性测试和兼容性测试等。</li><li data-pid="Wfi4gymF">自测case 可以帮助开发人员确保软件的质量和可靠性，提高软件的开发效率和降低软件的维护成本。同时也可以帮助确保软件在发布前满足用户需求。</li></ul></ul><p class="ztext-empty-paragraph"><br></p><ul><li data-pid="dMYvk3p6">[[QA]] 指质量保证 (Quality Assurance)，它是一种系统性的、预防性的过程，旨在确保产品或服务达到质量标准。<br></li><ul><li data-pid="48vdEW3n">QA 的目的是通过规范、程序、标准和测试等手段来确保产品或服务达到预期的质量水平。QA 的过程包括了质量策划、质量控制、质量保证和质量改进等。</li><li data-pid="aQMjSVa-">QA 的过程可以帮助企业或组织提高产品和服务的质量，满足客户需求，提高市场竞争力和品牌形象。QA 也可以帮助企业或组织降低不良产品的生产和服务的成本，提高生产效率和客户满意度。</li></ul></ul><p class="ztext-empty-paragraph"><br></p><ul><li data-pid="mOD4XiQo">[[RD]] 指的是研发 (Research and Development)，即研究与开发。研发是指企业或组织对于产品、服务、技术等进行研究和开发，以提高其竞争力和创新能力。研发包括了新产品研发、技术改进、新工艺开发等。<br></li><ul><li data-pid="azU9tFRA">研发可以帮助企业或组织推出新产品和服务，提高产品质量和性能，满足市场需求并增加市场份额，提高生产效率和降低生产成本，提高技术水平和竞争力。研发也是企业或组织的重要投资，因为它可以带来长期的经济效益。</li></ul></ul><p class="ztext-empty-paragraph"><br></p><ul><li data-pid="ZUsIvNja">[[Review]] 指的是代码审查或代码评审。它是一种质量保证和改进的重要手段，目的在于通过其他人员对代码的审查和评估来发现和纠正代码中的错误、缺陷和潜在问题<br></li><ul><li data-pid="fd9Ps6q0">代码评审可以帮助确保代码质量，提高代码的可读性、可维护性和可扩展性，降低软件维护成本和风险。</li><li data-pid="AargmLzL">一般来说，代码评审可以通过人工或工具来完成，人工评审通常由一个或多个开发人员来完成，而工具评审则使用自动化工具来完成，这些工具可以扫描代码并发现潜在问题。</li></ul></ul><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic1.zhimg.com/v2-77a80c12b1b44780b46743050a47df5c_r.jpg" data-caption="" data-size="normal" width="2060" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>经验总结</b></h3><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic3.zhimg.com/v2-43db227de9ae8a94710273be5d5da8e6_r.jpg" data-caption="" data-size="normal" width="2060" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h2><b>执行：执行如何高效跟进</b></h2><p data-pid="Vrmw2SGH"><b>需要保证执行得高效跟进的时候，注意以下的方面：</b></p><ol><li data-pid="DzgmTFIK">设立清晰的目标和计划: 首先需要确立项目的目标和计划，并且确保所有相关人员都了解并按照这些目标和计划来工作。</li><li data-pid="Q_0Wfa-4">建立有效的沟通机制: 通过建立有效的沟通机制，确保项目相关人员之间的信息沟通和协调，及时发现并解决问题。</li><li data-pid="ouj_Sl9R">定期跟进和报告: 设立定期跟进和报告机制，对项目进度、质量、费用、风险等进行监控和控制。</li><li data-pid="bG5NoHEC">敏捷管理: 通过使用敏捷管理方法，可以更快速地做出反应，并且能够应对项目中出现的变化。</li><li data-pid="tivST9dF">组织团队培训: 定期举行团队培训，帮助团队成员提高技能和知识，提高团队合作和协作能力。</li><li data-pid="T5BHGZUS">整体考虑: 整体考虑项目中所有相关因素，包括人员、资金、技术等，确保项目能够顺利完成。</li></ol><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic1.zhimg.com/v2-edf9ea0ff528175327f812ba30686b9c_r.jpg" data-caption="" data-size="normal" width="1771" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>会议制度宣贯</b></h3><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic1.zhimg.com/v2-21882dbb3034c0d46ca14cd1c331d540_r.jpg" data-caption="" data-size="normal" width="2060" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p data-pid="7376x_tM"><b>会议的时间很重要，不要浪费别人的时间，如果可以单独会议解决没必要集体开会。</b></p><p data-pid="y8G0WQkE">会议前指定模板和计划：</p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic2.zhimg.com/v2-44c5226d8df9350f4b9bc58bd9ae6a21_r.jpg" data-caption="" data-size="normal" width="2060" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>进度确认的四个步骤</b></h3><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic1.zhimg.com/v2-d62e99aae5351474567410abbd73e63c_r.jpg" data-caption="" data-size="normal" width="2060" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>会议中有效引导</b></h3><p data-pid="trFKKwe7"><b>在开源社区中，我常见到两种的会议引导手段，一种是 GitHub Dicussions 中指定会议的 issue 和 解决方案。第二种是 Google Docs、nothon或者是飞书文档的协同写入会议摘要和计划。</b></p><p data-pid="-OZvKfzJ"><b>我们应该注意：</b></p><ol><li data-pid="2PLucRUt">清晰的议题:  在会议前，确定好会议的议题和目的，并确保所有参与者都了解。</li><li data-pid="ezSr5ecb">准备充分:  在会议中，提前准备好会议材料和文件，为参与者提供有用的信息。</li><li data-pid="NJrZkylK">控制时间:  严格控制会议时间，确保会议在规定时间内结束。</li><li data-pid="zYpbG1ke">引导讨论:  通过问题和练习来引导讨论，让参与者发表观点并解决问题。</li><li data-pid="GUk9NTVR">进行反馈:  定期进行反馈，确保会议的目标和计划得到实现。</li><li data-pid="v6xKGuTT">记录决策:  记录会议中的决策和行动计划，确保所有参与者都了解并遵循。</li><li data-pid="SgZR3YOI">提高参与度：通过提问、提供机会发言、鼓励参与等方式提高参与者的参与度。</li></ol><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic3.zhimg.com/v2-316a2489ba21e758928c0201ed47dabe_r.jpg" data-caption="" data-size="normal" width="2060" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>会议后</b></h3><p data-pid="vTqtbctN"><b>会议结束后，需要发送会议纪要，其中包括:</b></p><ol><li data-pid="NQ2mFIH9">会议议题: 概述会议的主要议题和目的。</li><li data-pid="fvQpYBJk">会议纪要: 详细记录会议中的讨论和决策。</li><li data-pid="AiIRDeUU">行动计划: 列出会议中达成的行动计划和下一步工作。</li><li data-pid="SohHgm3L">截止日期: 设定行动计划完成的截止日期。</li><li data-pid="eHW9O30-">责任人: 分配责任人负责完成行动计划。</li><li data-pid="SwJ07RY2">跟进: 指定责任人负责跟进行动计划的执行。</li></ol><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic1.zhimg.com/v2-711e431c17f820301ee8ae8e5220bd64_r.jpg" data-caption="" data-size="normal" width="2060" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><p data-pid="Q0hHWv4J"><b>  以下是一个会议纪要模板：</b></p><p data-pid="q5cwgw1z">会议主题: [会议主题]</p><p data-pid="G6LSlkqc">会议日期: [会议日期]</p><p data-pid="QH_UUzI6">会议地点: [会议地点]</p><p data-pid="YRixQPf7">参会人员: [参会人员名单]</p><p data-pid="_cx6GXoG">会议议题:</p><ul><li data-pid="s2FVieZA">[议题 1]</li><li data-pid="Hp4nIyHi">[议题 2]</li><li data-pid="HyMYwLgv">[议题 3]</li></ul><p data-pid="k5XnGBJj">会议纪要:</p><ul><li data-pid="tLTajLgY">[议题 1]<br></li><ul><li data-pid="aOp0UzvT">[讨论结果]</li><li data-pid="bfADoB5F">[决策]</li></ul></ul><p class="ztext-empty-paragraph"><br></p><ul><li data-pid="pMon2YJj">[议题 2]<br></li><ul><li data-pid="eSiqrKCs">[讨论结果]</li><li data-pid="a0bdcF0E">[决策]</li></ul></ul><p class="ztext-empty-paragraph"><br></p><ul><li data-pid="DMUNFxkz">[议题 3]<br></li><ul><li data-pid="Fo7nsnKZ">[讨论结果]</li><li data-pid="2OpZRZlt">[决策]</li></ul></ul><p class="ztext-empty-paragraph"><br></p><p data-pid="4xFUG7aG">行动计划:</p><ul><li data-pid="Iczdkx4e">[任务 1]<br></li><ul><li data-pid="HsS6JaQW">[具体描述]</li><li data-pid="UFy3z4se">[责任人]</li><li data-pid="CLLlhno9">[截止日期]</li></ul></ul><p class="ztext-empty-paragraph"><br></p><ul><li data-pid="RYyDccqF">[任务 2]<br></li><ul><li data-pid="flAg0JPp">[具体描述]</li><li data-pid="PtdBZfJ3">[责任人]</li><li data-pid="LRy5089G">[截止日期]</li></ul></ul><p class="ztext-empty-paragraph"><br></p><ul><li data-pid="8VAbhAvo">[任务 3]<br></li><ul><li data-pid="GiMcyYU6">[具体描述]</li><li data-pid="O2FMAl1D">[责任人]</li><li data-pid="cIPBllqo">[截止日期]</li></ul></ul><p class="ztext-empty-paragraph"><br></p><p data-pid="mZF94THH">下一步工作:</p><ul><li data-pid="3TIXOXf1">[工作 1]</li><li data-pid="QhNyTc4h">[工作 2]</li><li data-pid="21P9Ew7W">[工作 3]</li></ul><p data-pid="v45uiHPj">会议结束时间: [会议结束时间]</p><p data-pid="c100F7eE">下次会议时间: [下次会议时间]</p><p data-pid="hvm2E4Xc">纪要撰写人: [纪要撰写人]</p><p data-pid="dr6_ru1C">联系方式: [联系方式]</p><p data-pid="c8chaFSF">请在[截止日期]前完成[行动计划]，并在下次会议中汇报进展。</p><p data-pid="VQBe54_K">会议纪要应该在会议结束后尽快发送给所有参会人员，以便他们能够了解会议的进展和结果，并确保他们能够按照行动计划的要求完成他们的工作。</p><p data-pid="gCF58vpE">除此之外，在下次会议之前，需要确保所有的行动计划已经完成，并且在会议中进行汇报。如果有任何问题或延迟，应该尽早报告给项目经理。</p><p class="ztext-empty-paragraph"><br></p><h3><b>节奏对齐</b></h3><p data-pid="A3is_010"><b>[[OKR]]：</b></p><blockquote data-pid="HuTFFItt">OKR (Objectives and Key Results) 是一种目标管理方法，是一种组织中定义目标和指标，并实现目标的过程。<br>它包括两部分：</blockquote><ol><li data-pid="PIviOZZf">Objectives (目标)：目标是组织想要实现的结果，它应该是明确的、具体的、可衡量的、具有挑战性的。</li><li data-pid="SdQryTFl">Key Results (关键结果)：关键结果是实现目标所需要达成的具体指标，它应该是可衡量的，并且可以通过某种方式来跟踪和评估。</li></ol><p data-pid="pM9kXuXf">OKR 的目的是帮助组织更好地管理目标和结果，并通过持续跟踪和评估来实现目标。OKR 能够帮助组织更好地管理目标和结果，更好地控制项目进度，并且更好地评估项目的成效。OKR 方法通常被用于企业级目标管理，并且在不同的公司和组织中有着不同的实施方式。<br>OKR 的优点是它能够帮助组织更好地定位和跟踪目标，并且能够更好地评估项目成效。OKR 方法还能帮助组织更好地沟通和协调，并且能够提高项目团队的积极性和绩效。<br>但是，如果OKR 不被认真执行或者没有得到正确的支持，它可能会导致项目偏差或者失败。所以在实施OKR时需要确保有一个好的管理团队来组织和监督实施过程，确保所有目标和关键结果都是合理的并且能够得到有效的跟踪和评估。此外，还需要确保所有员工和团队都能够理解和支持OKR 的目标和方法，确保OKR能够得到有效的落实。</p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic3.zhimg.com/v2-9a2aa80b87a766e3a9c605b12435bbaa_r.jpg" data-caption="" data-size="normal" width="2060" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>君子约定</b></h3><p data-pid="d7Rn4Pth">"君子约定" 是指在项目管理中，项目参与者之间约定好的规则和准则。这些规则和准则可以帮助确保项目的顺利进行，并确保项目成员之间的沟通和合作是有效的。</p><p data-pid="ToKVVxlU">君子约定可以包括以下内容：</p><ul><li data-pid="dAuOK7QO">项目目标和预期结果</li><li data-pid="ddIqgou6">项目进度和进展报告</li><li data-pid="Csme-YNz">任务和责任分配</li><li data-pid="pbwuoUBx">风险管理和问题解决</li><li data-pid="baRFBkUp">通信计划和沟通渠道</li><li data-pid="qWbm7F8c">项目成员之间的行为准则</li></ul><p data-pid="xPKPK--i">重要的是要确保所有项目成员都遵循君子约定，并确保这些约定是有效的，可以帮助项目顺利完成。</p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic2.zhimg.com/v2-16ef222f4dab0cc65158f2f76f1ec03d_r.jpg" data-caption="" data-size="normal" width="2060" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>跨团队协作解决问题</b></h3><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic4.zhimg.com/v2-f137b59115ea8519da86e4039fd12eef_r.jpg" data-caption="" data-size="normal" width="2060" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><p data-pid="5P59Z74R"><b>打开边界：</b></p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic4.zhimg.com/v2-3b464036ae3291993b0cd663dd889423_r.jpg" data-caption="" data-size="normal" width="2060" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h2><b>执行：如何拥抱变化</b></h2><p data-pid="tWGd8zLx">  <b>永远不变的是变化本身。正视变化，用积极的心态面对。</b></p><p data-pid="gliiSAL7">项目管理中执行阶段是指将项目计划转化为实际行动的过程。在这个阶段，项目经理需要确保项目团队正确地执行项目计划，并管理项目的进度和进展。</p><p data-pid="GhvUboZs">拥抱变化是在执行阶段非常重要的一点，因为项目的进展往往会受到各种因素的影响，导致计划发生变化。</p><p data-pid="1vLbKfyO">为了拥抱变化，项目经理可以采取以下步骤：</p><ol><li data-pid="mMTrtK3R">建立一个弹性的计划: 项目经理应该建立一个弹性的计划，而不是一个固定不变的计划，这样可以应对变化。</li><li data-pid="Tw8rC0-Y">建立一个风险管理计划: 项目经理应该评估项目中可能出现的风险，并建立一个有效的风险管理计划。</li><li data-pid="yLa5UjiE">经常监控项目进展: 项目经理应该经常监控项目进展，及时发现问题并采取措施。</li><li data-pid="LvtUE2Cw">保持开放的沟通: 项目经理应该保持开放的沟通，让项目团队和其他相关人员都能参与到项目中来。</li><li data-pid="qAqPxRUk">快速反应: 项目经理应该能够快速反应并采取行动，以应对变化。</li></ol><p data-pid="8nVphAP8">通过这些步骤，项目经理可以帮助项目团队更好地适应变化，并使项目能够顺利完成。</p><p data-pid="GCyiPpzy">另外，项目经理也应该培养团队成员的灵活性和适应性。这可以通过在项目中提供培训和支持，以帮助团队成员学会应对变化，并在变化中找到机会。</p><p data-pid="aMw96sDx">总而言之，拥抱变化是项目管理中非常重要的一点，项目经理需要采取有效的步骤来应对变化，帮助项目顺利完成。</p><p class="ztext-empty-paragraph"><br></p><h3><b>变更的类型</b></h3><p data-pid="_LIGbQMo">常见的变更类型包括：</p><ol><li data-pid="lCL2ZWtC">范围变更：对项目范围的修改，包括增加或删除项目任务。</li><li data-pid="sWA2PGEg">时间变更：对项目时间表的修改，包括项目开始和结束时间的调整。</li><li data-pid="TJ6UM6UA">成本变更：对项目预算的修改，包括增加或减少项目成本。</li><li data-pid="p6QzQ5A4">质量变更：对项目质量标准的修改。</li><li data-pid="kpgINXhI">人员变更：对项目团队成员的修改，包括增加或删除团队成员。</li><li data-pid="dHSqe6L7">沟通变更：对项目沟通计划的修改。</li></ol><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic2.zhimg.com/v2-2a9a48d53c310d5b12fee5493608218d_r.jpg" data-caption="" data-size="normal" width="2060" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>接收或者拒绝变更方法</b></h3><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic2.zhimg.com/v2-701565a3dc79aa978b0c16a13bca26cd_r.jpg" data-caption="" data-size="normal" width="2060" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>整体变更控制</b></h3><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic1.zhimg.com/v2-914cf187f0d76f9c5156dbe35e4006e4_r.jpg" data-caption="" data-size="normal" width="2060" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>如何拥抱变更</b></h3><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic2.zhimg.com/v2-63014321b010a428580d5b8f8bc2c14d_r.jpg" data-caption="" data-size="normal" width="2060" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>预防</b></h3><p data-pid="RxPOcAn1"><b>预防变更的措施包括:</b></p><ol><li data-pid="YFM71mb8">建立一个弹性的计划: 项目经理应该建立一个弹性的计划，而不是一个固定不变的计划，这样可以应对变化。</li><li data-pid="Wb3RjfID">建立一个风险管理计划: 项目经理应该评估项目中可能出现的风险，并建立一个有效的风险管理计划。</li><li data-pid="OL9M7I3C">经常监控项目进展: 项目经理应该经常监控项目进展，及时发现问题并采取措施。</li></ol><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic3.zhimg.com/v2-9c507c7a69c3354aaed4cf51c1f1c98e_r.jpg" data-caption="" data-size="normal" width="2060" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>应对</b></h3><p data-pid="efuMqp5p"><b>应对变更的措施包括:</b></p><ol><li data-pid="W1SvcYqb">变更控制程序: 项目经理应该建立一个变更控制程序，以确保变更得到正确的审批和管理。</li><li data-pid="jtTuYK6r">调整计划: 项目经理应该能够调整计划，以适应变更。</li><li data-pid="cDxXS8ix">协调团队: 项目经理应该协调团队，以确保变更得到正确的实施。</li><li data-pid="vXZUKJ_J">沟通: 项目经理应该沟通变更的影响，确保所有相关方都能理解并支持变更。</li></ol><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic1.zhimg.com/v2-950ed309a68c693a96da965a3dfd7874_r.jpg" data-caption="" data-size="normal" width="2060" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>四种变更工具</b></h3><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic3.zhimg.com/v2-4671468f4912a2018880b770b5f622e6_r.jpg" data-caption="" data-size="normal" width="2060" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h2><b>监控：如何识别和应对风险</b></h2><p data-pid="scw3TNz4">  <b>风险是可测定的不确定性。</b></p><p data-pid="dJWRM0CQ"><b>我们在上面看到，监控是贯穿于整个项目的生命周期的。</b></p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic2.zhimg.com/v2-50d95b0897aa8f8aa5ce3566ba5d5205_r.jpg" data-caption="" data-size="normal" width="1999" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>风险管理方法</b></h3><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic1.zhimg.com/v2-27b1e731ba98efa5f7b4d1c91c5cc378_r.jpg" data-caption="" data-size="normal" width="2060" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>风险管理方法：核心</b></h3><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic4.zhimg.com/v2-cf39a79af958c3cf7d7ecf200b435bef_r.jpg" data-caption="" data-size="normal" width="2060" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic3.zhimg.com/v2-238596b2f188ee647aa0da4b1be3611a_r.jpg" data-caption="" data-size="normal" width="2060" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>风险管理实践</b></h3><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic1.zhimg.com/v2-0882d9903cddb68f554db562dc227f5c_r.jpg" data-caption="" data-size="normal" width="2060" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic2.zhimg.com/v2-e0615d9eb69d75621c90a0fce97d93c1_r.jpg" data-caption="" data-size="normal" width="2060" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic2.zhimg.com/v2-91f33ace0cf8208d9acf49db6b2d2e7d_r.jpg" data-caption="" data-size="normal" width="2060" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>监控</b></h3><p data-pid="ITKfDQv5">风险监控和预警是项目管理中的重要组成部分。风险监控是通过定期监测和评估项目的进展来识别新的风险或更新已知风险的过程。风险预警则是在发现新的风险或更新已知风险之后，向相关人员发出警告以便采取纠正措施。</p><p data-pid="kiID3IjZ">通常，风险监控和预警的工具包括：</p><ul><li data-pid="_lfogWTn">风险日报：每天或每周提交的文件，其中记录了新的风险和已知风险的更新</li><li data-pid="r9zs-N7b">风险矩阵：表格，用于跟踪风险的概率和影响</li><li data-pid="oySisF7D">风险跟踪软件：用于自动跟踪和报告风险的软件</li></ul><p data-pid="FVHhFW4l">重要的是，风险监控和预警应该是一个连续的过程，以确保项目管理团队能够及时采取行动来管理风险。</p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic3.zhimg.com/v2-7417e5988d25955d6b5cda2f66cc3046_r.jpg" data-caption="" data-size="normal" width="2060" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>实施和沟通</b></h3><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic1.zhimg.com/v2-84fb881399bf97b76598077ec6565120_r.jpg" data-caption="" data-size="normal" width="2060" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h2><b>GitHub Project</b></h2><ul><li data-pid="OaB1pFBu"><a href="https://github.com/orgs/c-ub/projects/2" target="_blank">cub projects</a></li></ul><h3><b>Project 概述</b></h3><p data-pid="6R4O8E8U">GitHub作为我最常用的网站，其功能也是无穷无尽的。</p><p data-pid="ZyIsYSWb">Projects 是一个适应性强的灵活工具，用于计划和跟踪 GitHub 上的工作。</p><p data-pid="bjSAqVmj">Github 中传统的项目管理是使用 issue 和 pull request 进行的，这部分内容不是本文重点，不再赘述。 但有一些功能需要提及：</p><ol><li data-pid="ta0fi4Go">Tag： 每个 issue 可以添加不同的 tag，可以用于标记 issue 的种类和 issue 的处理进度；</li><li data-pid="umxGmD-O">MileStone：每个 issue 只属于一个 milestone，用于显示 issue 的处理进度。</li></ol><p data-pid="0dlI3J28">Project 提供了真正的管理 issue 的能力；而传统的 tag 方式只能以手工的方式管理分类（如 Q&amp;A，bug，duplicate，feature 这些标签），或者以手工的方式管理 issue 进度（need test, in progress, wait approval 等这些标签）。</p><p class="ztext-empty-paragraph"><br></p><p data-pid="g0No-m7s"><b>你可以选择高密度表布局，也可以使用看板功能。</b></p><p data-pid="iiZ2oiM_">您可以将您的项目视为高密度表布局：</p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic3.zhimg.com/v2-e0ecc55e0039be3bdebbe0e49e6e39b6_r.jpg" data-caption="" data-size="normal" width="2404" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p data-pid="miptZrHx">或作为看板：</p><p class="ztext-empty-paragraph"><br></p> <p class="ztext-empty-paragraph"><br></p><p data-pid="gWgPotJI">为了帮助您专注于项目的特定方面，您可以对项目进行分组、排序或筛选：</p><p class="ztext-empty-paragraph"><br></p> <p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>看板</b></h3><p data-pid="pnP6njWs">看板管理，起源于丰田的生产模式中，指为了达到及时生产（JIT）方式控制现场生产流程的工具。及时生产方式中的拉式（Pull）生产系统可以使信息的流程缩短，并配合定量、固定装货容器等方式，而使生产过程中的物料流动顺畅。</p><p class="ztext-empty-paragraph"><br></p><h3><b>KanbanFlow &amp; Trello</b></h3><p data-pid="xLjM9zb5">可以看出，所谓看板，就是把一块木板上分成几列，然后在每一列上贴上不同内容的卡片。 木板上的这几列一般是有顺序的，卡片可以在不同的列之间移动来表明所处的状态。</p><p data-pid="R2nwSpDn">以上的两个例子，看板并不是针对软件工程的，他们的市场也是一般的企业（比如丰田这样的）。</p><p class="ztext-empty-paragraph"><br></p><h3><b>Zenhub &amp; Github Projects</b></h3><p data-pid="HKWMlZsF">下面的两个例子则是针对软件开发做了优化，准确的说，它们都是对 Github 做了适配。</p><ol><li data-pid="0fTEINuL"><a href="https://chrome.google.com/webstore/search/Zenhub?hl=zh-CN" target="_blank">Zenhub</a> 是个浏览器插件，就是把 Github 的 issues 当作卡片，以 Kanban 的形式展现 issue，也提供了一个比较鸡肋的 Epic 的功能，同时针对个人也有 TODO 项管理。</li><li data-pid="bl76Paf6">而 Github 最近推出的 Project 不仅可以使用 issues 作为卡片，还可以使用Note（左侧的三个），这样我们就没有必要为了在看板上记录可能的需求而创建一个新的 issues 或者把问题记录在个人的 TODO 列表上了。</li></ol><p class="ztext-empty-paragraph"><br></p><h3><b>Github Projects</b></h3><p data-pid="FQtY4Dg0"><b>为什么是 Projects？</b> 一个仓库可以包含多个项目；最初，这个设定让我疑惑，直到使用之后才明白， 一个代码仓库通常有很多事情要做，比如：</p><h3><b>拟定线路图</b></h3><ol><li data-pid="qWi3w4hN">增加一个新功能</li><li data-pid="BTyFdFIa">发布一个新版本</li></ol><p data-pid="4uicKM_I">因此，我们可以为以上每一件事创建一个 Project，由于 Github 中并没有类似 Epic 的机制，因此使用不同的 Project 则很有用了。</p><p data-pid="lTgQbjms">可以看到，有了 Project 的 Kanban 之后，原来 tag 的部分功能（如标记处理进度等）可以被看板替代。 Github Project 提供的 Note 可以在需要的时候单项转换为 issue：</p><p data-pid="Edc29X_n">同时，Kanban 不仅可以包含 issue 和 note，还可以包含 pull request。</p><p data-pid="XX3HVLvF">Github 终于有了比较靠谱的项目管理工具，开源项目的又有了更好的工具。 撒花o(▽)o</p><p data-pid="HotnhU61">祝愿我自己早日完成我的第一个开源项目（IMAP Server）。</p><p class="ztext-empty-paragraph"><br></p><h3><b>实例讲解</b></h3><p data-pid="Nd9WwVwL">GitHub是目前世界上最大的开源中心之一，也有很多人在上面管理自己开放出来的程序代码。内建的Issue功能也非常方便，可以在上面提出需要改进/加强的地方。但对于项目开发的人来说，管理上就比较不方便一点，尤其是在越来越流行使用广告牌方法管理的时代，条列式的Issues就会显得比较杂乱难以管理。也有许多第三方的公司推出与GitHub整合的广告牌功能，但管理上总是会稍微有点不方便，因此GitHub也决定推出了内建的广告牌功能─Projects！让你可以轻松的整合目前的Issues/Pull Requests到广告牌上，虽然广告牌整体功能比较阳春，但基本的功能也都有了，操作方式也与目前流行的广告牌软件功能都类似，且对于GitHub直接整合，实在是方便许多啊！接下来就用我目前自己在做的一个小项目8ComicDownloaderElectron来介绍一下GitHub上的广告牌功能吧！</p><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h2><b>收尾：高效复盘</b></h2><p data-pid="i8_hZU04"><b>项目复盘是在项目结束后进行的一种评估过程，目的是总结项目的成果和教训，并为未来项目做出改进。</b></p><p data-pid="7kUT36NI"><b>项目复盘的步骤包括：</b></p><ol><li data-pid="rrPOWBOG">组织项目复盘会议：将项目团队成员、相关部门经理、项目委员会成员等邀请参加会议。</li><li data-pid="o9YFfsqC">整理项目数据：收集项目的文件，数据和记录。</li><li data-pid="dYHa_eM0">总结项目成果：评估项目的成果，包括项目的目标是否达成，项目的质量、成本和时间是否符合预期。</li><li data-pid="rnhFOCKF">总结项目教训：评估项目的教训，包括项目中发生的问题，以及如何解决这些问题。</li><li data-pid="lGKShJLm">制定改进计划：根据项目复盘的结果，制定改进计划，以提高未来项目的成功率。</li></ol><p data-pid="1-BYsNbV">项目复盘是项目管理的重要组成部分，它能帮助项目管理团队和组织改进项目管理流程，提高未来项目的成功率。</p><p class="ztext-empty-paragraph"><br></p><h3><b>复盘基础概念介绍</b></h3><p data-pid="qGRFufEg">小项目和大项目的复盘过程基本相似，但是在实施上可能会有一些差异。</p><ul><li data-pid="vbp48Ppk">小项目的复盘可能更为简单和灵活，可以在项目结束后进行简单的总结和评估，并在短时间内完成复盘过程。参与者也不需要太多，项目经理和项目成员就足够了。</li><li data-pid="h5lEcBkD">而大项目的复盘则更为复杂，可能需要较长时间来完成。项目经理需要收集大量的数据和文件，并进行详细的评估。参与者也更多，可能需要项目团队成员、相关部门经理、项目委员会成员等。</li></ul><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic2.zhimg.com/v2-77873ae654ac8ab5d7e6d81995b56335_r.jpg" data-caption="" data-size="normal" width="2060" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>复盘的态度</b></h3><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic3.zhimg.com/v2-7178f7438b81153e49d45c8f914c644e_r.jpg" data-caption="" data-size="normal" width="2060" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>复盘的四大步骤</b></h3><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic3.zhimg.com/v2-f0e96b870016400fe18a74cc33f9d5da_r.jpg" data-caption="" data-size="normal" width="2060" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p data-pid="uOHBUnij"><b>对应的 简单的一个案例如下：</b></p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic1.zhimg.com/v2-99502f9d2d05eb2b15dfcb2735f5b75c_r.jpg" data-caption="" data-size="normal" width="2060" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><p data-pid="JxGZJxoo"><b>复盘的步骤：</b></p><ol><li data-pid="B59AAUVH">计划复盘：安排复盘会议，确定参与者，并准备必要的文件和数据。</li><li data-pid="Io82_9g8">收集信息：收集项目的文件，数据和记录，包括项目计划、项目绩效指标、项目进度报告等。</li><li data-pid="sfGxI0n5">分析信息：分析项目的数据和文件，评估项目的成果和效益。</li><li data-pid="Q3R63tKV">总结项目：总结项目成果和教训，评估项目中发生的问题，并制定改进计划。</li><li data-pid="KZNL1lA4">记录结果：将复盘的结果记录下来，包括项目成果、教训和改进计划，并与相关人员共享。</li><li data-pid="gMwqLuFt">实施改进计划：按照改进计划采取行动, 以提高未来项目的成功率。</li></ol><p data-pid="PJn3aYuF">复盘是一个连续的过程，不断地总结项目的进展，并制定改进计划，以提高项目的效率和成功率。</p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic3.zhimg.com/v2-6bdcdf755f7ad30e208857c01d05cfce_r.jpg" data-caption="" data-size="normal" width="2060" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic3.zhimg.com/v2-b7b60def7c9b7b97cd3b1793f9fc6352_r.jpg" data-caption="" data-size="normal" width="2060" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>复盘案例分析</b></h3><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic4.zhimg.com/v2-9467e2bd8b1a790d978eb7d2f75f8d1f_r.jpg" data-caption="" data-size="normal" width="2060" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h2><b>实用项目管理工具推荐</b></h2><ul><li data-pid="uaTKY-9o"><a href="https://gu4gn46jrh.feishu.cn/sheets/shtcnnX8510cz9D2UWaZjaWQibh" target="_blank">Onepage模板链接</a></li></ul><blockquote data-pid="p4Dnov0q"><b>目录：</b></blockquote><table data-draft-node="block" data-draft-type="table" data-size="normal" data-row-style="normal"><tbody><tr><th>文档名称</th><th>文档链接</th></tr><tr><td>项目基础信息表</td><td>项目基础信息表</td></tr><tr><td>核心成员表</td><td>核心成员表</td></tr><tr><td>里程碑图表</td><td>里程碑图表</td></tr><tr><td>版本节奏表</td><td>版本节奏表</td></tr><tr><td>项目沟通计划表</td><td>项目沟通计划表</td></tr><tr><td>tracker-甘特图</td><td>tracker-甘特图</td></tr><tr><td>风险登记册</td><td>风险登记册</td></tr><tr><td>问题登记册</td><td>问题登记册</td></tr><tr><td>会议纪要表</td><td>会议纪要表</td></tr><tr><td>项目阶段性汇报</td><td>项目阶段性汇报I 项目阶段性汇报II</td></tr><tr><td>项目集阶段性汇报</td><td>项目集阶段性汇报</td></tr><tr><td>复盘模板</td><td>复盘模板</td></tr></tbody></table><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>Onepage模板—项目基础信息表</b></h3><p data-pid="nz2dly-U"><b>使用场景：项目启动规划阶段 | 项目背景、目标、预计收益指定</b></p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic1.zhimg.com/v2-b6409cdb6ea576c1039ed8e84b37e544_r.jpg" data-caption="" data-size="normal" width="2060" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>Onepage模板—核心成员表</b></h3><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic1.zhimg.com/v2-30946128d53b439801c295a34b2569fc_r.jpg" data-caption="" data-size="normal" width="2060" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>Onepage模板—里程碑图表</b></h3><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic1.zhimg.com/v2-2c10b041a4db09f021811623729f7940_r.jpg" data-caption="" data-size="normal" width="2060" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic1.zhimg.com/v2-c7655489438c5c43a4200ad50a5a8b74_r.jpg" data-caption="" data-size="normal" width="2060" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>Onepage模板—项目沟通计划表</b></h3><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic2.zhimg.com/v2-46a6b49b1317f510f8ed01cbca0d6acd_r.jpg" data-caption="" data-size="normal" width="2060" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>Tracker 模板—WBS/甘特图</b></h3><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic2.zhimg.com/v2-b898320ac99ffd7e0e9e30428c035d15_r.jpg" data-caption="" data-size="normal" width="2060" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><h3><b>Tracker 模板—会议纪要表</b></h3><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic4.zhimg.com/v2-b4cb18f295287b959ad7b308a539c893_r.jpg" data-caption="" data-size="normal" width="2060" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>项目汇报表 — 阶段性汇报 一</b></h3><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic2.zhimg.com/v2-5ed398babf079cba18c040657e3ee79d_r.jpg" data-caption="" data-size="normal" width="2060" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>项目汇报表 — 阶段性汇报 二</b></h3><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic4.zhimg.com/v2-b8b5a0096a7ae48e1da741165431de13_r.jpg" data-caption="" data-size="normal" width="2060" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>项目集阶段汇报</b></h3><p class="ztext-empty-paragraph"><br></p><figure data-size="normal"><img src="https://pic2.zhimg.com/v2-57cd9d5b21466341db641d430aff7d35_r.jpg" data-caption="" data-size="normal" width="2060" referrerpolicy="no-referrer"></figure><p class="ztext-empty-paragraph"><br></p><p class="ztext-empty-paragraph"><br></p><h3><b>复盘模板</b></h3><p></p></div> </details> 
 <hr /> 

 #### - [kubernetes 源码解析资源](https://zhuanlan.zhihu.com/p/597276550) 
 <details><summary>توضیحات</summary> <p><img src="https://picx.zhimg.com/v2-ca5410e9b799c1a9f96e2203e7b9950b_720w.jpg?source=d16d100b"></p><div><h2><b>需求</b></h2><p data-pid="hixpdr8a">tip  我们需要对 kubernetes 进一步的学习和深造，看源码是必须的道路。</p><p data-pid="WmaZbx1c">与其重要的，是对 kubernetes 资源的收集。</p><p data-pid="zMzN7AC-"><i><b>⚠️ 所有资源均是采用外链连接，书本资源或不放连接，其他均为自己感受和总结。如有侵权请联系删除。</b></i></p><p class="ztext-empty-paragraph"><br></p><p data-pid="NN5v9Mjk"><b>关于kubernetes：</b></p><ul><li data-pid="IziuorUI"><a href="https://kubernetes.io/" target="_blank">官网</a></li><li data-pid="SzHr8gpT"><a href="https://github.com/kubernetes/kubernetes" target="_blank">GitHub</a></li><li data-pid="VDtYSrCg"><a href="https://github.com/cubxxw/kubernetes" target="_blank">cubxxw - pr</a></li><li data-pid="eALbBm0a"><a href="https://github.com/kubernauts/Kubernetes-Learning-Resources" target="_blank">社区维护的 kubernetes 学习资源合集</a></li><li data-pid="tkRBr4ha"><a href="https://blog.opskumu.com/borg.html" target="_blank">Kubernetes源码必读的 Google 大规模集群管理器 Borg</a></li></ul><p class="ztext-empty-paragraph"><br></p><p data-pid="4oAEYgAl"><b>关于 CNCF 的贡献，你需要签署 CLA </b></p><ul><li data-pid="2hgkXqqx"><a href="https://github.com/kubernetes/community/blob/master/CLA.md" target="_blank">Kubernetes CLA  的签署流程</a></li></ul><p class="ztext-empty-paragraph"><br></p><p data-pid="9mt1ryG_">::: warning </p><ul><li data-pid="LlmbhMI2"><a href="https://github.com/kubernetes/community/tree/master/contributors/devel" target="_blank">官方开发者向导 markdown 文件</a></li></ul><p data-pid="3QLP27EJ">:::</p><p class="ztext-empty-paragraph"><br></p><p data-pid="An2l29Ov"><b>自己的一些资源：</b></p><ul><li data-pid="yFLmdRQe"><a href="https://docker.nsddd.top/" target="_blank">云原生学习</a></li><li data-pid="Selu6JNE"><a href="https://go.nsddd.top/" target="_blank">golang 学习</a></li></ul><p class="ztext-empty-paragraph"><br></p><h2><b>最好需要什么</b></h2><ol><li data-pid="32c6zzFu">如果说第一步的话，那必须要了解 docker 容器底层原理和 Linux 内核基础相关。</li><li data-pid="Vx5TyaE1">先理解理解完架构了，读起来就比较快了。</li><li data-pid="HKnZfjny">学会使用它，不会使用，永远无法理解它的设计理念。</li><li data-pid="qEm5brtb">读源码还得带着问题去读，不然会很枯燥。一定要带着问题去读，不然就会很枯燥，然后陷入细节中去</li><li data-pid="MYRdAf4l">读源码还得有一定积累量，比如你已经读过很多基础包的源码比如 net/http grpc-go 等等</li><li data-pid="GZGvY6nO">要尝试着调试，要尝试着练习，要尝试着理解和分析产品理念，更要学会自己设计。</li></ol><p class="ztext-empty-paragraph"><br></p><h2><b>基础知识</b></h2><p data-pid="VkzycBkh"><b>基础概念：</b></p><p data-pid="XFx5e91t">我们需要知道 kubernetes 的基础概念，我们或许在前面有讲解过。</p><p data-pid="Gc1Ea1B0">比如 Build-in 的 API Groups 和 API Objects 有什么，做什么用；</p><p class="ztext-empty-paragraph"><br></p><p data-pid="Qkm8pLys"><b>有一些很重要的工具库：</b> 如 <b>gengo</b> ，包括 informer 机制；</p><ul><li data-pid="nJg4OacW">Cobra：命令行阿，docker、Kubernetes、sealos、sealer、ks 都具备的~</li><li data-pid="o1C4sxSp"><a href="https://github.com/emicklei/go-restful" target="_blank">go-restful</a>：REST 要求开发人员以与协议定义一致的方式显式使用 HTTP 方法。这个基本的 REST 设计原则在创建、读取、更新和删除 (CRUD) 操作和 HTTP 方法之间建立了一对一的映射。</li><li data-pid="v4JwqpbB">etcd：和 fabric 一样采用 raft 共识机制的数据库，在 k3s 中很深的讲解和应用。</li></ul><p class="ztext-empty-paragraph"><br></p><p data-pid="Ik1FOQuf"><b>Restful 基础：</b></p><p data-pid="_bXQ1O5b">简单了解 Restful 概念，如果做过 Restful Service 那么最好了</p><p class="ztext-empty-paragraph"><br></p><h2><b>阅读方法（其他开源项目类似）</b></h2><ul><li data-pid="tCFAPc6e">先整体，后局部（不钻牛角尖）</li><li data-pid="U3v0eSbY">深入局部中的学习中去</li><li data-pid="iQ8UKwBn">耐心，多看代码~</li></ul><p class="ztext-empty-paragraph"><br></p><h2><b>书籍推荐</b></h2><ul><li data-pid="sY7XgWrR">Go语言程序设计语言 （买了，建议有一些其他语言基础 &amp;&amp; Go语言基础再看最好）</li><li data-pid="-RA_Z_tO">深入解刨 Kubernetes （这个我也买了，emmm，特别完美的一本书，作者有自己的讲解，是个大佬）</li><li data-pid="UzU05pFT">kubernetes 编程</li><li data-pid="2GPcQtyA">kubernetes 源码刨析（这个我买了！！！！！！，不推荐，copy 多干货少）</li><li data-pid="DS5Szv3Z">docker 容器与容器云 （还没开始看）</li><li data-pid="CSZPuLM2">docker 开发指南 （还没开始看）</li></ul><p class="ztext-empty-paragraph"><br></p><h2><b>视频资源</b></h2><ul><li data-pid="mxjO9lJA"><a href="https://space.bilibili.com/1748865719?share_from=space&amp;share_medium=iphone&amp;share_plat=ios&amp;share_session_id=160FA9F0-624A-411F-AD29-CE83BBBA3D35&amp;share_source=WEIXIN&amp;share_tag=s_i&amp;timestamp=1669727398&amp;unique_k=ulDpC8O" target="_blank">张海龙 kubernetes 开发之旅</a></li><li data-pid="WopR-8x7"><a href="https://search.bilibili.com/all?keyword=client-go&amp;from_source=webtop_search&amp;spm_id_from=333.999&amp;search_source=5" target="_blank">bilibili 搜索 client-go kubernetes必会</a></li><li data-pid="eRG18Dul"><a href="https://space.bilibili.com/547971176?share_from=space&amp;share_medium=iphone&amp;share_plat=ios&amp;share_session_id=DE3B8DC0-6E79-4FCC-A128-21D5FB84D251&amp;share_source=WEIXIN&amp;share_tag=s_i&amp;timestamp=1669727447&amp;unique_k=TjDCl4U" target="_blank">插座煤电 深入理解 k8s 网络</a></li></ul><p class="ztext-empty-paragraph"><br></p><h2><b>网站资源</b></h2><ul><li data-pid="BLaYouei"><a href="https://mp.weixin.qq.com/s/K6ynL_9nSTLCTy0_2xCobg" target="_blank">从 0 实现一个 k8s 的 CNI 网络插件</a></li></ul><p class="ztext-empty-paragraph"><br></p><h2><b>推荐书籍</b></h2><ul><li data-pid="6a72QURt"><a href="https://zhuanlan.zhihu.com/p/597276550/edit">深入剖析kubernetes</a></li><li data-pid="0IB5uaII">Kubernetes 源码解析</li></ul><p class="ztext-empty-paragraph"><br></p><h2><b>youtube 精选视频</b></h2><ul><li data-pid="oF-SnDJZ"><a href="https://www.youtube.com/watch?v=Q91iZywBzew" target="_blank">教程：从源代码构建和运行 Kubernetes 并提交您的第一个 PR</a></li><li data-pid="RN3UntcI"><a href="https://www.youtube.com/watch?v=Jbm0W9Dd4k4" target="_blank">Kubernetes源码解读: APIServer之server chain by Daniel Guo</a></li><li data-pid="nREePF2K"><a href="https://www.youtube.com/watch?v=ytbEmcxM4yQ" target="_blank">如何理解开源中的大型代码库</a></li><li data-pid="2n6I8eFp"><a href="https://www.youtube.com/watch?v=kA1T0zDPtQo" target="_blank">如何理解开源中的大型代码库？</a></li><li data-pid="qyEalfN1"><a href="https://www.youtube.com/watch?v=toIncOqOBTA" target="_blank">Kubernetes 源码阅读</a></li></ul><p class="ztext-empty-paragraph"><br></p><h2><b>GitHub 精选仓库</b></h2><ul><li data-pid="CJ1cyx6I"><a href="https://github.com/JackyZhangFuDan/K8sSourceCodeDeepDive/" target="_blank">go 开发之旅</a></li><li data-pid="LN6GAj-J"><a href="https://github.com/derekguo001/understanding-kubernetes" target="_blank">kubernetes 源码解读</a></li></ul><p class="ztext-empty-paragraph"><br></p><h2><b>数据统计和收集</b></h2><h3><b>CNCF 数据</b></h3><p data-pid="yPJ7vC1N">网站：<a href="https://kubernetes.io/" target="_blank">kubernetes.io</a></p><p data-pid="x8VPkPOD">资料库：<a href="https://github.com/kubernetes/kubernetes" target="_blank">github.com/kubernetes/kubernetes</a> 94,767  </p><p data-pid="IB0g0rvL">Crunchbase：<a href="https://www.crunchbase.com/organization/cloud-native-computing-foundation" target="_blank">crunchbase.com/organization/cloud-native-computing-foundation</a></p><p data-pid="m50cZayw">领英：<a href="https://www.linkedin.com/company/cloud-native-computing-foundation" target="_blank">linkedin.com/company/cloud-native-computing-foundation</a></p><p data-pid="FKDx7duN">推特：<a href="https://twitter.com/kubernetesio" target="_blank">@kubernetesio</a></p><p data-pid="_AyUU6CS">第一次提交：<a href="https://github.com/kubernetes/kubernetes/commit/2c4b3a562ce34cddc3f8218a2c4d11c7310e6d56%22" target="_blank">9年前</a></p><p data-pid="sljxjszt">贡献者：<a href="https://github.com/kubernetes/kubernetes/graphs/contributors" target="_blank">500+</a></p><p data-pid="menmX-rt">最新推文：<a href="https://twitter.com/kubernetesio" target="_blank">2个月前</a></p><p data-pid="ZY0IFLxR">公认: 2016-03-10</p><p data-pid="_9hr4cgm">已毕业：2018-03-06</p><p data-pid="J8hN0G96">总部：<a href="https://landscape.cncf.io/?grouping=headquarters&amp;headquarters=san-francisco-california" target="_blank">加利福尼亚州旧金山</a></p><p data-pid="_l_7knNK">孵化：7 年前</p><p data-pid="7Rf5onWQ">开发统计：<a href="https://k8s.devstats.cncf.io/" target="_blank"><span class="invisible">https://</span><span class="visible">k8s.devstats.cncf.io/</span><span class="invisible"></span></a></p><p data-pid="wARHqF8m">艺术品： <a href="https://github.com/cncf/artwork/blob/master/examples/graduated.md#kubernetes-logos" target="_blank"><span class="invisible">https://</span><span class="visible">github.com/cncf/artwork</span><span class="invisible">/blob/master/examples/graduated.md#kubernetes-logos</span><span class="ellipsis"></span></a></p><p data-pid="hofHOdZs">stackoverflow：<a href="https://stackoverflow.com/questions/tagged/kubernetes" target="_blank"><span class="invisible">https://</span><span class="visible">stackoverflow.com/quest</span><span class="invisible">ions/tagged/kubernetes</span><span class="ellipsis"></span></a></p><p data-pid="cGzUnWZQ">博客：<a href="http://blog.kubernetes.io/" target="_blank"><span class="invisible">http://</span><span class="visible">blog.kubernetes.io/</span><span class="invisible"></span></a></p><p data-pid="ITvQyDKe">邮件列表：<a href="https://groups.google.com/forum/#!forum/kubernetes-dev" target="_blank"><span class="invisible">https://</span><span class="visible">groups.google.com/forum</span><span class="invisible">/#!forum/kubernetes-dev</span><span class="ellipsis"></span></a></p><p data-pid="HBRFeJm3">slack：<a href="http://slack.k8s.io/" target="_blank"><span class="invisible">http://</span><span class="visible">slack.k8s.io/</span><span class="invisible"></span></a></p><p data-pid="oBdaJPEz">YouTube： <a href="https://www.youtube.com/channel/UCZ2bu0qutTOM0tHYa_jkIwg" target="_blank"><span class="invisible">https://www.</span><span class="visible">youtube.com/channel/UCZ</span><span class="invisible">2bu0qutTOM0tHYa_jkIwg</span><span class="ellipsis"></span></a></p><h3><b>源码统计</b></h3><p data-pid="W1A8eVZY"><code>Kubernetes</code> 代码特别庞大，使用 cloc 统计：</p><div class="highlight"><pre><code class="language-bash"> PS D:<span class="se">\文</span>档<span class="se">\m</span>y&gt; cloc.exe .<span class="se">\k</span>ubernetes<span class="se">\
</span><span class="se"></span>    <span class="m">23056</span> text files.
    <span class="m">17722</span> unique files.
     <span class="m">5806</span> files ignored.
 ​
 github.com/AlDanial/cloc v 1.94  <span class="nv">T</span><span class="o">=</span>228.54 s <span class="o">(</span>77.5 files/s, 28953.4 lines/s<span class="o">)</span>
 --------------------------------------------------------------------------------
 Language                      files          blank        comment           code
 --------------------------------------------------------------------------------
 Go                            <span class="m">15020</span>         <span class="m">517320</span>        <span class="m">1010720</span>        <span class="m">3922880</span>
 JSON                            <span class="m">341</span>              <span class="m">2</span>              <span class="m">0</span>         <span class="m">779037</span>
 YAML                           <span class="m">1182</span>            <span class="m">612</span>           <span class="m">1326</span>         <span class="m">132857</span>
 Markdown                        <span class="m">458</span>          <span class="m">22121</span>              <span class="m">0</span>          <span class="m">80538</span>
 Bourne Shell                    <span class="m">328</span>           <span class="m">6343</span>          <span class="m">12485</span>          <span class="m">31159</span>
 Protocol Buffers                <span class="m">124</span>           <span class="m">5811</span>          <span class="m">19566</span>          <span class="m">11531</span>
 PO File                          <span class="m">12</span>           <span class="m">1873</span>          <span class="m">13392</span>          <span class="m">11261</span>
 Assembly                         <span class="m">48</span>           <span class="m">2696</span>            <span class="m">883</span>           <span class="m">7754</span>
 Text                             <span class="m">28</span>            <span class="m">195</span>              <span class="m">0</span>           <span class="m">6612</span>
 PowerShell                        <span class="m">7</span>            <span class="m">398</span>           <span class="m">1018</span>           <span class="m">2485</span>
 make                             <span class="m">59</span>            <span class="m">527</span>            <span class="m">891</span>           <span class="m">1844</span>
 Starlark                         <span class="m">24</span>             <span class="m">68</span>              <span class="m">0</span>            <span class="m">904</span>
 C/C++ Header                      <span class="m">1</span>            <span class="m">399</span>           <span class="m">4367</span>            <span class="m">839</span>
 Bourne Again Shell               <span class="m">10</span>             <span class="m">58</span>             <span class="m">72</span>            <span class="m">449</span>
 sed                               <span class="m">4</span>              <span class="m">4</span>             <span class="m">32</span>            <span class="m">445</span>
 Dockerfile                       <span class="m">46</span>            <span class="m">201</span>            <span class="m">680</span>            <span class="m">408</span>
 Python                            <span class="m">7</span>            <span class="m">119</span>            <span class="m">159</span>            <span class="m">406</span>
 SVG                               <span class="m">4</span>              <span class="m">4</span>              <span class="m">4</span>            <span class="m">398</span>
 zsh                               <span class="m">1</span>             <span class="m">14</span>              <span class="m">3</span>            <span class="m">191</span>
 C                                 <span class="m">5</span>             <span class="m">42</span>             <span class="m">54</span>            <span class="m">140</span>
 ANTLR Grammar                     <span class="m">1</span>             <span class="m">31</span>             <span class="m">17</span>            <span class="m">138</span>
 TOML                              <span class="m">5</span>             <span class="m">24</span>             <span class="m">86</span>             <span class="m">74</span>
 INI                               <span class="m">1</span>              <span class="m">2</span>              <span class="m">0</span>             <span class="m">10</span>
 CSV                               <span class="m">2</span>              <span class="m">0</span>              <span class="m">0</span>              <span class="m">3</span>
 DOS Batch                         <span class="m">1</span>              <span class="m">2</span>             <span class="m">17</span>              <span class="m">2</span>
 HTML                              <span class="m">2</span>              <span class="m">0</span>              <span class="m">0</span>              <span class="m">2</span>
 NAnt script                       <span class="m">1</span>              <span class="m">0</span>              <span class="m">0</span>              <span class="m">1</span>
 --------------------------------------------------------------------------------
 SUM:                          <span class="m">17722</span>         <span class="m">558866</span>        <span class="m">1065772</span>        <span class="m">4992368</span>
 --------------------------------------------------------------------------------</code></pre></div><p></p></div> </details> 
 <hr /> 

 #### - [用于本地实验的小型 Kubernetes：k0s、MicroK8s、kind、k3s 和 Minikube](https://zhuanlan.zhihu.com/p/594206344) 
 <details><summary>توضیحات</summary> <p><img src="https://picx.zhimg.com/v2-e47af54c4df2cdfdab274aec884cce5b_720w.jpg?source=d16d100b"></p><div><p data-pid="L_wy1cZE"><b>前言</b></p><ul><li data-pid="lFKk319N"><a href="https://blog.palark.com/small-local-kubernetes-comparison/" target="_blank">本章为摘选，截取</a>，⚠️ 在此基础上的修改</li><li data-pid="ViAMrf2G"><a href="https://docker.nsddd.top/Cloud-Native-k8s/14.html" target="_blank">k3s 记录</a></li></ul><p data-pid="2HigKeZy">因此，您已经提出了一个自动化、统一或转换集群中某些内容的想法，但您不想冒破坏集群的风险。大多数有过 Kubernetes 经验的人都熟悉这种情况。为此，您需要的是一个易于设置的沙盒来测试您的想法，而不会冒太大风险。</p><p data-pid="C6muc0EX">在这种情况下，Kubernetes 迷你集群会派上用场。您可以在台式机或笔记本电脑上运行它们，修补基元，构建新结构，然后在实验结束时毫不犹豫地删除它们。</p><p data-pid="VzE7Fm4K">世界各地的开发人员通过发明各种解决方案来满足这一需求，这些解决方案使您能够快速轻松地启动轻量级 Kubernetes 环境。所有这些解决方案都具有不同的设计和功能。您选择的那个将取决于您的需求和偏好。本文回顾了一些最受欢迎的工具，帮助您更好地了解它们并选择正确的工具。幸运的是，它们都有相对完善的文档记录（无论是在官方网站上还是在 CLI 中），这大大加快了学习过程并使它们易于使用。在本文的最后，我们提供了一个比较表，详细介绍了解决方案的主要功能。</p><h2><b>工具</b></h2><h3><b>1. K0s</b></h3><ul><li data-pid="sM6RZC8s">网站： <a href="https://k0sproject.io/" target="_blank">k0sproject.io</a></li><li data-pid="4jOdhP2x">GitHub 存储库：<a href="https://github.com/k0sproject/k0s" target="_blank">k0sproject/k0s</a></li><li data-pid="jgJsdGcT">GitHub 明星： 4，000+ （后面不知道啥原因变少了）</li><li data-pid="Pq9F5hkZ">贡献者： 30+</li><li data-pid="6GkQNNdh">首次提交：2020 年 6 月</li></ul><p data-pid="i9ZdQe2L">该项目的名称不言自明：很难想象一个系统更轻量级，因为它基于单个自给自足（静态构建）的文件。您需要做的就是从项目存储库下载它的当前版本，然后您可以继续配置和使用集群。该文件是为 Linux 编译的。因此，群集只能在该系统上运行（有关支持的主机系统的详细信息，请参阅本文末尾）。请注意，只有根用户才能运行它。</p><p data-pid="ljO3PdSp"><a href="https://github.com/k0sproject/k0s/blob/main/docs/install.md" target="_blank">安装</a>完成后（您需要做的就是将文件复制到<code>/usr/local/bin</code>），使用帮助程序脚本将 K0s 作为服务启动。现在，您可以将其作为群集节点（默认为主节点）访问：</p><div class="highlight"><pre><code class="language-text"> k0s install controller ; systemctl start k0scontroller.service</code></pre></div><p data-pid="fx6XMeh_">k0s 包含用于连接到 Kubernetes API 的 kubectl CLI 工具：</p><div class="highlight"><pre><code class="language-text"> k0s kubectl get nodes</code></pre></div><p data-pid="p-Ed3jKx">您可以使用<code>k0s kubectl</code>创建其他 Kubernetes 对象：命名空间、部署等。要将节点添加到 k0s 群集，请在要用作工作器节点的服务器上下载并安装 k0s 二进制文件。接下来，生成身份验证令牌，该令牌将用于将节点加入群集。其他服务器可以在容器或 VM 上运行：您所要做的就是确保 API 服务器的网络可用性，以便在群集中注册节点。</p><p data-pid="cNEHXiCU">要卸载 k0s 群集，首先需要停止服务 （<code>k0s stop</code>），然后调用 reset 命令从主机中删除所有与 k0s 相关的文件。</p><p data-pid="osTmUFpK">containerd 守护进程在 Pod 中管理和运行容器。此外，您还可以将 hostPath 卷挂载到 Pod。Calico作为默认的CNI，而kube-router也可用。从本质上讲，你可以使用任何你喜欢的 CNI，因为 k0s 不会以任何方式限制 Kubernetes 配置。</p><p data-pid="QH7JGQXH">为了方便用户，k0s 为各种 shell 提供了自动完成脚本：Bash、zsh、fish 和 PowerShell（使用 WSL）。</p><p data-pid="FuO3Gm4T">k0s 尽可能简约：它是一个没有任何模块或插件的普通 Kubernetes。默认情况下，它不支持云提供商（但是，您可以在启动期间 <a href="https://github.com/k0sproject/k0s/blob/main/docs/cloud-providers.md" target="_blank">添加它</a>）。该软件的安装方式与常规 Kubernetes 集群中的安装方式相同——通过声明必要的原语（您可以使用 Helm 和其他此类工具）。</p><p class="ztext-empty-paragraph"><br></p><h3><b>2. MicroK8s型 K8s</b></h3><ul><li data-pid="ny4GW1J3">网站： <a href="https://microk8s.io/" target="_blank">microk8s.io</a></li><li data-pid="iFsRbLyB">GitHub 存储库：<a href="https://github.com/ubuntu/microk8s" target="_blank">ubuntu/microk8s</a></li><li data-pid="io8AKY6v">GitHub 星数： ~5，700</li><li data-pid="BRzErqxn">贡献者： 120+</li><li data-pid="MIuX_bnT">首次提交：2018 年 5 月</li></ul><p data-pid="G7ozCl7j">Canonical 的这个迷你集群与前一个类似：集群节点需要手动设置，它们可以在通过 TCP/IP 连接到第一个（主）节点的任何 Linux 实例上运行。同样，添加新节点需要令牌，而内置的 kubectl 工具处理 API 交互。</p><p data-pid="5cd6a2EF">印花布也用作默认的 CNI。您需要 root 权限才能安装它。MicroK8s 以快照包的形式提供，支持 42 个 Linux 发行版：</p><div class="highlight"><pre><code class="language-yaml"><span class="w"> </span><span class="c"># snap install microk8s --classic</span></code></pre></div><p data-pid="bPoHj59D">安装完成后，您可以启动群集：</p><div class="highlight"><pre><code class="language-yaml"><span class="w"> </span><span class="c"># microk8s start</span><span class="w">
</span><span class="w"> </span><span class="c"># microk8s kubectl get nodes</span><span class="w">
</span><span class="w"> </span><span class="l">NAME            STATUS   ROLES    AGE    VERSION</span><span class="w">
</span><span class="w"> </span><span class="l">thinkpad        Ready       2m     v1.20.7-34+df7df22a741dbc</span></code></pre></div><p data-pid="Ty-pPoTs">请注意，MicroK8s 附带<a href="https://microk8s.io/docs/addons" target="_blank">一组插件</a>。您可以随时启用和禁用它们。例如，以下内容将启用 Kubernetes 仪表板：</p><div class="highlight"><pre><code class="language-yaml"><span class="w"> </span><span class="c"># microk8s enable dashboard</span><span class="w">
</span><span class="w"> </span><span class="c"># microk8s status</span><span class="w">
</span><span class="w"> </span><span class="l">microk8s is running</span><span class="w">
</span><span class="w"> </span><span class="nt">high-availability</span><span class="p">:</span><span class="w"> </span><span class="kc">no</span><span class="w">
</span><span class="w">   </span><span class="nt">datastore master nodes</span><span class="p">:</span><span class="w"> </span><span class="m">127.0.0.1</span><span class="p">:</span><span class="m">19001</span><span class="w">
</span><span class="w">   </span><span class="nt">datastore standby nodes</span><span class="p">:</span><span class="w"> </span><span class="l">none</span><span class="w">
</span><span class="w"> </span><span class="nt">addons</span><span class="p">:</span><span class="w">
</span><span class="w">   </span><span class="nt">enabled</span><span class="p">:</span><span class="w">
</span><span class="w">     </span><span class="l">dashboard            # The Kubernetes dashboard</span><span class="w">
</span><span class="w">     </span><span class="l">...</span></code></pre></div><p data-pid="HYrMS2iC">与k0s类似，MicroK8s带有一个用于存储容器映像的内部注册表。</p><p data-pid="s-8-m6Gt">另一个令人兴奋的功能是<code>microk8s inspect</code>命令。它的作用是分析集群并编译有关其组件的完整报告（作为 tar.gz 文件）以供进一步研究：</p><div class="highlight"><pre><code class="language-bash"> $ ls inspection-report/
 apparmor
 args
 juju
 k8s
 kubeflow
 network
 snap.microk8s.daemon-apiserver
 snap.microk8s.daemon-apiserver-kicker
 snap.microk8s.daemon-cluster-agent
 snap.microk8s.daemon-containerd
 snap.microk8s.daemon-controller-manager
 snap.microk8s.daemon-control-plane-kicker
 snap.microk8s.daemon-kubelet
 snap.microk8s.daemon-proxy
 snap.microk8s.daemon-scheduler
 sys
 $ ls inspection-report/k8s/
 cluster-info
 cluster-info-dump
 get-all
 get-pv
 get-pvc
 version
 $ cat inspection-report/k8s/version 
 Client Version: version.Info<span class="o">{</span>Major:<span class="s2">"1"</span>, Minor:<span class="s2">"20+"</span>, GitVersion:<span class="s2">"v1.20.7-34+df7df22a741dbc"</span>, GitCommit:<span class="s2">"df7df22a741dbc18dc3de3000b2393a1e3c32d36"</span>, GitTreeState:<span class="s2">"clean"</span>, BuildDate:<span class="s2">"2021-05-12T21:08:20Z"</span>, GoVersion:<span class="s2">"go1.15.10"</span>, Compiler:<span class="s2">"gc"</span>, Platform:<span class="s2">"linux/amd64"</span><span class="o">}</span>
 Server Version: version.Info<span class="o">{</span>Major:<span class="s2">"1"</span>, Minor:<span class="s2">"20+"</span>, GitVersion:<span class="s2">"v1.20.7-34+df7df22a741dbc"</span>, GitCommit:<span class="s2">"df7df22a741dbc18dc3de3000b2393a1e3c32d36"</span>, GitTreeState:<span class="s2">"clean"</span>, BuildDate:<span class="s2">"2021-05-12T21:09:51Z"</span>, GoVersion:<span class="s2">"go1.15.10"</span>, Compiler:<span class="s2">"gc"</span>, Platform:<span class="s2">"linux/amd64"</span><span class="o">}</span></code></pre></div><p class="ztext-empty-paragraph"><br></p><h3><b>3. kind</b></h3><ul><li data-pid="YiZ2OG2-">网站： <a href="https://kind.sigs.k8s.io/" target="_blank">kind.sigs.k8s.io</a></li><li data-pid="bhhnz8K_">GitHub repository： <a href="https://github.com/kubernetes-sigs/kind" target="_blank">kubernetes-sigs/kind</a></li><li data-pid="G4ejkXFp">GitHub 星级： ~11，000</li><li data-pid="vcMC7CRw">贡献者： 200+</li><li data-pid="QAvpbh_9">首次提交：2018 年 9 月</li><li data-pid="kXr6Sb40">关键开发人员：Kubernetes SIG</li></ul><p data-pid="UKEbPotp">kind（Docker中的Kubernetes）是另一个用于运行本地 K8s 集群的轻量级工具。安装非常简单：您所要做的就是<a href="https://kind.sigs.k8s.io/docs/user/quick-start/#installation" target="_blank">下载</a>可执行文件。</p><p data-pid="m3Cq4p8H">要创建集群，您首先需要创建 Docker 容器和网络的权限。创建集群就像运行一样简单<code>kind create cluster</code>.这将启动一个节点 — 一个用于运行其他容器的 Docker 容器：</p><div class="highlight"><pre><code class="language-bash"> $ docker ps
 CONTAINER ID        IMAGE                  COMMAND                  CREATED             STATUS              PORTS                       NAMES
 fee30f6d4b73        kindest/node:v1.21.1   <span class="s2">"/usr/local/bin/entr…"</span>   <span class="m">2</span> minutes ago       Up About a minute   127.0.0.1:45331-&gt;6443/tcp   kind-control-plane
 $ kind get nodes
 kind-control-plane
 $ kubectl get nodes
 NAME                 STATUS   ROLES                  AGE   VERSION
 kind-control-plane   Ready    control-plane,master   2m    v1.21.1
 $ docker <span class="nb">exec</span> -it kind-control-plane bash
 root@kind-control-plane:/# crictl ps
 CONTAINER           IMAGE               CREATED             STATE               NAME                      ATTEMPT             POD ID
 2a0dfe12a5810       296a6d5035e2d       <span class="m">2</span> minutes ago       Running             coredns                   <span class="m">0</span>                   e13acbf529288
 38ef0ad97090a       296a6d5035e2d       <span class="m">2</span> minutes ago       Running             coredns                   <span class="m">0</span>                   3460cf0419c19
 ec11cbc0e9795       e422121c9c5f9       <span class="m">2</span> minutes ago       Running             local-path-provisioner    <span class="m">0</span>                   a9ffa60dcc12d
 fa8057bbf0df6       6de166512aa22       <span class="m">3</span> minutes ago       Running             kindnet-cni               <span class="m">0</span>                   4f8481acba5fc
 e341ce4c5cdfd       ebd41ad8710f9       <span class="m">3</span> minutes ago       Running             kube-proxy                <span class="m">0</span>                   1b1755819c40a
 88c6185beb5c5       0369cf4303ffd       <span class="m">3</span> minutes ago       Running             etcd                      <span class="m">0</span>                   da01c1b2b0cdc
 5cdf1b4ce6deb       d0d10a483067a       <span class="m">3</span> minutes ago       Running             kube-controller-manager   <span class="m">0</span>                   a0b2651c06136
 b704a102409e1       6401e478dcc01       <span class="m">3</span> minutes ago       Running             kube-apiserver            <span class="m">0</span>                   c2119c740fff2
 a5da036de5d10       7813cf876a0d4       <span class="m">3</span> minutes ago       Running             kube-scheduler            <span class="m">0</span>                   92a22aa99ad29</code></pre></div><p data-pid="KD_fsph3"><i>* 这也将创建一个 Docker 网络。如果安装由于以下错误而失败：</i></p><div class="highlight"><pre><code class="language-yaml"><span class="w"> </span><span class="nt">ERROR: failed to create cluster: failed to ensure docker network</span><span class="p">:</span><span class="w"> </span><span class="l">command "docker network create -d=bridge -o com.docker.network.bridge.enable_ip_masquerade=true -o com.docker.network.driver.mtu=1500 --ipv6 --subnet fc00:f853:ccd:e793::/64 kind" failed with error: exit status 1</span><span class="w">
</span><span class="w"> </span><span class="nt">Command Output: Error response from daemon</span><span class="p">:</span><span class="w"> </span><span class="l">could not find an available, non-overlapping IPv4 address pool among the defaults to assign to the network</span></code></pre></div><p data-pid="PMDfoFpd"><i>...检查  OpenVPN  进程是否在系统中运行，并在安装过程中停止它。安装完成后，您可以恢复其操作。</i></p><p data-pid="hLBJKLwg">此外，在创建群集时，<code>kubectl</code>配置为访问 API。要创建更复杂的集群，您需要在设置集群时指定配置文件（使用 <code>--config</code> 旗）。下面是如何创建由三个节点组成的群集的示例：</p><div class="highlight"><pre><code class="language-text"> kind create cluster --config=three-node-conf.yaml</code></pre></div><p data-pid="zevAOCxq">...哪里<code>three-node-conf.yaml</code>具有以下内容：</p><div class="highlight"><pre><code class="language-yaml"><span class="w"> </span><span class="nt">kind</span><span class="p">:</span><span class="w"> </span><span class="l">Cluster</span><span class="w">
</span><span class="w"> </span><span class="nt">apiVersion</span><span class="p">:</span><span class="w"> </span><span class="l">kind.x-k8s.io/v1alpha4</span><span class="w">
</span><span class="w"> </span><span class="nt">nodes</span><span class="p">:</span><span class="w">
</span><span class="w"> </span>- <span class="nt">role</span><span class="p">:</span><span class="w"> </span><span class="l">control-plane</span><span class="w">
</span><span class="w"> </span>- <span class="nt">role</span><span class="p">:</span><span class="w"> </span><span class="l">worker</span><span class="w">
</span><span class="w"> </span>- <span class="nt">role</span><span class="p">:</span><span class="w"> </span><span class="l">worker</span></code></pre></div><p data-pid="uQxzSi3x">删除同样简单：调用<code>kind delete cluster</code>从<code>kubectl</code>配置。作为旁注，还支持 Bash、zsh 和 fish 的自动完成脚本。</p><p data-pid="3evwcgNL">由于节点是 Docker 容器，因此在 Pod 中挂载 HostPath 卷会使用容器文件系统。这样，您可以将容器的目录转发到主机操作系统的文件系统。您可以将 Docker 镜像从主主机上传到群集节点。但是，它不附带任何插件或插件。</p><p data-pid="zbBMEIfU">kind 附带了一个基本的 <i>kindnetd</i> 插件作为默认CNI，但您也可以使用其他插件。虽然对自定义 CNI 的支持被描述为有限，但许多流行的 CNI 清单（例如 Calico）工作得很好。</p><p data-pid="rX-EpAvU">进一步配置通过<code>kubectl</code>.例如，您可以使用以下命令安装 Ingress NGINX：</p><div class="highlight"><pre><code class="language-bash"> kubectl apply -f https://raw.githubusercontent.com/kubernetes/ingress-nginx/master/deploy/static/provider/kind/deploy.yaml</code></pre></div><p class="ztext-empty-paragraph"><br></p><h3><b>4. K3S（和K3D）</b></h3><ul><li data-pid="jMESIx0i">网站：<a href="https://k3s.io/" target="_blank">k3s.io</a>（和 <a href="https://k3d.io/" target="_blank">k3d.io</a>)</li><li data-pid="hE42mAOv">GitHub repository： <a href="https://github.com/k3s-io/k3s/" target="_blank">k3s-io/k3s</a> （<a href="https://github.com/rancher/k3d" target="_blank">rancher/k3d</a> )</li><li data-pid="rwFaWEYA">GitHub 星： ~21，900 （~11000）</li><li data-pid="PVCJokkf">贡献者： 1，750+ （50+）</li><li data-pid="Y1O-HdJh">首次提交：2019 年 1 月（2019 年 4 月）</li><li data-pid="yBlgmxSj">主要开发商：CNCF（牧场主）</li></ul><p data-pid="xi8pei5Q">K3s 是 Rancher 的一个 Kubernetes 发行版，其名称类似于 K8s，但“只有一半大”，以强调其轻量级和简单性（尽管功能较少）。它的总体思路与k0s和MicroK8s没有太大区别。启动后，k3s 会创建具有以下两个角色之一的群集节点：</p><ul><li data-pid="HaMTmHme">作为主服务器运行的服务器：API 服务器、调度程序和控制器管理器（带有 SQLite 数据库）;</li><li data-pid="vLsZewiy">运行普通 Kubernetes 节点的代理：管理 <a href="https://cri-o.io/" target="_blank">CRI-O</a> 容器的 kubelet 和 containerd。</li></ul><p data-pid="vJ7lPjyk">大多数磁盘驱动程序和云提供程序驱动程序已从构建中排除，以使可执行文件更小。由于它结合了几个标准的 Kubernetes 组件，因此减少了内存使用量。</p><p data-pid="Tiqb5mTo">在最简单的情况下，您可以使用 Docker Desktop 将群集作为单个节点的一部分运行（不需要成熟的虚拟化系统）。</p><p data-pid="s91HM09Q">除了发行版之外，还有一个 <b>k3d</b> 实用程序，用于管理 Docker 容器中运行的 k3s 节点。它在Linux中运行，可以使用<a href="https://k3d.io/#install-script" target="_blank">Bash脚本</a>进行安装.</p><p data-pid="eWJG7Bq3">要启动集群，您只需要创建 Docker 容器和网络的权限。</p><p data-pid="wFA0BEAC">以下命令可用于创建群集：</p><div class="highlight"><pre><code class="language-text"> $ k3d cluster create mycluster --servers 1 --agents 2
 $ kubectl get nodes
 NAME                  STATUS   ROLES                  AGE   VERSION
 k3d-mycluster-agent-0    Ready                     30s   v1.20.6+k3s1
 k3d-mycluster-agent-1    Ready                     22s   v1.20.6+k3s1
 k3d-mycluster-server-0   Ready    control-plane,master   39s   v1.20.6+k3s1</code></pre></div><p data-pid="9bvZ51Hl">请参阅上面有关在安装期间创建 Docker 网络以及运行 OpenVPN 进程导致的错误的说明。但是，在这种情况下，错误消息将有所不同：</p><div class="highlight"><pre><code class="language-yaml"><span class="w"> </span><span class="nt">Failed Cluster Preparation: Failed Network Preparation: Error response from daemon</span><span class="p">:</span><span class="w"> </span><span class="l">could not find an available, non-overlapping IPv4 address pool among the defaults to assign to the network</span></code></pre></div><p data-pid="Gv-4hDIZ">每个群集节点都在自己的容器中运行，以及充当负载均衡器的 nginx 容器。Flannel 用作 CNI 插件，而 <a href="https://traefik.io/traefik/" target="_blank">Traefik</a> 用作入口代理。您也可以选择其他 CNI;例如，您可以在文档中找到有关印花布和运河<a href="https://rancher.com/docs/k3s/latest/en/installation/network-options/#custom-cni" target="_blank">的具体说明</a>。还支持 Bash、zsh、fish 和 PowerShell 的自动完成脚本。</p><p data-pid="4uKfCqz6">此外，您还可以管理映像存储库：在群集中创建自定义存储库并从主系统导入映像。如果您在本地构建 Docker 映像，这会派上用场，因为它们将在构建后立即在集群中可用。</p><hr><p data-pid="TkxiR9mF">⚠️ 本文主要描述 CNCF 主要的 Kubernetes 轻量版，关于 k3s 更详细的说明参考 <a href="https://docker.nsddd.top/Cloud-Native-k8s/14.html" target="_blank">k3s 上篇</a> 和 <a href="https://docker.nsddd.top/Cloud-Native-k8s/15.html" target="_blank">k3s 搭建详细测试</a></p><h3><b>5. minikube</b></h3><ul><li data-pid="OKkfz-6Z">网站： <a href="https://minikube.sigs.k8s.io/" target="_blank">minikube.sigs.k8s.io</a></li><li data-pid="BcocIe5K">GitHub repository： <a href="https://github.com/kubernetes/minikube" target="_blank">kubernetes/minikube</a></li><li data-pid="AZXzOAc7">GitHub 星级： ~0</li><li data-pid="4R64Ldxy">贡献者： 650+</li><li data-pid="Icn05HFx">首次提交：2016 年 4 月</li><li data-pid="J37OUHb2">关键开发人员：Kubernetes SIG</li></ul><p data-pid="PYiuQbti">对于基于 Debian 和 Red Hat 的 Linux 发行版，您需要做的就是<a href="https://minikube.sigs.k8s.io/docs/start/" target="_blank">安装</a>适当的软件包以使用 Minikube。您可以使用以下命令创建集群（不需要 root 权限;但是，用户必须具有足够的权限才能设置虚拟化系统）：</p><div class="highlight"><pre><code class="language-yaml"><span class="w"> </span><span class="l">$ minikube start</span><span class="w">
</span><span class="w"> </span>*<span class="w"> </span><span class="l">minikube v1.20.0 on Ubuntu 18.04</span><span class="w">
</span><span class="w"> </span><span class="nt">* Automatically selected the docker driver. Other choices</span><span class="p">:</span><span class="w"> </span><span class="l">kvm2, ssh</span><span class="w">
</span><span class="w"> </span><span class="l">…</span><span class="w">
</span><span class="w"> </span>*<span class="w"> </span><span class="l">Preparing Kubernetes v1.20.2 on Docker 20.10.6 ...</span><span class="w">
</span><span class="w"> </span><span class="l">…</span><span class="w">
</span><span class="w"> </span><span class="nt">* Enabled addons</span><span class="p">:</span><span class="w"> </span><span class="l">storage-provisioner, default-storageclass</span><span class="w">
</span><span class="w"> </span>*<span class="w"> </span><span class="l">Done! kubectl is now configured to use "minikube" cluster and "default" namespace by default</span><span class="w">
</span><span class="w"> </span><span class="l">$ kubectl get nodes</span><span class="w">
</span><span class="w"> </span><span class="l">NAME       STATUS   ROLES                  AGE    VERSION</span><span class="w">
</span><span class="w"> </span><span class="l">minikube   Ready    control-plane,master   48s    v1.20.2</span></code></pre></div><p data-pid="nbr-1PmX">现在您可以使用 kubectl 配置（它使用新集群的访问数据进行更新）。还支持 Bash、zsh 和 fish 的自动完成脚本。</p><p data-pid="aH7hQ-bL">对于本地操作系统，Minikube实现了<i>smth1-in-smth2</i>系统，其中：</p><ul><li data-pid="pIvAPFKI">SMTH1 是以下之一：<i>docker</i>、<i>cri-o</i> 或 <i>containerd</i>;</li><li data-pid="0OkGOmOM">SMTH2 是以下之一：<i>VirtualBox</i>、VMwareFusion、<i>KVM2</i>、<i>VMware</i>、<i>None</i>、<i>Docker</i>、<i>Podman</i> 或 <i>SSH</i> .</li></ul><p data-pid="-nOL7D4S">您还可以选择使用哪个 CNI 插件：</p><div class="highlight"><pre><code class="language-bash"> minikube <span class="nb">help</span> start
 Starts a <span class="nb">local</span> Kubernetes cluster
 ​
 Options:
 ...    
       --cni<span class="o">=</span><span class="s1">''</span>: CNI plug-in to use. Valid options: auto, bridge, calico, cilium, flannel, kindnet, or path to a CNI manifest <span class="o">(</span>default: auto<span class="o">)</span>
       --container-runtime<span class="o">=</span><span class="s1">'docker'</span>: The container runtime to be used <span class="o">(</span>docker, cri-o, containerd<span class="o">)</span>.
 ...
       --driver<span class="o">=</span><span class="s1">''</span>: Driver is one of: virtualbox, vmwarefusion, kvm2, vmware, none, docker, podman, ssh <span class="o">(</span>defaults to auto-detect<span class="o">)</span></code></pre></div><p data-pid="jfRinAJn">使用以下命令将节点添加到群集：</p><div class="highlight"><pre><code class="language-text"> $ minikube node add
 * Adding node m02 to cluster minikube</code></pre></div><p data-pid="6FnhCYD8">要查看群集的当前状态，请使用以下命令<code>minikube status</code>命令：</p><div class="highlight"><pre><code class="language-yaml"><span class="w"> </span><span class="l">minikube</span><span class="w">
</span><span class="w"> </span><span class="nt">type</span><span class="p">:</span><span class="w"> </span><span class="l">Control Plane</span><span class="w">
</span><span class="w"> </span><span class="nt">host</span><span class="p">:</span><span class="w"> </span><span class="l">Running</span><span class="w">
</span><span class="w"> </span><span class="nt">kubelet</span><span class="p">:</span><span class="w"> </span><span class="l">Running</span><span class="w">
</span><span class="w"> </span><span class="nt">apiserver</span><span class="p">:</span><span class="w"> </span><span class="l">Running</span><span class="w">
</span><span class="w"> </span><span class="nt">kubeconfig</span><span class="p">:</span><span class="w"> </span><span class="l">Configured</span><span class="w">
</span><span class="w"> </span><span class="l">​</span><span class="w">
</span><span class="w"> </span><span class="l">minikube-m02</span><span class="w">
</span><span class="w"> </span><span class="nt">type</span><span class="p">:</span><span class="w"> </span><span class="l">Worker</span><span class="w">
</span><span class="w"> </span><span class="nt">host</span><span class="p">:</span><span class="w"> </span><span class="l">Running</span><span class="w">
</span><span class="w"> </span><span class="nt">kubelet</span><span class="p">:</span><span class="w"> </span><span class="l">Running</span></code></pre></div><p data-pid="o0q1nyoq">这<code>minikube mount</code> <a href="https://minikube.sigs.k8s.io/docs/handbook/mount/#9p-mounts" target="_blank">命令</a>将主机目录挂载到 VM 中（请注意，<a href="https://en.wikipedia.org/wiki/9P_(protocol)" target="_blank">9P</a> 协议用于挂载）。因此，您可以通过将 HostPath 卷挂载到 Pod 中来直接编辑主机文件（否<code>docker cp</code>是需要的;但是，如果您愿意，可以使用该命令）。</p><p data-pid="pVw0pkch">请注意，如果 9P 与大量文件一起使用，则会出现性能和可靠性问题。虚拟化系统的（VirtualBox，KVM，VMware）文件系统选项可以帮助您解决这个问题。</p><p data-pid="vr0Wl7SP">Minikube提供了一组插件，您可以在集群中轻松激活它们：</p><div class="highlight"><pre><code class="language-bash"> $ minikube addons <span class="nb">enable</span> dashboard
 …
 * The <span class="s1">'dashboard'</span> addon is enabled
 $ minikube addons list
 …
 <span class="p">|</span> dashboard                   <span class="p">|</span> minikube <span class="p">|</span> enabled    <span class="p">|</span>
 …
 $ kubectl -n kubernetes-dashboard get pod
 NAME                                        READY   STATUS    RESTARTS   AGE
 dashboard-metrics-scraper-f6647bd8c-rrxq6   1/1     Running   <span class="m">0</span>          29s
 kubernetes-dashboard-968bcb79-tk5qt         1/1     Running   <span class="m">0</span>          29s</code></pre></div><p data-pid="m5OLBCkg">同样，您可以启用注册表，入口，Istio 和许多其他<a href="https://minikube.sigs.k8s.io/docs/handbook/addons/" target="_blank">组件</a>。.</p><p data-pid="j12OEipI">Minikube 还可以同时处理具有不同配置文件的多个集群：</p><div class="highlight"><pre><code class="language-yaml"><span class="w"> </span><span class="l">$ minikube start -p minik2</span><span class="w">
</span><span class="w"> </span>*<span class="w"> </span><span class="p">[</span><span class="l">minik2] minikube v1.20.0 on Ubuntu 18.04</span><span class="w">
</span><span class="w"> </span><span class="nt">* Automatically selected the docker driver. Other choices</span><span class="p">:</span><span class="w"> </span><span class="l">kvm2, ssh</span><span class="w">
</span><span class="w"> </span>*<span class="w"> </span><span class="l">Starting control plane node minik2 in cluster minik2</span><span class="w">
</span><span class="w"> </span><span class="l">…</span><span class="w">
</span><span class="w"> </span><span class="l">$ minikube profile list</span><span class="w">
</span><span class="w"> </span><span class="l">|----------|-----------|---------|--------------|------|---------|---------|-------|</span><span class="w">
</span><span class="w"> </span><span class="l">| Profile  | VM Driver | Runtime |      IP      | Port | Version | Status  | Nodes |</span><span class="w">
</span><span class="w"> </span><span class="l">|----------|-----------|---------|--------------|------|---------|---------|-------|</span><span class="w">
</span><span class="w"> </span><span class="l">| minik2   | docker    | docker  | 192.168.58.2 | 8443 | v1.20.2 | Running |     1 |</span><span class="w">
</span><span class="w"> </span><span class="l">| minikube | docker    | docker  | 192.168.49.2 | 8443 | v1.20.2 | Running |     2 |</span><span class="w">
</span><span class="w"> </span><span class="l">|----------|-----------|---------|--------------|------|---------|---------|-------|</span></code></pre></div><p class="ztext-empty-paragraph"><br></p><h3><b>6. 替代解决方案</b></h3><p data-pid="KgbgKkJL">有些项目没有被纳入本综述，因为它们不太受欢迎或出于其他原因。例如：</p><ul><li data-pid="03CbXr-o"><a href="https://github.com/code-ready/crc" target="_blank">Red Hat CRC</a> 工具（CodeReady Containers;750+ GitHub stars）取代<a href="https://github.com/minishift/minishift" target="_blank">了 Minishift</a>，在笔记本电脑/台式机上运行最小的 OpenShift 4.x 集群。</li><li data-pid="dEsNylEA">Weaveworks的<a href="https://github.com/weaveworks/wks-quickstart-firekube" target="_blank">Firekube</a>（~300 GitHub星）是一个在<a href="https://github.com/firecracker-microvm/firecracker" target="_blank">Firecracker</a>虚拟机中运行的Kubernetes集群，也值得一提。但是，它似乎并不活跃。</li></ul><p class="ztext-empty-paragraph"><br></p><h2><b>支持的操作系统</b></h2><p data-pid="sgw9TZgx">上述所有发行版都在 Linux 上运行。但是，即使您的主机具有不同的操作系统（借助虚拟化工具），您也可以使用它们：</p><ul><li data-pid="PdfUasVO"><a href="https://multipass.run/" target="_blank">Multipass</a> 和 <a href="https://www.virtualbox.org/" target="_blank">VirtualBox</a> 适用于大多数情况;</li><li data-pid="EJcjrezc">在其他情况下，可能需要使用特殊的虚拟化工具，例如 Windows 上的 <a href="https://docs.microsoft.com/en-us/windows/wsl/about" target="_blank">WSL</a>。</li></ul><p data-pid="36-gQpqY">对于kind，k3d和Minikube，您可以使用一个Linux VM（用于基本集群），而在k0s，Microk8s和k3s的情况下，您将需要创建多个与集群节点数量相等的VM。</p><h2><b>比较表</b></h2><p data-pid="3VRXR3uB">以下是基本功能的摘要：</p><table data-draft-node="block" data-draft-type="table" data-size="normal" data-row-style="normal"><tbody><tr><th></th><th>K0s</th><th>MicroK8s</th><th>kind</th><th>K3S + K3D</th><th>minikube</th></tr><tr><td>管理节点创建/删除</td><td>✗</td><td>✗</td><td>✓</td><td>✓</td><td>✓</td></tr><tr><td>节点管理系统</td><td>✗</td><td>✗</td><td>docker</td><td>docker</td><td>virtualbox， vmwarefusion， kvm2， vmware， none， docker， podman， ssh</td></tr><tr><td>容器运行时</td><td>containerd</td><td>containerd</td><td>containerd, CRI-O</td><td>CRI-O</td><td>Docker, CRI-O, containerd</td></tr><tr><td>默认 CNI</td><td>Calico</td><td>Calico</td><td>kindnet</td><td>Flannel</td><td>bridge</td></tr><tr><td>挂载主机操作系统的文件系统</td><td>HostPath</td><td>HostPath</td><td>HostPath + docker mount</td><td>HostPath + docker mount</td><td>HostPath + … (depends on the virtualization system)</td></tr><tr><td>插件</td><td>✗</td><td>✓</td><td>✗</td><td>✗</td><td>✓</td></tr><tr><td>非特权用户创建群集的能力</td><td>✗</td><td>✗</td><td>✓</td><td>✓</td><td>✓</td></tr><tr><td>Vanilla Kubernetes</td><td>✓</td><td>✓</td><td>✓</td><td>✗</td><td>✓</td></tr></tbody></table><p data-pid="84xzLauk"> Vanilla Kubernetes 指纯净、原生的 Kubernetes，一般还有 Vanilla JavaScript/Vanilla Linux 等用法，指原生 JavaScript 或 Linux，而不是它们的方言版或发行版本。</p><p data-pid="FJPF33er">原生 Kubernetes 指的是 Kubernetes 的原生未修改版本，提供源代码下载。</p><p data-pid="NlY7ABed">之所以称为原生版，是因为在软件界有一个长达几十年的传统，即打上 “Vanilla” 原生标签的软件被部署到任何应用程序或平台上时，表示这是没有修改过的官方版本。类似于，我们还会听到“原生 Linux” ，这是指使用纯粹的、官方的 Linux 内核源代码构建 Linux 内核，而不像在 Linux 发行版本中，会修改 Linux 内核程序。</p><p data-pid="-o3UNHCM">与原生 Kubernetes 相对的是 Kubernetes 发行版，例如 Rancher，Red Hat OpenShift，或基于云的 Kubernetes 服务，例如 Amazon EKS。这些发行版采用了开源 Kubernets 代码，并将其集成到更广泛的平台中，而这些平台通常包含不属于 Kubernetes 本身的管理、监视和安全工具。这些平台中的很多平台还提供安装程序，简化 Kubernetes 安装程序。</p><p data-pid="1Vi_7boG">当然，最近也有人提出了不适用发行版本的 Kubernets 的5个理由，具体可以参考：<a href="https://www.itprotoday.com/devops/5-reasons-not-use-kubernetes-distributions" target="_blank">5 Reasons Not to Use Kubernetes Distributions</a> :::</p><p class="ztext-empty-paragraph"><br></p><h2><b>结论</b></h2><p data-pid="EV4vkVSH">比较是在特定任务（本地运行的沙盒）的上下文中进行的，但上面的一些发行版是为利基使用场景设计的。例如，Canonical 的 MicroK8s 和 Rancher 的 K3s 针对物联网和边缘计算。因此，我应该重申，最终的选择 <b>将在很大程度上取决于手头的任务</b>、资源考虑和网络基础设施要求。我希望以上信息对您做出正确的选择有所帮助。</p><h2><b>有用的外部链接</b></h2><ul><li data-pid="NIAzbaEf"><a href="https://en.sokube.ch/post/k3s-k3d-k8s-a-new-perfect-match-for-dev-and-test-1" target="_blank">K3S + K3D = K8S：开发和测试的新完美匹配</a></li><li data-pid="WBDOCGxd"><a href="https://habd.as/post/kubernetes-macos-k3s-k3d-rancher/" target="_blank">带有 K3s、K3d 和 Rancher 的 macOS 上的 K8s</a></li><li data-pid="xXrk7uWp"><a href="https://www.reddit.com/r/kubernetes/comments/n2bsrz/k3s_vs_microk8s_vs_k0s_and_thoughts_about_their/" target="_blank">K3S vs Microk8S vs K0s 以及对未来的想法</a></li><li data-pid="vrRsWAls"><a href="https://www.reddit.com/r/kubernetes/comments/be0415/k3s_minikube_or_microk8s/" target="_blank">K3s，minikube还是microk8s？</a></li><li data-pid="LSLsDnTa"><a href="https://faun.pub/environment-for-comparing-several-on-premise-kubernetes-distributions-k3s-kind-kubeadm-a53675a80a00" target="_blank">用于比较几个内部部署 Kubernetes 发行版（K3s、MicroK8s、KinD、kubeadm）的环境</a></li><li data-pid="CRRNvghn"><a href="https://www.padok.fr/en/blog/minikube-kubeadm-kind-k3s" target="_blank">MiniKube， Kubeadm， Kind， K3S， 如何开始使用 Kubernetes？</a></li><li data-pid="HWCT-vi_"><a href="http://ceur-ws.org/Vol-2839/paper11.pdf" target="_blank">分析轻量级容器平台：MicroK8s 和 K3s 与 Kubernetes 的比较</a><i>（性能测试）</i></li><li data-pid="SbE0fbVm"><a href="https://brennerm.github.io/posts/minikube-vs-kind-vs-k3s.html" target="_blank">Minikube vs. kind vs. k3s – 我应该使用什么？</a><i>（总结）</i></li><li data-pid="UxRcO_Wu"><a href="https://searchitoperations.techtarget.com/answer/Evaluate-3-ways-to-run-Kubernetes-locally" target="_blank">评估在本地运行 Kubernetes 的 3 种方法</a></li><li data-pid="kiMP0PSY"><a href="https://docs.tilt.dev/choosing_clusters.html" target="_blank">选择本地开发群集</a></li><li data-pid="vjvnzpd5"><a href="https://kubevious.io/blog/post/what-is-mirantis-k0s-and-how-it-compares-with-rancher-k3s" target="_blank">什么是米兰蒂斯k0s，它与牧场主k3s有何不同</a></li><li data-pid="baypzhOT"><a href="https://www.cncf.io/wp-content/uploads/2020/08/CNCF-Webinar-Navigating-the-Sea-of-Local-Clusters-.pdf" target="_blank">驾驭 Kubernetes 本地集群的海洋</a></li></ul><h2><b>相关文章：</b></h2><ul><li data-pid="QA-Am8Ld"><a href="https://blog.palark.com/comparing-ingress-controllers-for-kubernetes/" target="_blank">比较 Kubernetes 的入口控制器</a></li><li data-pid="D_Y_qpiO"><a href="https://blog.palark.com/open-source-self-hosted-serverless-frameworks-for-kubernetes/" target="_blank">Kubernetes 自托管无服务器框架概述：OpenFaaS、Knative、OpenWhisk、Fission</a></li><li data-pid="W7V-gES1"><a href="https://blog.palark.com/logs-in-kubernetes-expectations-vs-reality/" target="_blank">Kubernetes 中的日志：期望与现实</a></li></ul><p class="ztext-empty-paragraph"><br></p><h2><b>END 链接</b></h2><ul><li data-pid="X6DNLFKB"><a href="typora://app/README.md" target="_blank">Ⓜ️回到目录 </a></li><li data-pid="4H-L2bln"><b><a href="https://nsddd.top/archives/contributors" target="_blank"> 参与贡献 ❤️‍  </a></b>)</li><li data-pid="3V78Qqjj">✴️版权声明 © ：本书所有内容遵循<a href="http://zh.wikipedia.org/wiki/Wikipedia:CC-by-sa-3.0%E5%8D%8F%E8%AE%AE%E6%96%87%E6%9C%AC" target="_blank">CC-BY-SA 3.0协议（署名-相同方式共享）©</a> </li></ul><p></p></div> </details> 
 <hr /> 
<!-- ZHIHU:END -->
---

</br>
