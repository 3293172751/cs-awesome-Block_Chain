+ [author(Github)](https://github.com)
# 第41节 分布式架构
+ [回到目录](../README.md)
+ [回到项目首页](../../README.md)
+ [上一节](40.md)
> ❤️💕💕CS自学指南,大学教育无论是深度还是广度都没有办法支撑我们的职业素养,这个板块算是自己在CS学习中额外补充和记录的。个人博客:[http://nsddd.top](http://nsddd.top/)
---
[TOC]

## 什么是分布式架构

最近几年，我们一直在谈论各式各样的架构，如高并发架构、异地多活架构、容器化架构、微服务架构、高可用架构、弹性化架构等。还有和这些架构相关的管理型的技术方法，如 DevOps、应用监控、自动化运维、SOA 服务治理、去 IOE 等。

面对这么多纷乱的技术，我看到很多团队或是公司都是一个一个地去做这些技术，非常辛苦，也非常累。这样的做法就像我们在撑开一张网里面一个一个的网眼。

我们需要找到一个总线，这样可以从全局上观察分布式架构，有种更清晰的认知。



**分布式系统目标：** 

1. 增大系统容量，能承载更高的并发 

2. 加强系统可用，避免单点故障



分布式系统优势，比如：

1. 因为模块化，所以系统模块重用度更高
2. 因为软件服务模块被拆分，开发和发布速度可以并行而变得更快
3. 系统扩展性更高；团队协作流程也会得到改善；……



### 单体和分布式优缺点

![image-20230131130509606](http://sm.nsddd.top/sm202301311305813.png)

**带来的问题：**

1. 架构设计变得复杂（尤其是其中的分布式事务）。
2. 部署单个服务会比较快，但是如果一次部署需要多个服务，流程会变得复杂。
3. 系统的吞吐量会变大，但是响应时间会变长。
4. 运维复杂度会因为服务变多而变得很复杂。
5. 架构复杂导致学习曲线变大。
6. 测试和查错的复杂度增大。
7. 技术多元化，这会带来维护和运维的复杂度。
8. 管理分布式系统中的服务和调度变得困难和复杂。



### SOA 和 微服务

从 20 世纪 70 年代的模块化编程，80 年代的面向事件设计，90 年代的基于接口 / 构件设计，这个世界很自然地演化出了 SOA——基于服务的架构。SOA 架构是构造分布式计算应用程序的方法。它将应用程序功能作为服务发送给最终用户或者其他服务。

而 2010 年后，出现了微服务架构，这个架构更为松耦合。每一个微服务都能独立完整地运行（所谓的自包含），后端单体的数据库也被微服务这样的架构分散到不同的服务中。而它和传统 SOA 的差别在于，服务间的整合需要一个服务编排或是服务整合的引擎。就好像交响乐中需要有一个指挥来把所有乐器编排和组织在一起。

**这个编排和组织引擎可以是工作流引擎，也可以是网关。当然，还需要辅助于像容器化调度这样的技术方式，如 Kubernetes。**

+ [微服务架构 Microservices ](https://martinfowler.com/articles/microservices.html)

微服务的出现使得开发速度变得更快，部署快，隔离性高，系统的扩展度也很好，但是在集成测试、运维和服务管理等方面就比较麻烦了。所以，需要一套比较好的微服务 PaaS 平台。就像 Spring Cloud 一样需要提供各种配置服务、服务发现、智能路由、控制总线……还有像 Kubernetes 提供的各式各样的部署和调度方式。



## 分布式系统技术栈

构建分布式系统说白了就是干两件事。一是提高整体架构的吞吐量，服务更多的并发和流量，二是为了提高系统的稳定性，让系统的可用性更高。



### 提高架构性能常用技术

![image-20230131141903964](http://sm.nsddd.top/sm202301311419190.png)



### 提高系统稳定性的常用技术

![image-20230131142029068](http://sm.nsddd.top/sm202301311420178.png)

> 上述这些技术非常有技术含量，而且需要投入大量的时间和精力。



## 分布式技术问题

引入分布式系统，会引入一堆技术问题，需要从以下几个方面来解决:

1. 服务治理。服务拆分、服务调用、服务发现、服务依赖、服务的关键度定义…… 服务治理的最大意义是需要把服务间的依赖关系、服务调用链，以及关键的服务给梳理出来，并对这些服务进行性能和可用性方面的管理。
2. 架构软件管理。服务之间有依赖，而且有兼容性问题，所以，整体服务所形成的架构需要有架构版本管理、整体架构的生命周期管理，以及对服务的编排、聚合、事务处理等服务调度功能。
3. DevOps。分布式系统可以更为快速地更新服务，但是对于服务的测试和部署都会是挑战。所以，还需要 DevOps 的全流程，其中包括环境构建、持续集成、持续部署等。
4. 自动化运维。有了 DevOps 后，我们就可以对服务进行自动伸缩、故障迁移、配置管理、状态管理等一系列的自动化运维技术了。
5. 资源调度管理。应用层的自动化运维需要基础层的调度支持，也就是云计算 IaaS 层的计算、存储、网络等资源调度、隔离和管理。
6. 整体架构监控。如果没有一个好的监控系统，那么自动化运维和资源调度管理只可能成为一个泡影，因为监控系统是你的眼睛。没有眼睛，没有数据，就无法进行高效运维。所以说，监控是非常重要的部分。这里的监控需要对三层系统（应用层、中间件层、基础层）进行监控。
7. 流量控制。最后是我们的流量控制，负载均衡、服务路由、熔断、降级、限流等和流量相关的调度都会在这里，包括灰度发布之类的功能也在这里。

**要具备这些技术可以看到特别难，但是现在有 docker 和 Kubernetes，大大的减少了这些入门门槛。**



### 分布式关键技术

总结一下上面讲述的内容，你不难发现，分布式系统有五个关键技术，它们是：

1. 全栈系统监控；
2. 服务 / 资源调度；
3. 流量调度；
4. 状态 / 数据调度；
5. 开发和运维的自动化。

![image-20230131143127026](http://sm.nsddd.top/sm202301311431122.png)



**下面将会依次讲解分布式的五大关键技术   |**



## 全栈系统监控

作为监控系统的眼睛，全栈监控系统是非常重要的，或许我们在[Kubernetes中周边的第二个开源的项目Prometheus中获取到了灵感](https://github.com/prometheus/prometheus)。

**完成功能**：

1. 全栈监控；
2. 关联分析；
3. 跨系统调用的串联；
4. 实时报警和自动处置；
5. 系统性能分析



### 多层体系监控

**全栈监控，其实就是三层监控：**

+ 基础层：监控主机和底层资源。比如：CPU、内存、网络吞吐、硬盘 I/O、硬盘使用等。
+ 中间层：就是中间件层的监控。比如：Nginx、Redis、ActiveMQ、Kafka、MySQL、Tomcat 等。
+ 应用层：监控应用层的使用。比如：HTTP 访问的吞吐量、响应时间、返回码、调用链路分析、性能瓶颈，还包括用户端的监控。

![image-20230131145921150](http://sm.nsddd.top/sm202301311459379.png)



### 什么是好的监控系统



**满足以下要求**：

1. 关注于整体应用的 SLA。主要从为用户服务的 API 来监控整个系统。
2. 关联指标聚合。把有关联的系统及其指标聚合展示。主要是三层系统数据：基础层、平台中间件层和应用层。其中，最重要的是把服务和相关的中间件以及主机关联在一起，服务有可能运行在 Docker 中，也有可能运行在微服务平台上的多个 JVM 中，也有可能运行在 Tomcat 中。总之，无论运行在哪里，我们都需要把服务的具体实例和主机关联在一起，否则，对于一个分布式系统来说，定位问题犹如大海捞针。
3. 快速故障定位。对于现有的系统来说，故障总是会发生的，而且还会频繁发生。故障发生不可怕，可怕的是故障的恢复时间过长。所以，快速地定位故障就相当关键。快速定位问题需要对整个分布式系统做一个用户请求跟踪的 trace 监控，我们需要监控到所有的请求在分布式系统中的调用链，这个事最好是做成没有侵入性的。



换句话说，一个好的监控系统主要是为以下两个场景所设计的：

**体检：**

+ 容量管理。提供一个全局的系统运行时数据的展示，可以让工程师团队知道是否需要增加机器或者其它资源。
+ 性能管理。可以通过查看大盘，找到系统瓶颈，并有针对性地优化系统和相应代码。



**急诊：**

+ 定位问题。可以快速地暴露并找到问题的发生点，帮助技术人员诊断问题。
+ 性能分析。当出现非预期的流量提升时，可以快速地找到系统的瓶颈，并帮助开发人员深入代码。
+ 只有做到了上述的这些关键点才能是一个好的监控系统。



### 如何做一个好的监控系统

1. 服务调用链跟踪。这个监控系统应该从对外的 API 开始，然后将后台的实际服务给关联起来，然后再进一步将这个服务的依赖服务关联起来，直到最后一个服务（如 MySQL 或 Redis），这样就可以把整个系统的服务全部都串连起来了。这个事情的最佳实践是 Google Dapper 系统，其对应于开源的实现是 Zipkin。对于 Java 类的服务，我们可以使用字节码技术进行字节码注入，做到代码无侵入式。

![image-20230131150803445](http://sm.nsddd.top/sm202301311508618.png)





2. 服务调用时长分布。使用 Zipkin，可以看到一个服务调用链上的时间分布，这样有助于我们知道最耗时的服务是什么。下图是 Zipkin 的服务调用时间分布。

![image-20230131150835782](http://sm.nsddd.top/sm202301311508932.png)



3. 服务的 TOP N 视图。所谓 TOP N 视图就是一个系统请求的排名情况。一般来说，这个排名会有三种排名的方法：

+ 按调量排名，
+ 按请求最耗时排名，
+ 按热点排名（一个时间段内的请求次数的响应时间和）。

![img](http://sm.nsddd.top/sm202301311510646.png)



4. 数据库操作关联。对于 Java 应用，我们可以很方便地通过 JavaAgent 字节码注入技术拿到 JDBC 执行数据库操作的执行时间。对此，我们可以和相关的请求对应起来。

![img](http://sm.nsddd.top/sm202301311510740.png)

5. 服务资源跟踪。我们的服务可能运行在物理机上，也可能运行在虚拟机里，还可能运行在一个 Docker 的容器里，Docker 容器又运行在物理机或是虚拟机上。我们需要把服务运行的机器节点上的数据（如 CPU、MEM、I/O、DISK、NETWORK）关联起来。

   这样一来，我们就可以知道服务和基础层资源的关系。如果是 Java 应用，我们还要和 JVM 里的东西进行关联，这样我们才能知道服务所运行的 JVM 中的情况（比如 GC 的情况）。

所以，一个分布式系统，或是一个自动化运维系统，或是一个 Cloud Native 的云化系统，最重要的事就是把监控系统做好。在把数据收集好的同时，更重要的是把数据关联好。这样，我们才可能很快地定位故障，进而才能进行自动化调度。

![image-20230131151149630](http://sm.nsddd.top/sm202301311511729.png)





## 分布式系统关键技术：服务调度

[典型的 Native Cloud 服务治理的开放平台 Istio](https://github.com/istio/istio)

同样的 Istio 和 Kubernetes 结合适用于 Service Mesh 形态的用于服务治理的开放平台



### 服务依赖

因为依赖关系就像“铁锁连环”一样，一个服务的问题很容易出现一条链上的问题。因此，传统的 SOA 希望通过 ESB 来解决服务间的依赖关系，这也是为什么微服务中希望服务间是没有依赖的，而让上层或是前端业务来整合这些后台服务。



### 服务状态和生命周期管理

我们还需要有一个服务发现的中间件，这个中间件是非常非常关键的。因为这个“架构城市”是非常动态的，有的服务会新加进来，有的会离开，有的会增加更多的实例，有的会减少，有的服务在维护过程中（发布、伸缩等），所以我们需要有一个服务注册中心，来知道这么几个事。

+ 整个架构中有多少种服务？
+ 这些服务的版本是什么样的？
+ 每个服务的实例数有多少个，它们的状态是什么样的?
+ 每个服务的状态是什么样的？是在部署中，运行中，故障中，升级中，还是在回滚中，伸缩中，或者是在下线中……



这个服务注册中心有点像我们系统运维同学说的 CMDB 这样的东西，它也是非常之关键的，因为没有它，我们将无法知道这些服务运作的状态和情况。

有了这些服务的状态和运行情况之后，你就需要对这些服务的生命周期进行管理了。服务的生命周期通常会有以下几个状态：

1. Provision，代表在供应一个新的服务；
2. Ready，表示启动成功了；
3. Run，表示通过了服务健康检查；
4. Update，表示在升级中；
5. Rollback，表示在回滚中；
6. Scale，表示正在伸缩中（可以有 Scale-in 和 Scale-out 两种）；
7. Destroy，表示在销毁中；
8. Failed，表示失败状态。

有了这些服务的状态和生命周期的管理，以及服务的重要程度和服务的依赖关系，再加上一个服务运行状态的拟合控制，你一下子就有了管理整个分布式服务的手段了。



### 资源 / 服务调度

服务和资源的调度有点像操作系统。操作系统一方面把用户进程在硬件资源上进行调度，另一方面提供进程间的通信方式，可以让不同的进程在一起协同工作。服务和资源调度的过程，与操作系统调度进程的方式很相似，主要有以下一些关键技术。

+ 服务状态的维持和拟合。
+ 服务的弹性伸缩和故障迁移。
+ 作业和应用调度。
+ 作业工作流编排。
+ 服务编排。



### 服务状态的维持和拟合

所谓服务状态不是服务中的数据状态，而是服务的运行状态，换句话说就是服务的 Status，而不是 State。也就是上述服务运行时生命周期中的状态——Provision，Ready，Run，Scale，Rollback，Update，Destroy，Failed……

服务运行时的状态是非常关键的。服务运行过程中，状态也是会有变化的，这样的变化有两种。

+ 一种是没有预期的变化。比如，服务运行因为故障导致一些服务挂掉，或是别的什么原因出现了服务不健康的状态。而一个好的集群管理控制器应该能够强行维护服务的状态。在健康的实例数变少时，控制器会把不健康的服务给摘除，而又启动几个新的，强行维护健康的服务实例数。
+ 另外一种是预期的变化。比如，我们需要发布新版本，需要伸缩，需要回滚。这时，集群管理控制器就应该把集群从现有状态迁移到另一个新的状态。这个过程并不是一蹴而就的，集群控制器需要一步一步地向集群发送若干控制命令。这个过程叫“拟合”——从一个状态拟合到另一个状态，而且要穷尽所有的可能，玩命地不断地拟合，直到达到目的。



### 服务的弹性伸缩和故障迁移

有了上述的服务状态拟合的基础工作之后，我们就能很容易地管理服务的生命周期了，甚至可以通过底层的支持进行便利的服务弹性伸缩和故障迁移。

对于弹性伸缩，在上面我已经给出了一个服务伸缩所需要的操作步骤。还是比较复杂的，其中涉及到了：

底层资源的伸缩；服务的自动化部署；服务的健康检查；服务发现的注册；服务流量的调度。



### 服务工作流和编排

正如上面和操作系统做的类比一样，一个好的操作系统需要能够通过一定的机制把一堆独立工作的进程给协同起来。在分布式的服务调度中，这个工作叫做 Orchestration，国内把这个词翻译成“编排”。



## 流量调度

关于流量调度，现在很多架构师都把这个事和服务治理混为一谈了。我觉得还是应该分开的。一方面，服务治理是内部系统的事，而流量调度可以是内部的，更是外部接入层的事。另一方面，服务治理是数据中心的事，而流量调度要做得好，应该是数据中心之外的事，也就是我们常说的边缘计算，是应该在类似于 CDN 上完成的事。



对于一个流量调度系统来说，其应该具有的主要功能是：

1. 依据系统运行的情况，自动地进行流量调度，在无需人工干预的情况下，提升整个系统的稳定性；
2. 让系统应对爆品等突发事件时，在弹性计算扩缩容的较长时间窗口内或底层资源消耗殆尽的情况下，保护系统平稳运行。

这还是为了提高系统架构的稳定性和高可用性。

此外，这个流量调度系统还可以完成以下几方面的事情。

1. 服务流控。服务发现、服务路由、服务降级、服务熔断、服务保护等。
2. 流量控制。负载均衡、流量分配、流量控制、异地灾备（多活）等。
3. 流量管理。协议转换、请求校验、数据缓存、数据计算等。

所有的这些都应该是一个 API Gateway 应该做的事。



### 流量调度的关键技术

但是，作为一个 API Gateway 来说，因为要调度流量，首先需要扛住流量，而且还需要有一些比较轻量的业务逻辑，所以一个好的 API Gateway 需要具备以下的关键技术。

+ 高性能。API Gateway 必须使用高性能的技术，所以，也就需要使用高性能的语言。扛流量。
+ 要能扛流量，就需要使用集群技术。集群技术的关键点是在集群内的各个结点中共享数据。这就需要使用像 Paxos、Raft、Gossip 这样的通讯协议。因为 Gateway 需要部署在广域网上，所以还需要集群的分组技术。
+ 业务逻辑。API Gateway 需要有简单的业务逻辑，所以，最好是像 AWS 的 Lambda 服务一样，可以让人注入不同语言的简单业务逻辑。
+ 服务化。一个好的 API Gateway 需要能够通过 Admin API 来不停机地管理配置变更，而不是通过一个.conf 文件来人肉地修改配置。



### 状态数据调度

对于服务调度来说，最难办的就是有状态的服务了。这里的状态是 State，也就是说，有些服务会保存一些数据，而这些数据是不能丢失的，所以，这些数据是需要随服务一起调度的。



## paas

+ IAAS是基础设施，如服务器，网络 
+ paas是软件基础设施，以平台形式对外提供服务，提供软件开发的部署，运维能力，客户只要关注业务软件开发既可。 
+ SAAS是开箱即用的服务，如物流助手，电商网站

一个好的 PaaS 平台应该具有分布式、服务化、自动化部署、高可用、敏捷以及分层开放的特征，并可与 IaaS 实现良好的联动。

![image-20230131160707630](http://sm.nsddd.top/sm202301311607943.png)

下面这三件事是 PaaS 跟传统中间件最大的差别：

+ 服务化是 PaaS 的本质。软件模块重用，服务治理，对外提供能力是 PaaS 的本质。
+ 分布式是 PaaS 的根本特性。多租户隔离、高可用、服务编排是 PaaS 的基本特性。
+ 自动化是 PaaS 的灵魂。自动化部署安装运维，自动化伸缩调度是 PaaS 的关键。



![image-20230131161037838](http://sm.nsddd.top/sm202301311610097.png)

一个完整的 PaaS 平台会包括以下几部分：

1. PaaS 调度层 – 主要是 PaaS 的自动化和分布式对于高可用高性能的管理。
2. PaaS 能力服务层 – 主要是 PaaS 真正提供给用户的服务和能力。
3. PaaS 的流量调度 – 主要是与流量调度相关的东西，包括对高并发的管理。
4. PaaS 的运营管理 – 软件资源库、软件接入、认证和开放平台门户。
5. PaaS 的运维管理 – 主要是 DevOps 相关的东西。



## 分布式学习的经典

**基础理论**

+ CAP 定理
+ Fallacies of Distributed Computing

**经典资料**

1. Distributed systems theory for the distributed systems engineer
2. FLP Impossibility Result
3. An introduction to distributed systems
4. Distributed Systems for fun and profit
5. Distributed Systems: Principles and Paradigms
6. Scalable Web Architecture and Distributed Systems
7. Principles of Distributed Systems
8. Making reliable distributed systems in the presence of software errors
9. Designing Data Intensive Applications



### CAP定理

CAP 定理是分布式系统设计中最基础，也是最为关键的理论。它指出，分布式数据存储不可能同时满足以下三个条件。

1. 一致性（Consistency）：每次读取要么获得最近写入的数据，要么获得一个错误。
2. 可用性（Availability）：每次请求都能获得一个（非错误）响应，但不保证返回的是最新写入的数据。
3. 分区容忍（Partition tolerance）：尽管任意数量的消息被节点间的网络丢失（或延迟），系统仍继续运行。

也就是说，CAP 定理表明，在存在网络分区的情况下，一致性和可用性必须二选一。而在没有发生网络故障时，即分布式系统正常运行时，一致性和可用性是可以同时被满足的。这里需要注意的是，CAP 定理中的一致性与 ACID 数据库事务中的一致性截然不同。

掌握 CAP 定理，尤其是能够正确理解 C、A、P 的含义，对于系统架构来说非常重要。因为对于分布式系统来说，网络故障在所难免，如何在出现网络故障的时候，维持系统按照正常的行为逻辑运行就显得尤为重要。你可以结合实际的业务场景和具体需求，来进行权衡。



**关系：**

![image-20230131164240260](http://sm.nsddd.top/sm202301311642501.png)

+ CA (consistency + availability)，这样的系统关注一致性和可用性，它需要非常严格的全体一致的协议，比如 “两阶段提交”（2PC）。CA 系统不能容忍网络错误或节点错误，一旦出现这样的问题，整个系统就会拒绝写请求，因为它并不知道对面的那个结点是否挂掉了，还是只是网络问题。唯一安全的做法就是把自己变成只读的。
+ CP (consistency + partition tolerance)，这样的系统关注一致性和分区容忍性。它关注的是系统里大多数人的一致性协议，比如：Paxos 算法（Quorum 类的算法）。这样的系统只需要保证大多数结点数据一致，而少数的结点会在没有同步到最新版本的数据时变成不可用的状态。这样能够提供一部分的可用性。
+ AP (availability + partition tolerance)，这样的系统关心可用性和分区容忍性。因此，这样的系统不能达成一致性，需要给出数据冲突，给出数据冲突就需要维护数据版本。Dynamo 就是这样的系统。



**谷歌的CAP工程具体体现：**

![image-20230131164527656](http://sm.nsddd.top/sm202301311645784.png)



## END 链接

+ [回到目录](../README.md)
+ [上一节](40.md)
+ [下一节](42.md)
---
+ [参与贡献❤️💕💕](https://github.com/3293172751/Block_Chain/blob/master/Git/git-contributor.md)