+ [author(Github)](https://github.com)

# 第44节 规则引擎的设计和实现

+ [回到目录](../README.md)
+ [回到项目首页](../../README.md)
+ [上一节](43.md)
> ❤️💕💕CS自学指南,大学教育无论是深度还是广度都没有办法支撑我们的职业素养,这个板块算是自己在CS学习中额外补充和记录的。个人博客:[http://nsddd.top](http://nsddd.top/)
---
[TOC]

## 前言

规则引擎是一种嵌入在应用服务中的组件，可以将灵活多变的业务决策从服务代码中分离出来。通过使用预定义的语义模块来编写业务逻辑规则。在执行时接受数据输入、解释业务规则，并做出决策。规则引擎能大大提高系统的灵活性和扩展性。

在字节跳动，规则引擎已经在风控识别、活动运营、配置下发等场景得到了广泛的应用。开发人员可以将业务逻辑与服务代码解耦，实现灵活、高效的业务策略发布。目前公司内部基于规则引擎的动态决策系统已经承接了千万级别QPS的决策请求。

规则引擎的实现需要在满足大容量、高请求、低延迟的基础上尽可能做到简单易上手。本次课程将会带领大家实现一个简单版的规则引擎。



**目标：**

+ 了解规则引擎的组成部分和应用场景。
+ 学习并掌握规则引擎的设计与实现原理。
+ 明确一个规则引擎的设计目标，并完成各部分的设计与实现步骤拆解。
+ 动手实现规则引擎项目，完成预定目标。
+ *[课外扩展] 结合其他课程，完成一个在线* *规则引擎* *服务。*



### 规则引擎的组成部分

![image-20230204130944125](http://sm.nsddd.top/sm202302041309332.png)



### 应用场景

![image-20230204131010658](http://sm.nsddd.top/sm202302041310913.png)



### 原理

![image-20230204131107088](http://sm.nsddd.top/sm202302041311297.png)





## 编译原理相关的内容

+ **编译的概念:**
  + 编译的过程发生了什么？
  + 一般分为哪几个步骤，每个步骤的中间结果是什么？
+ **词法分析：**
  + 词法如何表示？| *正则文法*
  + 词法分析阶段的输出是什么
  + 词法分析阶段是怎么做的？
  + 词法分析可能会产生什么问题？
  + 如何解决词法分析过程中产生的问题？| *左递归问题怎么解决*
+ **语法分析**
  + 语法如何表示？上下文无关语法、巴克斯范式怎么理解
  + 语法分析阶段的输出是什么？ 一般怎么表示
  + 语法分析有哪些方式？什么是递归下降算法？
+ **抽象语法树**
  + 抽象语法树是什么？
  + 抽象语法树如何执行？
+ **类型检查**
  + 类型检查怎么做？有哪些方式？
  + 类型检查什么时候做？有什么区别？



### 回答

编译的过程就是 把某种语言的源程序，**在不改变语义的条件下**，转换成另一种语言程序(目标语言程序)

![image-20230204125818951](http://sm.nsddd.top/sm202302041258396.png)

+ 如果源代码编译后要在操作系统上运行，那目标代码就是汇编/机器代码。
+ 如果编译后是在虚拟机里执行，那目标代码就可以不是汇编代码，而是一种解释器可以理解的中间形式的代码即可。



### 解释型语言和编译型语言

有的语言提前把代码一次性转换完毕，这种就是编译型语言，用的转换工具就叫编译器，比如C、C++、Go。一次编译可重复执行

+ 编译后产物不能跨平台，不同系统对可执行文件的要求不同。.exe
+ 特殊的，c、c++、汇编、源代码也不能跨平台

有的语言则可以一边执行一边转化，用到哪里了就转哪里，这种就是解释性语言，用的转化工具叫虚拟机或者解释器，比如java python、javascript

![image-20230204125927024](http://sm.nsddd.top/sm202302041259102.png)



**关于** **Java** **和** **Python** **.**

+ Java 既有编译又有解释。但是编译并没有直接编译成机器码，而是编译成字节码，然后再放到虚拟机中执行。
+ Python 执行过程也是经过两个阶段，先编译成字节码 .pyc 再放到虚拟机中去执行

为什么一个叫虚拟机一个叫解释器

1. “虚拟机”对二进制字节码进行解释，而 “解释器” 是对程序文本进行解释。
2. 从历史上看，Java 是为解释二进制字节码而设计和实现的，而 Python 最初是为解释程序文本而设计和实现的。因此，“Java 虚拟机” 这个术语在 Java 社区中具有历史意义并且非常成熟，“Python 解释器” 这个术语在 Python 社区中具有历史意义并且非常成熟。人们倾向于延长传统并使用很久以前使用的相同术语。
3. 对于 Java，二进制字节码解释是程序执行的主要方式，而 JIT 编译只是一种可选的和透明的优化。而对于 Python，目前，程序文本解释是 Python 程序执行的主要方式，而编译成 Python VM 字节码只是一种可选的透明优化。



### 词法分析

把源代码字符串转换为词法单元 (Token) 的这个过程。

**确定的有限自动机 DFA |** **Deterministic Finite Automaton**

![image-20230204130632018](http://sm.nsddd.top/sm202302041306151.png)

确定的有限自动机就是一个状态机，它的状态数量是有限的。该状态机在任何一个状态，基于输入的字符，都能做一个确定的状态转换。

![image-20230204131714330](http://sm.nsddd.top/sm202302041317526.png)



### 语法分析

**词法分析是识别一个个的单词，而语法分析就是在词法分析的基础上识别出程序的语法结构。** 

*英语的单词和语法，单词和句子的组成~*

这个结构是一个树状结构。这棵树叫做抽象语法树（Abstract Syntax Tree，AST）。树的每个节点（子树）是一个语法单元，这个单元的构成规则就叫 “语法”。每个节点还可以有下级节点。

`Token -> AST`

![image-20230204131931043](http://sm.nsddd.top/sm202302041319231.png)

**这个过程就是数据结构的语法生成树，这个是唯一确定的，所以树也是唯一的。**



#### 上下文无关语法 Context-Free Grammar

语言句子无需考虑上下文，就可以判断正确性。 **可以使用巴科斯范式（BNF）来表达。**

```bash
...
a = 0;
...
这是一个赋值语句，无论此语句的前后是什么代码，此语句所代表的操作是确定的。即给变量a赋值等于0
```

![image-20230204132436451](http://sm.nsddd.top/sm202302041324644.png)

> 冒号左边的类型是定义的表达式类型，是可以由冒号右边的表示。

编程语言为什么不用人类的语言（自然语言），而是用上下文无关的文法呢？ 因为

1. 便于设计编译器。 客观上技术目前无法实现，如果使用了上下文相关文法，那就是真正实现了人工智能，NLP 领域将会有重大突破。
2. 便于代码开发维护。 如果开发出来的代码像高考的语文阅读理解一样，每个人都有不同的理解，那么，到底哪个才是作者真正想要表达的？如果人类都确定不了含义，那计算机同样也确定不了，最终结果就是错误执行或无法执行。
3. 汇编语言 / 机器语言是上下文无关的。CPU 执行指令时，读到哪条执行哪条。如果 CPU 需要考虑上下文，来决定一个语句到底要做什么，那么 CPU 执行一条语句会比现在慢千倍万倍。考虑上下文的事情，完全可以用户在编程的时候用算法实现。既然机器语言是上下文无关的，那高级语言也基本上是上下文无关的，可能有某些个别语法为了方便使用，设计成了上下文相关的，比如脚本语言的弱类型。在便于使用的同时，增加了解析器的复杂度。

> **自然语言处理**（英语：Natural Language Processing，[缩写](https://zh.wikipedia.org/wiki/缩写)作 **NLP**）是[人工智能](https://zh.wikipedia.org/wiki/人工智慧)和[语言学](https://zh.wikipedia.org/wiki/語言學)领域的分支学科。此领域探讨如何处理及运用[自然语言](https://zh.wikipedia.org/wiki/自然語言)；自然语言处理包括多方面和步骤，基本有认知、理解、生成等部分。



**递归下降算法概念不是很容易理解它，我们或许可以通过一个动画来演示一遍：**

![image-20230204141238694](http://sm.nsddd.top/sm202302041412915.png)

每一次推到都是一层递归，知道最后认识它，最后我们认识到标识符。

递归后回溯。

回溯后根据本身的表达式，继续递归。

**最后我们形成的就是右边的状态。这是一个递归语法树。**





**上下文无关语法 G：终结符集合 T + 非终结符集合 N + 产生式集合 P + 起始符号 S**

G 由 T、N、S 和 P 组成，由语法 G 推导出来的所有句子的集合称为 G 语言！

**终结符：** 组成串的基本符号。可以理解为词法分析器产生的 token 集合。比如 `+` `Id` `(` `)` 等

**非终结符：** 表示 token 的的集合的语法变量。比如 `stmt` `varDecl` 等等

```c
start：blockStmts ;               //起始
block : '{' blockStmts '}' ;      //语句块
blockStmts : stmt* ;              //语句块中的语句
stmt = varDecl | expStmt | returnStmt | block;   //语句
varDecl : type Id varInitializer？ ';' ;   //变量声明
type : Int | Long ;                        //类型
varInitializer : '=' exp ;                 //变量初始化
expStmt : exp ';' ;                        //表达式语句
returnStmt : Return exp ';' ;              //return语句
exp : add ;                                //表达式       
add : add '+' mul | mul;                   //加法表达式
mul : mul '*' pri | pri;                   //乘法表达式
pri : IntLiteral | Id | '(' exp ')' ;      //基础表达式 
复制代码
```

产生式：表示形式，S : AB ，就是说 S 的含义可以用语法 AB 进行表达

```
S : AB
A : aA | ε
B : b | bB
复制代码
```

`展开`(expand)：将 P(A->*u* ) 应用到符号串 vAw 中，得到新串 v_u_ **w

`折叠`(reduce)：将 P(A->*uu* ) 应用到符号串 v_uu_ w 中，得到新串 vAw

`推导`(derivate)：符号串 *u* 应用一系列产生式，变成符号串 *v* ，则 *u* =>*v：S => ab | b | bb*

**巴科斯范式**

BNF 是描述上下文无关理论的一种具体方法，通过 BNF 可以实现上下文无关文法的具体化、公式化、科学化，是实现代码解析的必要条件。

```
<expr> ::= <expr> + <term>
         | <expr> - <term>
         | <term>

<term> ::= <term> * <factor>
         | <term> / <factor>
         | <factor>

<factor> ::= ( <expr> )
           | Num
```

> BNF 本质上就是树形分解，分解成一棵抽象语法树

+ 每个产生式就是一个子树，在写编译器时，每个子树对应一个解析函数。
+ 叶子节点叫做 **终结符**，非叶子节点叫做 **非终结符**。

**递归下降算法 Recursive Descent Parsing**

基本思路就是按照语法规则去匹配 Token 串。比如说，变量声明语句的规则如下：

```
varDecl : types Id varInitializer？ ';' ;        //变量声明
varInitializer : '=' exp ;                       //变量初始化
exp : add ;                                      //表达式       
add : add '+' mul | mul;                         //加法表达式
mul : mul '*' pri | pri;                         //乘法表达式
pri : IntLiteral | Id | '(' exp ')' ;            //基础表达式
```

如果写成产生式格式，是下面这样：

```bash
varDecl -> types Id varInitializer ';' 
varInitializer -> '=' exp              
varInitializer -> ε
exp -> add
add -> add + mul
add -> mul
mul -> mul * pri
mul -> pri
pri -> IntLiteral
pri -> Id
pri -> ( exp )
```

而基于这个规则做解析的算法如下：

```
匹配一个数据类型(types)
匹配一个标识符(Id)，作为变量名称
匹配初始化部分(varInitializer)，而这会导致下降一层，使用一个新的语法规则：
   匹配一个等号
   匹配一个表达式(在这个步骤会导致多层下降：exp->add->mul->pri->IntLiteral)
   创建一个varInitializer对应的AST节点并返回
如果没有成功地匹配初始化部分，则回溯，匹配ε，也就是没有初始化部分。
匹配一个分号   
创建一个varDecl对应的AST节点并返回
```

![image-20230204134652257](http://sm.nsddd.top/sm202302041346395.png)

> int a = 2

+ 对于一个非终结符，要从左到右依次匹配其产生式中的每个项，包括非终结符和终结符。
+ 在匹配产生式右边的非终结符时，要下降一层，继续匹配该非终结符的产生式。
+ 如果一个语法规则有多个可选的产生式，那么只要有一个产生式匹配成功就行。如果一个产生式匹配不成功，那就回退回来，尝试另一个产生式。这种回退过程，叫做回溯（Backtracking）。



## 类型检查

词法分析和语法分析后的下一步就是类型检查。

![image-20230204142008557](http://sm.nsddd.top/sm202302041420771.png)







## END 链接

+ [回到目录](../README.md)
+ [上一节](43.md)
+ [下一节](45.md)



**参考：**

+ [节选](https://github.com/cubxxw/awesome-cs-course/blob/master/excerpt/%E3%80%90%E5%90%8E%E7%AB%AF%E4%B8%93%E5%9C%BA%20%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E4%B8%89%E3%80%91%E7%AC%AC%E4%BA%94%E5%B1%8A%E5%AD%97%E8%8A%82%E8%B7%B3%E5%8A%A8%E9%9D%92%E8%AE%AD%E8%90%A5.md)