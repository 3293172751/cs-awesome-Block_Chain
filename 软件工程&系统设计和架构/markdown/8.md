+ [author](https://github.com/3293172751)
# 第8节 测试
+ [回到目录](../README.md)
+ [回到项目首页](../../README.md)
+ [上一节](7.md)
> ❤️💕💕包含软件工程、算法与架构：设计模式、软件架构、协同开发、质量保障。更多关注我的博客：Myblog:[http://nsddd.top](http://nsddd.top/)
---
[TOC]

## 目标

今天的课后，你应该：

- 了解测试的价值，了解测试优先的编程流程；
- 能够判断测试套件的正确性、彻底性和大小；
- 能够通过划分输入空间并选择好的测试用例来为方法设计测试套件；
- 能够通过测量其代码覆盖率来判断一个测试套件；和
- 了解并知道何时使用黑盒测试与玻璃盒测试、单元测试与集成测试以及自动回归测试。

## 验证

测试是一个更通用的过程的示例，称为**验证**。验证的目的是发现程序中的问题，从而增加您对程序正确性的信心。验证包括：

- **关于程序的正式推理**，通常称为确认. 验证构造了程序正确的正式证明。手动进行验证很乏味，而对验证的自动化工具支持仍然是一个活跃的研究领域。然而，程序的小而关键的部分可能会被形式化验证，例如操作系统中的调度程序，或虚拟机中的字节码解释器，或[操作系统中的文件系统](http://www.csail.mit.edu/crash_tolerant_data_storage)。
- **代码审查。** 让其他人仔细阅读您的代码，并非正式地对其进行推理，可能是发现错误的好方法。这很像让别人校对你写的文章。我们在另一篇文章中讨论[代码审查](http://web.mit.edu/6.031/www/sp21/classes/04-code-review/)。
- **测试**。在仔细选择的输入上运行程序并检查结果。

即使有最好的验证，也很难在软件中达到完美的质量。以下是每 kloc（一千行源代码）的一些**典型残留缺陷率（软件发布后遗留的错误）**：

- 1 - 10 个缺陷/kloc：典型的行业软件。
- 0.1 - 1 个缺陷/kloc：高质量验证。Java 库可能会达到这个级别的正确性。
- 0.01 - 0.1 个缺陷/kloc：最好的安全关键验证。NASA 和 Praxis 等公司可以达到这一水平。

这对于大型系统来说可能是令人沮丧的。例如，如果您发布了一百万行典型的行业源代码（1 个缺陷/kloc），这意味着您错过了 1000 个错误！

## 为什么软件测试很难

不幸的是，这里有一些在软件世界中效果不佳的方法。

**详尽的测试**是不可行的。可能的测试用例空间通常太大而无法穷举。想象一下详尽地测试一个 32 位浮点乘法运算，`a*b`. 有2^64^个测试用例！

**杂乱无章的测试**（“试一试，看看它是否有效”）不太可能发现错误，除非程序有很多错误，以至于任意选择的输入更有可能失败而不是成功。它也不会增加我们对程序正确性的信心。

**随机或统计测试**不适用于软件。其他工程学科可以测试小的随机样本（例如制造的硬盘驱动器的 1%）并推断整个生产批次的缺陷率。物理系统可以使用许多技巧来加快时间，例如在 24 小时内打开冰箱 1000 次，而不是 10 年。这些技巧给出了已知的故障率（例如硬盘驱动器的平均寿命），但它们假设缺陷空间的连续性或均匀性。这对于物理工件是正确的。

但对于软件来说并非如此。软件行为在可能的输入空间中不连续且离散地变化。该系统似乎可以在广泛的输入范围内正常工作，然后在单个边界点突然失败。[著名](http://www.willamette.edu/~mjaneba/pentprob.html)的Pentium 部门错误影响了大约 90 亿分之一的部门。堆栈溢出、内存不足错误和数字溢出错误往往会突然发生，并且总是以相同的方式发生，而不是概率变化。这与物理系统不同，在物理系统中，通常有明显的证据表明系统正在接近故障点（桥梁中的裂缝）或故障概率性地分布在故障点附近（因此统计测试甚至可以在达到该点之前观察到一些故障） ）。

相反，必须仔细和系统地选择测试用例。系统测试技术是本次阅读的主要重点。



## 测试优先编程

在深入研究之前，我们需要定义一些术语：

- 一个**模块**是软件系统的一部分，可以与系统的其余部分分开设计、实现、测试和推理。在本篇文章中，我们将重点关注由 Java 方法表示的函数模块。在未来的阅读中，我们将拓宽视野以考虑更大的模块，例如具有多种交互方法的类。
- 一个*规格*（或规范）描述模块的行为。对于一个函数，规范给出了参数的类型以及对它们的任何附加约束（例如`sqrt`， 的参数必须是非负的）。它还给出了返回值的类型以及返回值与输入的关系。在 Java 代码中，规范由方法签名和上面描述其功能的注释组成。
- **一个模块有一个执行提供其行为**，并且*客户*使用该模块。对于一个函数，实现是方法的主体，客户端是调用该方法的其他代码。模块的规范约束了客户端和实现。从现在开始，我们将有更多关于规范、实现和客户端的内容要说。
- 一个*测试用例*是输入的特定选择，以及规范要求的预期输出行为。
- 一个*测试套件*是一个模块的一组测试用例。

您已经在问题集 0 中看到并使用了这些概念。您获得了一些 Java 方法的规范，并要求您为每个方法编写一个实现。您还获得了每个可以运行的方法的测试套件，以查看您的实现是否符合规范。

事实证明，在从头开始设计程序时，这是一个很好的模式。

在*测试优先编程*，您甚至在编写任何代码之前就编写了规范和测试。单个函数的开发按以下顺序进行：

1. **Spec**：为函数编写规范。
2. **测试**：编写执行规范的测试。
3. **实现**：编写实现。

一旦您的实现通过了您编写的测试，您就完成了。

测试优先编程的最大好处是避免错误。**不要在开发结束前离开测试，那时你有一大堆未经验证的代码。将测试留到最后只会使调试变得更长、更痛苦，因为代码中的任何地方都可能存在错误。在开发代码时测试代码要愉快得多。**



## 系统测试

我们希望系统地进行测试，而不是详尽的、随意的或随机的测试。 系统测试意味着我们以有原则的方式选择测试用例，目标是设计具有三个理想属性的测试套件：

- **正确**。正确的测试套件是规范的合法客户，它接受规范的所有合法实现而不会抱怨。这使我们可以自由地更改模块在内部的实现方式，而不必更改测试套件。
- **彻底**。一个完整的测试套件会发现实现中的实际错误，这些错误是由程序员可能犯的错误引起的。
- **小**。一个带有少量测试用例的小型测试套件首先编写起来更快，并且随着规范的发展更容易更新。小型测试套件的运行速度也更快。如果您的测试套件小而快，您将能够更频繁地运行测试。

根据这些标准，详尽的测试是彻底的，但大到不可行。随意的测试往往很小但不彻底。随机测试只能以大尺寸为代价才能实现彻底性。

设计一个既彻底又小规模的测试套件需要有正确的态度。通常，当您编写代码时，您的目标是使程序正常工作。但是作为一个测试套件设计者，你想让*它失败*。这是一个微妙但重要的区别。一个好的测试人员会故意戳出程序可能存在漏洞的所有地方，以便消除这些漏洞。

需要采取测试态度是测试优先编程的另一个论据。将您已经编写的代码视为珍贵的东西，脆弱的蛋壳，并非常轻松地对其进行测试以查看它是否有效，这太诱人了。但是，为了*进行彻底*的测试，你必须是残酷的。测试优先编程允许你在编写任何代码之前戴上你的测试帽子，并采用这种残酷的视角。

#### 阅读练习

正确性和彻底性

## 通过分区选择测试用例

创建一个好的测试套件是一个具有挑战性和有趣的设计问题。我们希望选择一组足够小的测试用例，以便易于编写和维护并快速运行，但又足够彻底以发现程序中的错误。

![划分函数的输入空间](https://sm.nsddd.top//typora/partition.png?mail:3293172751@qq.com)

为此，我们将输入空间划分为*子域*，每个都由一组输入组成。（*子域*这个名字来源于它是*域*的一个子集，一个数学函数的输入空间。）综合起来，子域形成了一个*分割*：完全覆盖输入空间的不相交集的集合，因此每个输入都恰好位于一个子域中。然后我们从每个子域中选择一个测试用例，这就是我们的测试套件。

子域背后的想法是将输入空间划分为程序具有相似行为的相似输入集。然后我们使用每组的一个代表。这种方法通过选择不同的测试用例并强制测试探索随机测试可能无法到达的输入空间区域，从而充分利用有限的测试资源。

#### 例子：`abs()`

让我们从 Java 库中的一个简单示例开始：[`abs()`](http://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/lang/Math.html#abs(int))在类中找到的整数函数[`Math`](http://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/lang/Math.html)：

```java
/**
 * ...
 * @param a  the argument whose absolute value is to be determined
 * @return the absolute value of the argument.
 */
public static int abs(int a)
```

（这不是 的完整规范`abs`，所以我们稍后会回到这个。但它会作为一个开始。）

在数学上，此方法是以下类型的函数：

**绝对：int → int**

![分区-abs](https://sm.nsddd.top//typora/abs-partition.png?mail:3293172751@qq.com)

该函数具有一维输入空间，由 a 的所有可能值*组成*。考虑绝对值函数的行为方式，我们可以先将输入空间划分为以下两个子*域*：*a* ≥ 0 } 和 { *a* | *一个*< 0 }。在第一个子域上，`abs`应该返回*一个*不变的。在第二个子域上，`abs`应该否定它。

为了紧凑地写一个分区，我们省略了 { *a* | ... } 每个集合描述的框架，并简单地编写一个谓词列表，如下所示：

```java
// partition: a >= 0; a < 0
```

为了为我们的测试套件选择测试用例，我们从分区的每个子域中选择一个任意值*a*，例如：

- *a* = 17 覆盖子域*a* ≥ 0
- *a* = -3 覆盖子域*a* < 0

#### 例子：`max()`

现在让我们看一下 Java 库中的另一个示例：整数[`max()`](http://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/lang/Math.html#max(int,int))函数，也可以在[`Math`](http://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/lang/Math.html).

```java
/**
 * ...
 * @param a  an argument
 * @param b  another argument
 * @return the larger of a and b.
 */
public static int max(int a, int b)
```

在数学上，这个方法是两个参数的函数：

**最大值：int × int → int**

![最大分区](https://sm.nsddd.top//typora/max-partition.png?mail:3293172751@qq.com)

所以我们有一个二维输入空间，由所有整数对（*a*，*b*）组成。现在让我们对其进行分区。*根据规范，选择子域 { ( a* , *b* ) |是有意义的。*a* < *b* } 和 { ( *a* , *b* ) | *a* > *b* }，因为规范要求每个人都有不同的行为。但我们不能止步于此，因为这些子域还不是输入空间的一个*分区*。一个分区必须完全覆盖一组可能的输入。所以我们需要添加 { ( *a* , *b* ) | *a* = *b*}。简而言之，分区如下所示：

```java
// partition: a < b; a > b; a = b
```

我们的测试套件可能是：

- ( *a* , *b* ) = (1, 2) 覆盖*a* < *b*
- ( *a* , *b* ) = (10, -8) 覆盖*a* > *b*
- ( *a* , *b* ) = (9, 9) 覆盖*a* = *b*



### 在分区中包含边界

错误经常发生在*边界*子域之间。一些例子：

- 0 是正数和负数的分界线
- 数值类型的最大值和最小值，例如`int`或`double`
- 集合类型的空性，例如空字符串、空列表或空集
- 序列的第一个和最后一个元素，如字符串或列表

为什么错误经常发生在边界处？一个原因是程序员经常**犯一些错误**，比如写`<=`而不是`<`，或者将计数器初始化为 0 而不是 1。另一个是某些边界可能需要在代码中作为特殊情况进行处理。另一个是边界可能是代码行为不连续的地方。例如，当`int`变量增长超过其最大正值时，它会突然变为负数。

事实证明，[`abs()`](http://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/lang/Math.html#abs(int))Java 中的函数在其中一个边界上以一种非常出乎意料的方式表现，规范描述如下：

```java
/**
 * ...
 * Note that if the argument is equal to the value of Integer.MIN_VALUE, 
 * the most negative representable int value, the result is that same value, 
 * which is negative.
 * ...
 */
```

所以有可能`abs`返回一个负整数！这是[二进制补码表示](https://en.wikipedia.org/wiki/Two's_complement#Most_negative_number)的一个特征。一个简单的理解方法[`Integer.MIN_VALUE`](http://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/lang/Integer.html#MIN_VALUE)是 -2 31但[`Integer.MAX_VALUE`](http://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/lang/Integer.html#MAX_VALUE)2 31 -1，所以 的否定`Integer.MIN_VALUE`正好在 的范围之外`int`。我们当然应该在测试中包含这些边界值。

我们将边界合并为分区中的单元素子域，因此测试套件必须将边界值作为测试用例包含在内。对于`abs`，我们将为每个相关边界添加子域：

- *a* = 0，因为`abs`在正数和负数上表现不同
- *a* = `Integer.MIN_VALUE`，最负的可能`int`值，因为规范在那里调用了一些不寻常的行为
- *a* = `Integer.MAX_VALUE`，最大正值`int`，用于对称性和完整性

然后我们原来的两个子域会缩小以排除边界值：{ *a* | 0 < *a* < `Integer.MAX_VALUE`} 和 { *a* | `Integer.MIN_VALUE`<*一*< 0 }。

这是输入空间的一个分区`abs`：五个子域是不相交的，完全覆盖了空间。紧凑地编写它的一种方法如下所示：

```java
// partition:
//     a = Integer.MIN_VALUE
//     Integer.MIN_VALUE < a < 0
//     a = 0
//     0 < a < Integer.MAX_VALUE
//     a = Integer.MAX_VALUE
```

我们的测试套件可能是：

- *a* = 0
- *一个*=`Integer.MIN_VALUE`
- *一个*=`Integer.MAX_VALUE`
- *a* = 17 覆盖子域 0 < *a* <`Integer.MAX_VALUE`
- *a* = -3 覆盖子域`Integer.MIN_VALUE`< *a* < 0



#### 例子：`BigInteger.multiply()`

让我们看一个稍微复杂一点的例子。 [`BigInteger`](http://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/math/BigInteger.html)是一个内置在 Java 库中的类，它可以表示任何大小的整数，这与原始类型不同，`int`并且`long`只有有限的范围。BigInteger 有一个[`multiply`](http://docs.oracle.com/en/java/javase/15/docs/api/java.base/java/math/BigInteger.html#multiply(java.math.BigInteger))将两个 BigInteger 值相乘的方法：

```java
/**
 * @param val another BigInteger
 * @return a BigInteger whose value is (this * val).
 */
public BigInteger multiply(BigInteger val)
```

例如，以下是它的使用方法：

```java
BigInteger a = new BigInteger("9500000000"); // 9.5 billion
BigInteger b = new BigInteger("2");
BigInteger ab = a.multiply(b); // should be 19 billion
```

![image-20220921112021486](https://sm.nsddd.top//typora/image-20220921112021486.png?mail:3293172751@qq.com)

这个例子表明，即使在方法的声明中只显式显示了一个参数，`multiply`它实际上是一个包含*两个*参数的函数：您正在调用该方法的对象（`a`在上面的示例中），以及您正在传入的参数括号（`b`在本例中）。在 Python 中，接收方法调用的对象将被显式命名为`self`方法声明中调用的参数。在 Java 中，您不会在参数中提及接收对象，而是调用它`this`而不是`self`.

因此，我们应该将其`multiply`视为一个函数，该函数接受两个输入，每个输入为 type `BigInteger`，并产生一个输出 type `BigInteger`：

**乘法：BigInteger × BigInteger → BigInteger**

我们再次有一个二维输入空间，由所有整数对（*a*，*b*）组成。考虑符号规则如何与乘法一起工作，我们可以从这些子域开始：

- *a*和*b*都是正数
- *a*和*b*都是负数
- *a*为正，*b*为负
- *a*为负，*b*为正

我们还应该检查一些乘法的边界值：

- *a*或*b*为 0，因为结果始终为 0
- *a*或*b*为 1，乘法的标识值

最后，因为 的目的`BigInteger`是表示任意大的整数，所以我们应该确保尝试非常大的整数，至少比最大的大`long`，大约是 2 63，一个 19 位十进制整数。

- *a*或*b*的大小或小或大（即，小到足以表示一个`long`值，或太大而不是 a `long`）



让我们将所有这些观察结果集中到整个 ( *a* , *b* ) 空间的单个分区中。我们将独立地选择*a*和*b*：

![分割乘法（）](https://sm.nsddd.top//typora/multiply-partition.png?mail:3293172751@qq.com)

- 0
- 1
- 小正整数（≤`Long.MAX_VALUE`且 > 1）
- 小负整数（≥`Long.MIN_VALUE`且 < 0）
- 大正整数 (> `Long.MAX_VALUE`)
- 大负整数 (< `Long.MIN_VALUE`)

所以这将产生 6 × 6 = 36 个子域，这些子域划分整数对空间。

为了从这个分区生成测试套件，我们将从网格的每个正方形中选择一个任意对 ( *a* , *b* )，例如：

- ( *a* , *b* ) = (0, 0) 覆盖 (0, 0)
- ( *a* , *b* ) = (0, 1) 覆盖 (0, 1)
- ( *a* , *b* ) = (0, 8392) 覆盖 (0, 小正整数)
- ( *a* , *b* ) = (0, -7) 覆盖 (0, 小负整数)
- …
- ( *a* , *b* ) = (-10 60 , -10 810 ) 覆盖（大负数，大负数）

右图显示了二维（a，b）空间是如何被这个分区划分的，点是我们可能选择完全覆盖该分区的测试用例。

### 使用多个分区

到目前为止，这些示例仅在整个输入空间中使用了一个分区——一组不相交的子域。对于具有多个参数的函数，这可能会变得昂贵。**每个参数可能有有趣的行为变化和几个边界值，因此从每个参数上的行为的笛卡尔积形成输入空间的单个分区会导致结果测试套件的大小组合爆炸。**我们已经在 中看到了这一点`multiply`，其中笛卡尔积分区已经有 6 × 6 = 36 个子域，需要覆盖 36 个测试用例。对于具有*n 个*参数的函数，笛卡尔积方法产生一个大小为*n的指数测试套件*，这对于手动测试创作很快变得不可行。

![用单独的 a 和 b 分区对 multiply() 进行分区](https://sm.nsddd.top//typora/multiply-a-b-partition.png?mail:3293172751@qq.com)

另一种方法是将每个输入*a*和*b*的特征视为输入空间的两个独立分区。一个分区只考虑*a*的值：

- ( *a* , *b* ) 使得*a* = 0, 1, 小正数, 小负数, 大正数, 大负数

而另一个分区只考虑*b*的值：

- ( *a* , *b* ) 使得*b* = 0, 1, 小正数, 小负数, 大正数, 大负数

这两个分区如右图所示。每个输入对 ( *a* , *b* ) 恰好属于每个分区的一个子域。

我们可以将这两个分区紧凑地写成如下：

```java
// partition on a:
//   a = 0
//   a = 1
//   a is small integer > 1
//   a is small integer < 0
//   a is large positive integer
//   a is large negative integer
//      (where "small" fits in long, and "large" doesn't)
// partition on b:
//   b = 0
//   b = 1
//   b is small integer > 1
//   b is small integer < 0
//   b is large positive integer
//   b is large negative integer
```

我们仍然希望用一个测试用例覆盖每个子域，但是现在一个测试用例可以覆盖来自不同分区的多个子域，从而使测试套件更加高效。我们只需 6 个测试用例就可以完全覆盖这两个分区，如右图所示。

![在 a 和 b 的符号上划分 multiply()](https://sm.nsddd.top//typora/multiply-sign-partition.png?mail:3293172751@qq.com)

独立分区*a*和*b*会增加您不再测试它们之间的交互的风险。例如，乘法中的符号处理可能是错误的来源，结果的符号取决于*a*和*b*的符号。但是我们可以添加一个额外的分区来捕获这种交互：

```java
// partition on signs of a and b:
//    a and b are both positive
//    a and b are both negative
//    a positive and b negative
//    a negative and b positive
//    one or both are 0
```

现在我们有三个分区，每个分区有 6、6 和 5 个子域，但我们不需要 6 × 6 × 5 测试用例的笛卡尔积来覆盖它们。包含 6 个精心挑选的测试用例的测试套件可以覆盖所有三个分区的子域。

我们可以继续以这种方式添加分区，因为我们更多地考虑规范并观察可能导致错误的其他行为变化。通过仔细选择测试用例，额外的分区应该需要很少（如果有的话）额外的测试用例。

有时我们可能希望在多个分区上使用笛卡尔积方法，以生成更全面的测试套件。但即使在这些情况下，笛卡尔积也可能比我们预期的要小。当来自不同分区的子域被证明是互斥的时，笛卡尔积将不包括该特定子域组合的子域。我们将在下面的一个练习中看到一个例子。

然而，作为测试优先编程的起点，一个涵盖多个精心选择的分区的每个子域的小型测试套件在大小和彻底性之间取得了良好的平衡。然后，测试套件可能会通过玻璃盒测试、代码覆盖率测量和回归测试进一步增长，我们将在本阅读后面部分看到。



## 使用 JUnit 进行自动化单元测试

一个经过良好测试的程序将对其包含的每个单独模块进行测试。如果可能的话，单独测试单个模块的测试称为**单元测试**。

[JUnit](http://junit.org/junit5/)是一个被广泛采用的 Java 单元测试库，我们将在 6.031 中大量使用它。JUnit 单元测试被编写为一个方法，前面有注解`@Test`。单元测试方法通常包含对被测试模块的一个或多个调用，然后使用断言方法（如`assertEquals`、`assertTrue`和）检查结果`assertFalse`。

例如，我们为`max`上面选择的测试在为 JUnit 实现时可能如下所示：

```java
public class MaxTest {
  ...

  @Test
  public void testALessThanB() {
      assertEquals(2, Math.max(1, 2));
  }

  @Test
  public void testBothEqual() {
      assertEquals(9, Math.max(9, 9));
  }

  @Test
  public void testAGreaterThanB() {
      assertEquals(10, Math.max(10, -9));
  }
}
```

请注意，参数的顺序`assertEquals`很重要。第一个参数应该是测试想要看到的*预期结果，通常是常数。*第二个参数是*实际*结果，代码实际做了什么。如果您切换它们，那么 JUnit 将在测试失败时产生令人困惑的错误消息。 [所有比较值的 JUnit 断言都](https://junit.org/junit5/docs/current/api/org.junit.jupiter.api/org/junit/jupiter/api/Assertions.html#method.summary)遵循这个顺序：期望的第一，实际的第二。断言还可以将可选的消息字符串作为最后一个参数，您可以使用它来使测试失败更加清晰。

如果测试方法中的断言失败，则该测试方法立即返回，并且 JUnit 记录该测试的失败。一个测试类可以包含任意数量的`@Test`方法，这些方法在您使用 JUnit 运行测试类时独立运行。即使一种测试方法失败，其他测试方法仍将运行。



## 记录您的测试策略

写下用于创建测试套件的测试策略是个好主意：分区、它们的子域以及每个测试用例选择覆盖的子域。写下策略可以让读者更清楚地看到测试套件的彻底性。

在 JUnit 测试类顶部的注释中记录分区和子域。例如，为了记录我们的测试策略`max`，我们可以这样写`MaxTest.java`：

```java
public class MaxTest {
  /*
   * Testing strategy
   *
   * partition:
   *    a < b
   *    a > b
   *    a = b
   */
```

每个测试用例上面都应该有一个注释，说明它涵盖了哪些子域，例如：

```java
  // covers a < b
  @Test
  public void testALessThanB() {
      assertEquals(2, Math.max(1, 2));
  }
```

大多数测试套件将有多个分区，并且大多数测试用例将覆盖多个子域。例如，这是一个`multiply`使用七个分区的策略：

```java
public class Multiply {
  /*
   * Testing strategy
   *
   * cover the cartesian product of these partitions:
   *   partition on a: positive, negative, 0
   *   partition on b: positive, negative, 0
   *   partition on a: 1, !=1
   *   partition on b: 1, !=1
   *   partition on a: small (fits in a long value), or large (doesn't fit)
   *   partition on b: small, large
   * 
   * cover the subdomains of these partitions:
   *   partition on signs of a and b:
   *      both positive
   *      both negative
   *      different signs
   *      one or both are 0
   */
```

然后每个测试用例都有一个注释来标识它被选择覆盖的子域，例如：

```java
  // covers a is positive, b is negative, 
  //        a fits in long value, b fits in long value,
  //        a and b have different signs
  @Test
  public void testDifferentSigns() {
      assertEquals(BigInteger.valueOf(-146), BigInteger.valueOf(73).multiply(BigInteger.valueOf(-2)));
  }

  // covers a = 1, b != 1, a and b have same sign
  @Test
  public void testIdentity() {
      assertEquals(BigInteger.valueOf(33), BigInteger.valueOf(1).multiply(BigInteger.valueOf(33)));
  }
```



## 黑盒和玻璃盒测试

回想一下，*规范*是对函数行为的描述——参数的类型、返回值的类型以及它们之间的约束和关系。

**黑盒测试**意味着仅从规范中选择测试用例，而不是功能的实现。到目前为止，这就是我们在示例中所做的。我们在 、 和 中划分并寻找边界`abs`，`max`而`multiply`没有查看这些函数的实际代码。事实上，按照测试优先的编程方法，我们甚至还没有为这些函数*编写代码。*

**玻璃盒测试**意味着选择测试用例并了解功能的实际实现方式。例如，如果实现根据输入选择不同的算法，那么您应该围绕选择不同算法的点进行分区。如果实现保留了一个内部缓存来记住先前输入的答案，那么您应该测试重复的输入。

对于 的情况`BigInteger.multiply`，当我们最终实现它时，我们可能已经决定用`int`值表示小整数，用十进制数字列表表示大整数。这个决定引入了新的边界值，大概在`Integer.MAX_VALUE`和`Integer.MIN_VALUE`，以及围绕它们的新分区。

在进行玻璃盒测试时，您必须注意您的测试用例不需要规范未明确*要求的特定实现行为。*例如，如果规范说“如果输入格式错误，则抛出异常”，那么您的测试不应该*专门*检查a `NullPointerException`，因为这是当前实现所做的。在这种情况下，规范允许抛出*任何*异常，因此您的测试用例同样应该是通用的，以便正确，并保持实现者的自由。我们将在规格课程中对此进行更多说明。



## 覆盖范围

判断测试套件的一种方法是询问它对程序的执行程度。这个概念被称为*覆盖范围*. 以下是三种常见的覆盖范围：

- **语句覆盖率**：是否每个语句都由某个测试用例运行？
- **分支覆盖**：对于程序中的每一个`if`或`while`语句，某些测试用例是否同时采用了正确和错误的方向？
- **路径覆盖**：是否每个可能的分支组合——通过程序的每条路径——都被某个测试用例采用？

[![Eclipse 的 EclEmma 代码覆盖工具](https://sm.nsddd.top//typora/eclemma.png?mail:3293172751@qq.com)](http://web.mit.edu/6.031/www/sp21/classes/03-testing/figures/eclemma.png)

分支覆盖比语句覆盖更强（需要更多测试才能实现），路径覆盖比分支覆盖更强。在行业中，100% 的语句覆盖率是一个共同目标，但由于无法访问的防御代码（例如“不应该到达这里”断言），即使这样也很少实现。100% 的分支覆盖率是非常理想的，并且安全关键行业代码具有更严格的标准（例如，[MC/DC](https://en.wikipedia.org/wiki/Modified_condition/decision_coverage)、修改的条件/决策覆盖率）。不幸的是，100% 的路径覆盖是不可行的，需要指数级的测试套件才能实现。

测试的标准方法是添加测试，直到测试套件达到足够的语句覆盖率：即，程序中的每个可达语句至少由一个测试用例执行。在实践中，语句覆盖率通常由代码覆盖率工具测量，该工具计算每个语句由测试套件运行的次数。有了这样的工具，玻璃盒测试很容易；您只需测量黑盒测试的覆盖率，然后添加更多测试用例，直到所有重要语句都记录为已执行。

Eclipse 的一个很好的代码覆盖工具是[EclEmma](http://www.eclemma.org/)，如右图所示。在 EclEmma 中，已被测试套件执行的行显示为绿色，尚未覆盖的行显示为红色。包含仅在一个方向上执行的分支的行 - 始终为真但从不为假，反之亦然 - 是黄色的。如果您从覆盖工具中看到右侧的结果，下一步将是提出一个测试用例，使`if`测试至少为真一次，并将其添加到您的测试套件中，以便黄线和红线变成绿色。

安装 EclEmma 后（就像在 6.031 Eclipse 安装中一样），您可以使用 Run → Coverage As 来突出显示代码覆盖率。



## 单元和集成测试

到目前为止，我们一直在谈论**单元测试**单独测试单个模块。单独测试模块可以更容易地进行调试。当一个模块的单元测试失败时，你可以更加确信错误是在该模块中找到的，而不是在程序中的任何地方。

与单元测试相比，**集成测试**测试模块的组合，甚至整个程序。如果您只有集成测试，那么当测试失败时，您必须寻找错误。它可能在程序中的任何位置。集成测试仍然很重要，因为程序可能会在模块之间的连接处失败。例如，一个模块可能期望不同于它实际从另一个模块获得的输入。但是，如果您有一套完整的单元测试，可以让您对各个模块的正确性充满信心，那么您在寻找错误方面的工作就会少得多。

假设您正在构建一个文档搜索引擎。您的两个模块可能是`load()`加载文件的模块和`extract()`将文档拆分为其组成词的模块：

```java
/** 
 * @return the contents of the file
 */
public static String load(File file) { ... }

/** 
 * @return the words in string s, in the order they appear, 
 *         where a word is a contiguous sequence of 
 *         non-whitespace and non-punctuation characters 
 */
public static List<String> extract(String s) { ... }
```

这些方法可能被另一个模块`index()`用来创建搜索引擎的索引：

```java
/**
 * @return an index mapping a word to the set of files
 *         containing that word, for all files in the input set 
 */
public static Map<String, Set<File>> index(Set<File> files) { 
    ...
    for (File file : files) {
        String doc = load(file);
        List<String> words = extract(doc);
        ...
    }
    ...
} 
```

在我们的测试套件中，我们希望：

- 单元测试只是为了`load`在各种文件上测试它
- 单元测试只是为了`extract`在各种字符串上测试它
- `index`对各种文件集进行测试的单元测试

`extract`程序员有时会犯的一个错误是以测试用例依赖于`load`正确的方式编写测试用例。例如，一个测试用例可能用于`load`加载一个文件，然后将其结果作为输入传递给`extract`. 但这*不是*`extract`. _ 如果测试用例失败，那么我们不知道失败是否是由于`load`或`extract`.

最好单独考虑和测试`extract`。使用包含真实文件内容的测试分区可能是合理的，因为这`extract`就是程序中实际使用的方式。但实际上不要`load`从测试用例中调用，因为`load`可能是错误的！相反，将文件内容存储为文字字符串，并将其直接传递给`extract`. 这样你就可以编写一个独立的单元测试，如果它失败了，你可以更加确信这个错误是在它实际测试的模块中。

请注意，`index`无法以这种方式轻松隔离单元测试。一个测试用例调用`index`的时候，不仅是测试里面的代码的正确性`index`，还要测试所有被调用的方法的正确性`index`。如果测试失败，则错误可能在这些方法中的任何一个中。`load`这就是为什么我们需要对和进行单独测试`extract`，以增加我们对这些模块的信心，并将问题定位到`index`将它们连接在一起的代码。

`index`如果我们写的话，隔离一个更高级别的模块是可能的**存根**它调用的模块的版本。例如，存根 for`load`根本不会访问文件系统，而是会返回模拟文件内容，无论`File`传递给它的是什么。类的存根通常称为[**模拟对象**](http://en.wikipedia.org/wiki/Mock_object)。存根是构建大型系统时的一项重要技术，但我们一般不会在 6.031 中使用它们。



## 自动化回归测试

没有什么比完全自动化更容易运行、更有可能运行测试的了。 **自动化测试**意味着运行测试并自动检查其结果。

在模块上运行测试的代码是*测试驱动程序*（也称为测试工具或测试运行程序）。测试驱动程序不应该是一个交互式程序，它会提示您输入并打印出结果供您手动检查。相反，测试驱动程序应该在固定的测试用例上调用模块本身并自动检查结果是否正确。测试驱动程序的结果应该是“所有测试正常”或“这些测试失败：……”一个好的测试框架，如 JUnit，允许您构建和运行这种测试驱动程序，并带有一套自动化测试。

请注意，像 JUnit 这样的自动化测试框架可以很容易地运行测试，但您仍然必须自己提出好的测试用例。 *自动测试生成*是一个难题，仍然是活跃的计算机科学研究的主题。

一旦你有了测试自动化，当你修改你的代码时重新运行你的测试是非常重要的。软件工程师从痛苦的经验中知道，对大型或复杂程序的*任何*更改都是危险的。无论您是要修复另一个错误、添加新功能，还是优化代码以使其更快，保留正确行为基线的自动化测试套件（即使只是几个测试）都将节省您的精力。在更改代码时频繁运行测试可以防止程序*倒退*——在修复新错误或添加新功能时引入其他错误。在每次更改后运行所有测试**回归测试**.

每当您发现并修复错误时，请获取引发错误的输入并将其作为测试用例添加到您的自动化测试套件中。这种测试用例称为*回归测试*。这有助于用良好的测试用例填充您的测试套件。请记住，如果测试会引发错误，那么它就是好的测试——并且每个回归测试都在您的代码的一个版本中进行！保存回归测试还可以防止重新引入错误的回归。该错误可能是一个容易犯的错误，因为它已经发生过一次。

这个想法也导致了*测试优先调试*。当出现错误时，立即为它编写一个测试用例来引发它，并立即将其添加到您的测试套件中。一旦你找到并修复了这个 bug，你的所有测试用例都将通过，你将完成调试并对该 bug 进行回归测试。

在实践中，自动化测试和回归测试这两个想法几乎总是结合使用。只有当测试可以经常自动运行时，回归测试才是实用的。相反，如果您已经为您的项目进行了自动化测试，那么您不妨使用它来防止回归。因此，**自动化回归测试**是现代软件工程的最佳实践。



## 迭代测试优先编程

让我们重温一下我们在本文开头介绍的测试优先编程思想，并对其进行改进。有效的软件工程不遵循线性过程。实践**迭代的**测试优先编程，您准备返回并修改之前步骤中的工作：

1. 为函数编写规范。
2. 编写执行规范的测试。当你发现问题时，**迭代**规范和测试。
3. 写一个实现。当你发现问题时，**迭代**规范、测试和实现。

每个步骤都有助于验证前面的步骤。编写测试是理解规范的好方法。规范可能不正确、不完整、模棱两可或缺少极端情况。尝试编写测试可以及早发现这些问题，在您浪费时间处理错误规范的实现之前。同样，编写实现可能会帮助您发现缺失或不正确的测试，或者提示您重新访问和修改规范。

由于可能需要对前面的步骤进行迭代，因此在继续下一步之前花费大量时间使一个步骤完美是没有意义的。 **迭代计划：**

- 对于大型规范，首先只编写规范的一部分，然后继续测试和实现该部分，然后迭代更完整的规范。
- 对于复杂的测试套件，首先选择几个重要的分区，然后为它们创建一个小的测试套件。继续执行通过这些测试的简单实现，然后在具有更多分区的测试套件上进行迭代。
- 对于一个棘手的实现，首先编写一个简单的蛮力实现来测试你的规范并验证你的测试套件。然后确信您的规范是好的并且您的测试是正确的，然后继续进行更难的实施。

迭代是每个现代软件工程过程（例如[敏捷](https://en.wikipedia.org/wiki/Agile_software_development)和[Scrum](https://en.wikipedia.org/wiki/Scrum_(software_development))）的一个特征，它的有效性得到了很好的经验支持。迭代需要不同于学生解决家庭作业和考试问题时所习惯的思维方式。迭代不是试图从头到尾完美地解决一个问题，迭代意味着尽快达到一个粗略的解决方案，然后不断地完善和改进它，这样你就有时间在必要时丢弃和返工。当问题很困难且解决方案空间未知时，迭代会充分利用您的时间。

<iframe class="exercises-status" src="https://6031.mit.edu/handx/sp21-java/status.php" style="box-sizing: border-box; width: 232.164px; height: 260px; border: none; position: absolute; right: -232.164px;"></iframe>



## 概括

在本次阅读中，我们看到了这些想法：

- 测试优先编程。在编写代码之前编写测试。
- 使用分区和边界值进行系统测试，以设计正确、彻底和小型的测试套件。
- 用于填写测试套件的玻璃盒测试和语句覆盖率。
- 尽可能独立地对每个模块进行单元测试。
- 自动回归测试以防止错误再次出现。
- 迭代开发。计划重做一些工作。

今天阅读的主题与我们优秀软件的三个关键属性有关，如下所示：

- **远离错误。** 测试是在你的代码中发现错误，而测试优先编程是在你引入它们之后尽早发现它们。
- **容易理解。** 使用记录在案的测试策略进行系统测试可以更容易地理解测试用例的选择方式以及测试套件的彻底性。
- **准备好改变。** 正确的测试套件仅取决于规范中的行为，这允许实现在规范的范围内进行更改。我们还谈到了自动化回归测试，它有助于防止在对代码进行更改时出现错误。



## END 链接
+ [回到目录](../README.md)
+ [上一节](7.md)
+ [下一节](9.md)
---
+ [**参与贡献❤️💕💕**](https://nsddd.top/archives/contributors))