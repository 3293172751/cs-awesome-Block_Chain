+ [author](http://nsddd.top)

# 第5节 sealer runtime 

<br>

<div><a href = '4.md' style='float:left'>⬆️上一节🔗  </a><a href = '6.md' style='float: right'>  ⬇️下一节🔗</a></div>
<br>

> ❤️💕💕记录[sealos](https://github.com/3293172751/sealos)开源项目的学习过程。[k8s,docker和云原生的学习](https://github.com/3293172751/sealos)。Myblog:[http://nsddd.top](http://nsddd.top/)

[TOC]

## 项目规范



## 注意

::: tip 
k8s 从 v1.24 开始，kubernetes 默认容器运行时使用 `containerd` ，不再使用 `docker`。

k3s 将所有 kubernetes 控制层面组件都封装到 单个二进制中 ，占用资源小，且包含了 kubernetes 运行时所需要的外部依赖和本地存储提供程序。

k3s 提供离线安装包，可以避免网络资源访问问题。

:::



## 运行时

::: warning 什么是 运行时
我们分为广义和侠义

+ 广义：程序跑起来的时候
+ 侠义：辅助程序跑起来的代码和环境

我们或许可以把 runtime 和 compile-time 对比：

我们都希望编译器发现错误，而不是测试跑的时候发现错误，而且排查很难。

+ runtime：内存错误、数字错误
+ compile-time：语法错误，语义错误



**侠义上的运行时：**

+ 运行时库（runtime library）`stdio.h`
+ 运行时环境（runtime environment）



**运行时环境：**

+ "无" 运行时 – 依赖 os
  + c/c++
  + rust
+ 轻运行时
  + Golang
+ 重运行时
  + java（JVM）
  + python（CPython）
  + C#（.NET runtime）

:::



## 目录结构

::: details 目录结构

+ **/bin**：

  + `bin` 是 `Binaries` (二进制文件) 的缩写, 这个目录存放着最经常使用的命令。

+ **/boot**：

  + 这里存放的是启动 Linux 时使用的一些核心文件，包括一些连接文件以及镜像文件。

+ **/dev** ：

  + `dev` 是 `Device`(设备) 的缩写, 该目录下存放的是 Linux 的外部设备，在 Linux 中访问设备的方式和访问文件的方式是相同的。

+ **/etc**：

  + `etc` **是** `Etcetera`(等等**) **的缩写，这个目录用来存放所有的系统管理所需要的配置文件和子目录。

+ **/home**：

  + 用户的主目录，在 Linux 中，每个用户都有一个自己的目录，一般该目录名是以用户的账号命名的，如上图中的 alice、bob 和 eve。

+ **/lib**：

  + `lib` 是Library(库) 的缩写这个目录里存放着系统最基本的动态连接共享库，其作用类似于 Windows 里的 DLL 文件。几乎所有的应用程序都需要用到这些共享库。

+ **/lost+found**：

  + 这个目录一般情况下是空的，当系统非法关机后，这里就存放了一些文件。

+ **/media**： 

  + linux 系统会自动识别一些设备，例如U盘、光驱等等，当识别后，Linux 会把识别的设备挂载到这个目录下。

+ **/mnt** 

  + 系统提供该目录是为了让用户临时挂载别的文件系统的，我们可以将光驱挂载在 /mnt/ 上，然后进入该目录就可以查看光驱里的内容了。

+ **/opt**： 

  + opt 是optional(可选) 的缩写，这是给主机额外安装软件所摆放的目录。比如你安装一个ORACLE数据库则就可以放到这个目录下。默认是空的。

+ **/proc**： 

  + proc 是Processes(进程) 的缩写，/proc是一种伪文件系统（也即虚拟文件系统），存储的是当前内核运行状态的一系列特殊文件，这个目录是一个虚拟的目录，它是系统内存的映射，我们可以通过直接访问这个目录来获取系统信息。

   这个目录的内容不在硬盘上而是在内存里，我们也可以直接修改里面的某些文件，比如可以通过下面的命令来屏蔽主机的 `ping` 命令，使别人无法 `ping` 你的机器：

  ```bash
  echo 1 > /proc/sys/net/ipv4/icmp_echo_ignore_all
  ```

+ **/root**： 

  + 该目录为系统管理员，也称作超级权限者的用户主目录。

+ **/sbin**： 

  + `s` 就是 `Super User` 的意思，是 Superuser Binaries (超级用户的二进制文件) 的缩写，这里存放的是系统管理员使用的系统管理程序。

+ **/selinux**： 

  + 这个目录是 `Redhat/CentOS` 所特有的目录，`Selinux`是一个安全机制，类似于 windows 的防火墙，但是这套机制比较复杂，这个目录就是存放`selinux`相关的文件的。

+ **/srv**： 

  + 该目录存放一些服务启动之后需要提取的数据。

+ **/sys**： 

  + 这是 Linux2.6 内核的一个很大的变化。该目录下安装了 2.6 内核中新出现的一个文件系统 sysfs sysfs 文件系统集成了下面3种文件系统的信息：针对进程信息的 proc 文件系统、针对设备的 devfs 文件系统以及针对伪终端的 devpts 文件系统。 该文件系统是内核设备树的一个直观反映。 当一个内核对象被创建的时候，对应的文件和目录也在内核对象子系统中被创建。

+ **/tmp**： 

  + `tmp` 是`temporary`(临时) 的缩写这个目录是用来存放一些临时文件的。

+ **/usr**： 

  + usr 是 unix shared resources(共享资源) 的缩写，这是一个非常重要的目录，用户的很多应用程序和文件都放在这个目录下，类似于 windows 下的 program files 目录。

+ **/usr/bin**：

  + 系统用户使用的应用程序。

+ **/usr/sbin**：

  + ****超级用户使用的比较高级的管理程序和系统守护程序**。**

+ **/usr/src**：

  + 内核源代码默认的放置目录。

+ **/var**：

  +  var 是 variable(变量) 的缩写，这个目录中存放着在不断扩充着的东西，我们习惯将那些经常被修改的目录放在这个目录下。包括各种日志文件。

+ **/run**： 

  + 是一个临时文件系统，存储系统启动以来的信息。当系统重启时，这个目录下的文件应该被删掉或清除。如果你的系统上有 `/var/run` 目录，应该让它指向 `run`。



**💡 重要的目录结构：**

**在 Linux 系统中，有几个目录是比较重要的，平时需要注意不要误删除或者随意更改内部文件。**

`-/etc`： 上边也提到了，这个是系统中的配置文件，如果你更改了该目录下的某个文件可能会导致系统不能启动。

`-/bin, /sbin, /usr/bin, /usr/sbin:` 这是系统预设的执行文件的放置目录，比如 ls 就是在 `/bin/ls` 目录下的。

**值得提出的是，/bin, /usr/bin 是给系统用户使用的指令（除root外的通用户），而/sbin, /usr/sbin 则是给 root 使用的指令。**

-**/var**： 这是一个非常重要的目录，系统上跑了很多程序，那么每个程序都会有相应的日志产生，而这些日志就被记录到这个目录下，具体在 `/var/log` 目录下，另外 `mail` 的预设放置也是在这里。

:::



## 前言

**议题：**

+ [https://github.com/sealerio/sealer/issues/1839](https://github.com/sealerio/sealer/issues/1839)
+ [https://github.com/sealerio/sealer/issues/1770](https://github.com/sealerio/sealer/issues/1770)



### What is the problem this feature will solve?

+ Brings all the benefits of k3s. @https://www.rancher.cn/k3s/
+ No k3s no sealos.

> Sealos wants to hit the mass market, which is consistent with the direction of k3s. The lightweight k3s is more popular with mass developers.

我们在路线图中对 k8s、k0s、k3s 运行时支持的工作应该有一个进度记录，应该是让工作进度更加清晰，并吸引更多的参与者加入这个核心工作。这里简单介绍一下部分工作：

阅读 Sealer 主分支代码，理解 runtime 模块中的代码，掌握从 cmd 模块到 runtime 模块的代码调用逻辑。

通过k8s、k0s、k3s官网阅读并设计运行时接口实现方法。

为指定的运行时读取和设计 clusterImage。主要参考： [ClusterImage](http://sealer.cool/docs/advanced/define-cloudimage.html#customize-the-cloudrootfs)、[basefs](https://github.com/sealerio/basefs)。

类型：功能请求

+ 单结点成为高可用~

```bash
docker~ run cmd 
```



## Clusterlmage

::: tip location
https://github.com/sealerio/basefs
:::



###  cluster

+ `Bin file`，如 docker、containerd、crictl、kubeadm、kubectl...
+ `config file` ，如 kubelet systemd config、docker systemd config、docker daemon.json...
+ `registry` images。
+ `Some metadata`，例如 Kubernetes 版本信息。
+ `registry file`，包含所有的docker镜像，比如kubernetes核心组件docker镜像...
+ `Script`，一些用于安装 docker 和 kubelet 的 shell 脚本... sealer 将调用 init.sh 和 clean.sh`。`
+ `Other static files` ：其他静态文件



使用 Kubernetes 仪表板构建 ClusterImage：

FileName：`Kubefile`

```dockerfile
# base ClusterImage contains all the files that run a kubernetes cluster needed.
#    1. kubernetes components like kubectl kubeadm kubelet and apiserver images ...
#    2. docker engine, and a private registry
#    3. config files, yaml, static files, scripts ...
FROM registry.cn-qingdao.aliyuncs.com/sealer-io/kubernetes:v1.19.8
# download kubernetes dashboard yaml file
RUN wget https://raw.githubusercontent.com/kubernetes/dashboard/v2.2.0/aio/deploy/recommended.yaml
# when run this ClusterImage, will apply a dashboard manifests
CMD kubectl apply -f recommended.yaml
```



**Build it：**

```bash
sealer build -t registry.cn-qingdao.aliyuncs.com/sealer-io/dashboard:latest .
```



**Make it run：**

```bash
# sealer will install a kubernetes on host 192.168.0.2 then apply the dashboard manifests
sealer run registry.cn-qingdao.aliyuncs.com/sealer-io/dashboard:latest --masters 192.168.0.2 --passwd xxx
# check the pod

kubectl get pod -A|grep dashboard

```



## 调研

首先需要调研，然后出一个设计稿，比如 `install` 模块怎么和 k3s 结合

`apply` 会对比一下新旧集群的差别，然后再确定是否调用  `runtime`  来扩缩容集群

> 目前k3s还没有实现，`k0s` 在最新代码中还没有适配起来，上面这个文档是在0.8.6版本，也就是9月下旬发布的那个版本代码前设计的，现在的话大体思路一致，如果需要实现k3s的话，首先需要熟读k3s的官方安装文档，其次阅读`sealer runtime`的接口逻辑，`install/scaleup`等接口干些什么事儿。最后还需要看一下如何与`rootfs`进行交互，也就是集群镜像那个部分。
>
> 切换到9月30号的那次`starcomingup`的提交，基于那次`commit`进行编译，k0s镜像的话可以体验一下
>
> +  scaledown 作用于master节点，删除master节点前需要先删除master节点上的pod

**install 模块和 k3s 的结合：**

```
/*
Install a new cluster.

:param infra: 基础结构对象。
:param kubeadmConfig: The kubeadm configuration.
:param masters: The list of master IPs.
:param workers: The list of worker IPs.
:returns: None
:raises: None
*/
```



***infradriver*:**

```go
// infracontrol将整个集群视为一个操作系统内核，
// 这里的interface函数是目标系统调用。
type InfraDriver interface {
	GetHostIPList() []net.IP

	GetHostIPListByRole(role string) []net.IP
	//获取指定角色的ip列表，比如master，node，
    
	GetHostsPlatform(hosts []net.IP) (map[v1.Platform][]net.IP, error)

	//GetHostEnv return merged env with host env and cluster env.
	GetHostEnv(host net.IP) map[string]interface{}

	//GetClusterEnv return cluster.spec.env as map[string]interface{}
	GetClusterEnv() map[string]interface{}

	//GetClusterName ${clusterName}
	GetClusterName() string

	//GetClusterImageName ${cluster image Name}
	GetClusterImageName() string

	//GetClusterLaunchCmds ${user-defined launch command}
	GetClusterLaunchCmds() []string

	//GetClusterRootfsPath /var/lib/sealer/data/${clusterName}/rootfs
	GetClusterRootfsPath() string

	// GetClusterBasePath /var/lib/sealer/data/${clusterName}
	GetClusterBasePath() string

	// Execute use eg.Go to execute shell cmd concurrently
	Execute(hosts []net.IP, f func(host net.IP) error) error

	// Copy local files to remote host
	// scp -r /tmp root@192.168.0.2:/root/tmp => Copy("192.168.0.2","tmp","/root/tmp")
	// need check md5sum
	Copy(host net.IP, localFilePath, remoteFilePath string) error
	// CopyR copy remote host files to localhost
	CopyR(host net.IP, remoteFilePath, localFilePath string) error
	// CmdAsync exec command on remote host, and asynchronous return logs
	CmdAsync(host net.IP, cmd ...string) error
	// Cmd exec command on remote host, and return combined standard output and standard error
	Cmd(host net.IP, cmd string) ([]byte, error)
	// CmdToString exec command on remote host, and return spilt standard output and standard error
	CmdToString(host net.IP, cmd, spilt string) (string, error)

	// IsFileExist check remote file exist or not
	IsFileExist(host net.IP, remoteFilePath string) (bool, error)
	// IsDirExist Remote file existence returns true, nil
	IsDirExist(host net.IP, remoteDirPath string) (bool, error)

	// GetPlatform Get remote platform
	GetPlatform(host net.IP) (v1.Platform, error)

	GetHostName(host net.IP) (string, error)
	// Ping Ping remote host
	Ping(host net.IP) error
	// SetHostName add or update host name on host
	SetHostName(host net.IP, hostName string) error

	//SetClusterHostAliases set additional HostAliases
	SetClusterHostAliases(hosts []net.IP) error

	//DeleteClusterHostAliases delete additional HostAliases
	DeleteClusterHostAliases(hosts []net.IP) error

	// SetLvsRule add or update host name on host
	//SetLvsRule(host net.IP, hostName string) error
}

```





##  runtime/types

```bash
// Metadata use file Metadata in rootfs to help cluster install.
type Metadata struct {
	Version string `json:"version"`
	Arch    string `json:"arch"`
	Variant string `json:"variant"`
	// KubeVersion is a SemVer constraint specifying the version of Kubernetes required.
	KubeVersion string `json:"kubeVersion"`
	NydusFlag   bool   `json:"NydusFlag"`
	// ClusterRuntime is a flag to distinguish the runtime for k0s、k8s、k3s
	ClusterRuntime ClusterRuntime `json:"ClusterRuntime"`
}

type ClusterRuntime string

const (
	K0s ClusterRuntime = "k0s"
	K3s ClusterRuntime = "k3s"
	K8s ClusterRuntime = "k8s"
)
```

metadata:

```bash
[root@iZbp1evo5cnwagauz3w188Z rootfs]# pwd;cat Metadata 
/var/lib/sealer/data/my-cluster/rootfs
{
  "version": "v1.19.8",
  "arch": "amd64"
}

```



## rootfs module

**interface：**

```go
type Manager interface {
	App() App   // App returns the application manager.
}

type App interface {
	Root() string  // Root returns the root path of the application.
}
```



## data

![在这里插入图片描述](http://sm.nsddd.top/smetcd&sqlite)



::: tip 
我需要注意的模块：

+ apply/driver/
+ apply/processor/
+ [cmd/sealer/cmd/cluster](https://github.com/sealerio/sealer/pull/1686/files#diff-ad043994ee0ef6e350ef3520fbab469423b41d1abb8cdb3527b230eb3416d4de)
+ runtime

:::



## 安装/放大/缩小/重置/升级

+ 删除注册表交互逻辑
+ 更改为 `infra-driver` 命令



## 更改 basefs 脚本

+ 容器 `d.sh`
+ 有些东西需要遵循 `k8s` 领先的逻辑



## 入口函数

+ `ChooseClusterRuntime()`：使用 `Metadata` 来区分集群 `Runtime`，需要添加一个字段来区分k0s、k3s、k8s

 

### 附加上下文

在此处添加有关功能请求的任何其他上下文或屏幕截图。



### sealos 主议题

+ [k3s 所有议题](https://github.com/sealerio/sealer/issues?q=is%3Aissue+is%3Aopen+k3s)

+ [https://github.com/labring/sealos/issues/1943](https://github.com/labring/sealos/issues/1943)
+ https://github.com/sealerio/sealer/issues/1399



### 策划文档

+ https://www.yuque.com/zhouxinyuan-6woia/nodno9/iswdqd



## 计划

+ [x] 熟读k3s官方文档
+ [x] 熟悉 k3s 的安装脚本
+ [x] 阅读 sealer runtime 的接口逻辑   install / scaleup 接口
+ [x] 如何和 rootfs 交互



## issues

我们在路线图中对 k8s、k0s、k3s 运行时支持的工作应该有一个进度记录，应该是让工作进度更加清晰，并吸引更多的参与者加入这个核心工作。这里简单介绍一下部分工作：
阅读Sealer主分支代码，理解 `runtime` 模块中的代码，掌握从 cmd 模块到 runtime 模块的代码调用逻辑。
通过k8s、k0s、k3s官网阅读并设计运行时接口实现方法。
为指定的运行时读取和设计 clusterImage。主要参考： [ClusterImage](http://sealer.cool/docs/advanced/define-cloudimage.html#customize-the-cloudrootfs)、[basefs](https://github.com/sealerio/basefs)。
类型：*功能请求*

+ [k0s 跟进文档](https://github.com/sealerio/sealer/pull/1686)
+ [1686议题跟进代码](https://github.com/sealerio/sealer/pull/1686/files)



### cluster

`cluster.go`描述整个集群期望状态 -- 几个`master`，几个`node`，`ssh`密码、端口号、集群镜像、贯穿始终，特别特别重要  -- `sealos run` 也是渲染成结构体传递给其他模块~**

```bash
----
apply.go
cert.go
cluster.go
delete.go
join.go
run-app.go
run.go
scale-up.go
```



## k0s runtime design readme

::: details install.sh

```bash
$ curl https://get.k0s.sh/
#!/bin/sh

set -e

if [ -n "${DEBUG}" ]; then
  set -x
fi

_k0s_latest() {
  curl -sSLf "https://docs.k0sproject.io/stable.txt"
}

_detect_binary() {
  os="$(uname)"
  case "$os" in
    Linux) echo "k0s" ;;
    *) echo "Unsupported operating system: $os" 1>&2; return 1 ;;
  esac
  unset os
}

_detect_arch() {
  arch="$(uname -m)"
  case "$arch" in
    amd64|x86_64) echo "amd64" ;;
    arm64|aarch64) echo "arm64" ;;
    armv7l|armv8l|arm) echo "arm" ;;
    *) echo "Unsupported processor architecture: $arch" 1>&2; return 1 ;;
  esac
  unset arch
}

_download_url() {
  echo "https://ghproxy.com/https://github.com/k0sproject/k0s/releases/download/$K0S_VERSION/$k0sBinary-$K0S_VERSION-$k0sArch"
}

main() {
  if [ -z "${K0S_VERSION}" ]; then
    K0S_VERSION=$(_k0s_latest)
  fi

  k0sInstallPath=/usr/local/bin
  k0sBinary="$(_detect_binary)"
  k0sArch="$(_detect_arch)"
  k0sDownloadUrl="$(_download_url)"

  mkdir -p -- "$k0sInstallPath"

  echo "Downloading k0s from URL: $k0sDownloadUrl"

  curl -sSLf "$k0sDownloadUrl" >"$k0sInstallPath/$k0sBinary"
  chmod 755 -- "$k0sInstallPath/$k0sBinary"

  echo "k0s is now executable in $k0sInstallPath"
}

main

```

:::

+ https://github.com/sealerio/sealer/blob/main/pkg/runtime/k0s/README.md

### basics directory structure

```bash
├── amd64
│   ├── bin
│   │   ├── k0s
│   │   ├── kubectl
│   │   ├── nerdctl
│   │   └── seautil
│   ├── images
│   │   └── registry.tar.gz
│   └── Metadata
├── imageList
├── Kubefile
└── rootfs
    ├── etc
    │   ├── dump-config.toml
    │   └── registry.yml
    └── scripts
        ├── containerd.sh
        ├── init-registry.sh
        └── init.sh
```



### 重构相对运行时的列表

```bash
runtime
├── interface.go # runtime interface
└── kubernets
    ├── join_masters.go     # add master nodes/controlplanes
    ├── join_worker.go      # add worker nodes
    ├── common.go           # Enum relative Kubeadm
    ├── init.go             # create cluster
    ├── delete_masters.go   # delete master nodes/controlplanes
    ├── delete_nodes.go     # delete worker nodes
    ├── kubeadm_runtime.go  # runtime implement
    ├── kubeadm_type        # kubeadm version type
    │   └── v1beta1
    │       └── type.go
    ├── registry_service.go  # get and set some registry info
    ├── reset.go             # reset a kubernetes cluster
    ├── static_file.go       # AuditPolicyYml type
    ├── update_cert.go       # update certs about kubernetes
    └── util.go              # util of kubernetes runtime

```



### cloud镜像

```bash
COPY rootfs/* .
COPY ${ARCH} .
COPY ImageList manifests
BASE rootfs cache
```



### 目录设计

```bash
├── bin
│   ├── conntrack
│   ├── containerd-rootless-setuptool.sh
│   ├── containerd-rootless.sh
│   ├── crictl
│   ├── k0s
│   ├── kubectl
│   ├── ...
│   └── seautil
├── etc
│   ├── admin.conf
│   ├── Clusterfile  # 镜像默认集群文件
│   ├── daemon.json # docker 守护进程配置文件。
│   ├── docker.service
│   ├── k0s.yaml # k0s config
│   ├── kubelet.service
│   └── registry.yml # 如果用户想自定义用户名和密码，可以覆盖这个文件。
├── images
│   └── registry.tar  # 注册docker镜像，将加载此镜像并在集群中运行本地注册表
├── Metadata
├── registry #是否将此目录挂载到本地注册表
│   └── docker
│       └── registry
├── scripts
│   ├── script-wait-for-develop
└── statics # yaml文件, sealer 将渲染这些文件中的值
    └── audit-policy.yml
```



### Clusterfile 和 KubeadmConfig

KubeadmConfig 根据集群文件生成，如何从集群文件中加载：

```go
// LoadFromClusterfile: Load KubeadmConfig from Clusterfile.
// If it has `KubeadmConfig` in Clusterfile, load every field to each configuration.
// If Kubeadm raw config in Clusterfile, just load it.
func (k *KubeadmConfig) LoadFromClusterfile(kubeadmConfig KubeadmConfig) error {
	k.APIServer.CertSANs = strUtils.RemoveDuplicate(append(k.APIServer.CertSANs, kubeadmConfig.APIServer.CertSANs...))

	return mergo.Merge(k, kubeadmConfig)
}
```



如何生成：





### 介绍

我们定义 k0s 运行时有 5 个阶段来安装/扩展/重置集群。

basefs 包含二进制、shell 脚本、配置文件和镜像。了解有关[sealerio/basefs 的更多信息](https://github.com/sealerio/basefs)

[通过执行k0s](https://github.com/k0sproject/k0s) 命令安装文件系统引导集群之前的运行时。

+ init
  + 当 sealer 导致先安装集群时，`init` 阶段将 `rootfs/bin` 复制到 `init.sh` 脚本中的 `/usr/bin`
  + 创建引导配置 `/etc/k0s/k0s.yaml` 以引导控制器初始化
  + 生成 `k0s` 加入令牌 `/etc/k0s/worker-token` 和 `/etc/k0s/controller-token`，也是私有注册表证书
  + 初始化控制器节点
  + 获取  `~/.kube/config`  的配置以管理集群。
+ join
  + 加入阶段准备注册表证书，并用于 `k0s join` 扩展集群。
+ delete
  + 删除与加入相同，但它回收加入阶段安装的任何内容。
+ reset
  + 通过 `k0s` 重置以移除该集群并移除由 `sealer` 生成的集群的任何相关内容。
+ Upgrade
  + `upgrade` 可以升级 `k0s` 集群。



## 表格（CN）

![image-20221113000126421](http://sm.nsddd.top/smimage-20221113000126421.png)



## code runtime module

**util.go：**

```
/*
Loads the metadata file from the given rootfs.
从给定的rootfs加载元数据文件。

Args:
	rootfs: The rootfs path.

Returns:
	The metadata object.
*/
```

+ metaverse 元宇宙
+ metadata 元数据



::: warning what is metadata?
描述数据的数据，它是数据的描述和上下文。有助于组织、发现和理解数据。

+ 业务 metadata
+ 操作 metadata
  + 数据所有者、使用者
  + 数据的访问方式、访问时间、访问限制
  + 数据的访问权限、组和角色等
  + 数据处理作业的结果、系统执行日志等等
  + 数据备份、归档人、归档时间等

:::



## k3s rootfs

**bin:**

主要的二进制：

```bash
root@ubuntu:/var/lib/rancher/k3s/data/2ef87ff954adbb390309ce4dc07500f29c319f84feec1719bfb5059c8808ec6a/bin# ls -al |grep "^-"
-rwxr-xr-x 1 root root    268480 Dec 18  2021 blkid
-rwxr-xr-x 1 root root    816728 Dec 18  2021 busybox
-rwxr-xr-x 1 root root   2874560 Dec 18  2021 charon
-rwxr-xr-x 1 root root     13476 Oct 25 12:59 check-config
-rwxr-xr-x 1 root root   3158016 Oct 25 12:59 cni
-rwxr-xr-x 1 root root    186672 Dec 18  2021 conntrack
-rwxr-xr-x 1 root root  53494904 Oct 25 12:59 containerd
-rwxr-xr-x 1 root root   9482240 Oct 25 12:59 containerd-shim-runc-v2
-rwxr-xr-x 1 root root   1388752 Dec 18  2021 coreutils
-rwxr-xr-x 1 root root    215000 Dec 18  2021 ethtool
-rwxr-xr-x 1 root root    303088 Dec 18  2021 find
-rwxr-xr-x 1 root root    444520 Dec 18  2021 fuse-overlayfs
-rwxr-xr-x 1 root root    533648 Dec 18  2021 ip
-rwxr-xr-x 1 root root    186432 Dec 18  2021 ipset
-rwxr-xr-x 1 root root 130760056 Oct 25 12:59 k3s
-rw-r--r-- 1 root root      6046 Oct 25 12:59 .links
-rwxr-xr-x 1 root root    193952 Dec 18  2021 losetup
-rwxr-xr-x 1 root root     63040 Dec 18  2021 nsenter
-rwxr-xr-x 1 root root    181944 Dec 18  2021 pigz
-rwxr-xr-x 1 root root   8887624 Oct 25 12:59 runc
-rw-r--r-- 1 root root      2335 Oct 25 12:59 .sha256sums
-rwxr-xr-x 1 root root   1129336 Dec 18  2021 slirp4netns
-rwxr-xr-x 1 root root    934304 Dec 18  2021 swanctl
```



其他的链接文件：

```bash
root@ubuntu:/var/lib/rancher/k3s/data/2ef87ff954adbb390309ce4dc07500f29c319f84feec1719bfb5059c8808ec6a/bin# ls -al  |grep "^l"
lrwxrwxrwx 1 root root         9 Nov  8 05:23 [ -> coreutils
lrwxrwxrwx 1 root root         7 Nov  8 05:23 [[ -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 addgroup -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 adduser -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 ar -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 arch -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 arp -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 arping -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 ash -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 awk -> busybox
lrwxrwxrwx 1 root root         9 Nov  8 05:23 b2sum -> coreutils
lrwxrwxrwx 1 root root         9 Nov  8 05:23 base32 -> coreutils
lrwxrwxrwx 1 root root         9 Nov  8 05:23 base64 -> coreutils
lrwxrwxrwx 1 root root         9 Nov  8 05:23 basename -> coreutils
lrwxrwxrwx 1 root root         9 Nov  8 05:23 basenc -> coreutils
lrwxrwxrwx 1 root root         7 Nov  8 05:23 bc -> busybox
lrwxrwxrwx 1 root root         3 Nov  8 05:23 bridge -> cni
lrwxrwxrwx 1 root root         7 Nov  8 05:23 bunzip2 -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 bzcat -> busybox
lrwxrwxrwx 1 root root         9 Nov  8 05:23 cat -> coreutils
lrwxrwxrwx 1 root root         7 Nov  8 05:23 chattr -> busybox
lrwxrwxrwx 1 root root         9 Nov  8 05:23 chcon -> coreutils
lrwxrwxrwx 1 root root         9 Nov  8 05:23 chgrp -> coreutils
lrwxrwxrwx 1 root root         9 Nov  8 05:23 chmod -> coreutils
lrwxrwxrwx 1 root root         9 Nov  8 05:23 chown -> coreutils
lrwxrwxrwx 1 root root         9 Nov  8 05:23 chroot -> coreutils
lrwxrwxrwx 1 root root         7 Nov  8 05:23 chrt -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 chvt -> busybox
lrwxrwxrwx 1 root root         9 Nov  8 05:23 cksum -> coreutils
lrwxrwxrwx 1 root root         7 Nov  8 05:23 clear -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 cmp -> busybox
lrwxrwxrwx 1 root root         9 Nov  8 05:23 comm -> coreutils
lrwxrwxrwx 1 root root         9 Nov  8 05:23 cp -> coreutils
lrwxrwxrwx 1 root root         7 Nov  8 05:23 cpio -> busybox
lrwxrwxrwx 1 root root         3 Nov  8 05:23 crictl -> k3s
lrwxrwxrwx 1 root root         7 Nov  8 05:23 crond -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 crontab -> busybox
lrwxrwxrwx 1 root root         9 Nov  8 05:23 csplit -> coreutils
lrwxrwxrwx 1 root root         3 Nov  8 05:23 ctr -> k3s
lrwxrwxrwx 1 root root         9 Nov  8 05:23 cut -> coreutils
lrwxrwxrwx 1 root root         9 Nov  8 05:23 date -> coreutils
lrwxrwxrwx 1 root root         7 Nov  8 05:23 dc -> busybox
lrwxrwxrwx 1 root root         9 Nov  8 05:23 dd -> coreutils
lrwxrwxrwx 1 root root         7 Nov  8 05:23 deallocvt -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 delgroup -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 deluser -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 devmem -> busybox
lrwxrwxrwx 1 root root         9 Nov  8 05:23 df -> coreutils
lrwxrwxrwx 1 root root         7 Nov  8 05:23 diff -> busybox
lrwxrwxrwx 1 root root         9 Nov  8 05:23 dir -> coreutils
lrwxrwxrwx 1 root root         9 Nov  8 05:23 dircolors -> coreutils
lrwxrwxrwx 1 root root         9 Nov  8 05:23 dirname -> coreutils
lrwxrwxrwx 1 root root         7 Nov  8 05:23 dnsd -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 dnsdomainname -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 dos2unix -> busybox
lrwxrwxrwx 1 root root         9 Nov  8 05:23 du -> coreutils
lrwxrwxrwx 1 root root         7 Nov  8 05:23 dumpkmap -> busybox
lrwxrwxrwx 1 root root         9 Nov  8 05:23 echo -> coreutils
lrwxrwxrwx 1 root root         7 Nov  8 05:23 egrep -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 eject -> busybox
lrwxrwxrwx 1 root root         9 Nov  8 05:23 env -> coreutils
lrwxrwxrwx 1 root root         7 Nov  8 05:23 ether-wake -> busybox
lrwxrwxrwx 1 root root         9 Nov  8 05:23 expand -> coreutils
lrwxrwxrwx 1 root root         9 Nov  8 05:23 expr -> coreutils
lrwxrwxrwx 1 root root         9 Nov  8 05:23 factor -> coreutils
lrwxrwxrwx 1 root root         7 Nov  8 05:23 fallocate -> busybox
lrwxrwxrwx 1 root root         9 Nov  8 05:23 false -> coreutils
lrwxrwxrwx 1 root root         7 Nov  8 05:23 fbset -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 fdflush -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 fdformat -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 fgrep -> busybox
lrwxrwxrwx 1 root root         3 Nov  8 05:23 flannel -> cni
lrwxrwxrwx 1 root root         9 Nov  8 05:23 fmt -> coreutils
lrwxrwxrwx 1 root root         9 Nov  8 05:23 fold -> coreutils
lrwxrwxrwx 1 root root         7 Nov  8 05:23 free -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 freeramdisk -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 fsck -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 fsfreeze -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 fuser -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 getopt -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 getty -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 grep -> busybox
lrwxrwxrwx 1 root root         9 Nov  8 05:23 groups -> coreutils
lrwxrwxrwx 1 root root         7 Nov  8 05:23 gunzip -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 gzip -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 halt -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 hdparm -> busybox
lrwxrwxrwx 1 root root         9 Nov  8 05:23 head -> coreutils
lrwxrwxrwx 1 root root         7 Nov  8 05:23 hexedit -> busybox
lrwxrwxrwx 1 root root         9 Nov  8 05:23 hostid -> coreutils
lrwxrwxrwx 1 root root         3 Nov  8 05:23 host-local -> cni
lrwxrwxrwx 1 root root         7 Nov  8 05:23 hostname -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 hwclock -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 i2cdetect -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 i2cdump -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 i2cget -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 i2cset -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 i2ctransfer -> busybox
lrwxrwxrwx 1 root root         9 Nov  8 05:23 id -> coreutils
lrwxrwxrwx 1 root root         7 Nov  8 05:23 ifconfig -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 ifdown -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 ifup -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 inetd -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 init -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 insmod -> busybox
lrwxrwxrwx 1 root root         9 Nov  8 05:23 install -> coreutils
lrwxrwxrwx 1 root root         7 Nov  8 05:23 ipaddr -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 ipcrm -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 ipcs -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 iplink -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 ipneigh -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 iproute -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 iprule -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 iptunnel -> busybox
lrwxrwxrwx 1 root root         9 Nov  8 05:23 join -> coreutils
lrwxrwxrwx 1 root root         3 Nov  8 05:23 k3s-agent -> k3s
lrwxrwxrwx 1 root root         3 Nov  8 05:23 k3s-certificate -> k3s
lrwxrwxrwx 1 root root         3 Nov  8 05:23 k3s-completion -> k3s
lrwxrwxrwx 1 root root         3 Nov  8 05:23 k3s-etcd-snapshot -> k3s
lrwxrwxrwx 1 root root         3 Nov  8 05:23 k3s-secrets-encrypt -> k3s
lrwxrwxrwx 1 root root         3 Nov  8 05:23 k3s-server -> k3s
lrwxrwxrwx 1 root root         9 Nov  8 05:23 kill -> coreutils
lrwxrwxrwx 1 root root         7 Nov  8 05:23 killall -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 killall5 -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 klogd -> busybox
lrwxrwxrwx 1 root root         3 Nov  8 05:23 kubectl -> k3s
lrwxrwxrwx 1 root root         7 Nov  8 05:23 last -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 less -> busybox
lrwxrwxrwx 1 root root         9 Nov  8 05:23 link -> coreutils
lrwxrwxrwx 1 root root         7 Nov  8 05:23 linux32 -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 linux64 -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 linuxrc -> busybox
lrwxrwxrwx 1 root root         9 Nov  8 05:23 ln -> coreutils
lrwxrwxrwx 1 root root         7 Nov  8 05:23 loadfont -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 loadkmap -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 logger -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 login -> busybox
lrwxrwxrwx 1 root root         9 Nov  8 05:23 logname -> coreutils
lrwxrwxrwx 1 root root         3 Nov  8 05:23 loopback -> cni
lrwxrwxrwx 1 root root         9 Nov  8 05:23 ls -> coreutils
lrwxrwxrwx 1 root root         7 Nov  8 05:23 lsattr -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 lsmod -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 lsof -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 lspci -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 lsscsi -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 lsusb -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 lzcat -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 lzma -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 lzopcat -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 makedevs -> busybox
lrwxrwxrwx 1 root root         9 Nov  8 05:23 md5sum -> coreutils
lrwxrwxrwx 1 root root         7 Nov  8 05:23 mdev -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 mesg -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 microcom -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 mim -> busybox
lrwxrwxrwx 1 root root         9 Nov  8 05:23 mkdir -> coreutils
lrwxrwxrwx 1 root root         7 Nov  8 05:23 mkdosfs -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 mke2fs -> busybox
lrwxrwxrwx 1 root root         9 Nov  8 05:23 mkfifo -> coreutils
lrwxrwxrwx 1 root root         9 Nov  8 05:23 mknod -> coreutils
lrwxrwxrwx 1 root root         7 Nov  8 05:23 mkpasswd -> busybox
lrwxrwxrwx 1 root root         9 Nov  8 05:23 mktemp -> coreutils
lrwxrwxrwx 1 root root         7 Nov  8 05:23 more -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 mountpoint -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 mt -> busybox
lrwxrwxrwx 1 root root         9 Nov  8 05:23 mv -> coreutils
lrwxrwxrwx 1 root root         7 Nov  8 05:23 nameif -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 netstat -> busybox
lrwxrwxrwx 1 root root         9 Nov  8 05:23 nice -> coreutils
lrwxrwxrwx 1 root root         9 Nov  8 05:23 nl -> coreutils
lrwxrwxrwx 1 root root         9 Nov  8 05:23 nohup -> coreutils
lrwxrwxrwx 1 root root         7 Nov  8 05:23 nologin -> busybox
lrwxrwxrwx 1 root root         9 Nov  8 05:23 nproc -> coreutils
lrwxrwxrwx 1 root root         7 Nov  8 05:23 nslookup -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 nuke -> busybox
lrwxrwxrwx 1 root root         9 Nov  8 05:23 numfmt -> coreutils
lrwxrwxrwx 1 root root         9 Nov  8 05:23 od -> coreutils
lrwxrwxrwx 1 root root         7 Nov  8 05:23 openvt -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 partprobe -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 passwd -> busybox
lrwxrwxrwx 1 root root         9 Nov  8 05:23 paste -> coreutils
lrwxrwxrwx 1 root root         7 Nov  8 05:23 patch -> busybox
lrwxrwxrwx 1 root root         9 Nov  8 05:23 pathchk -> coreutils
lrwxrwxrwx 1 root root         7 Nov  8 05:23 pidof -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 ping -> busybox
lrwxrwxrwx 1 root root         9 Nov  8 05:23 pinky -> coreutils
lrwxrwxrwx 1 root root         7 Nov  8 05:23 pipe_progress -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 pivot_root -> busybox
lrwxrwxrwx 1 root root         3 Nov  8 05:23 portmap -> cni
lrwxrwxrwx 1 root root         7 Nov  8 05:23 poweroff -> busybox
lrwxrwxrwx 1 root root         9 Nov  8 05:23 pr -> coreutils
lrwxrwxrwx 1 root root         9 Nov  8 05:23 printenv -> coreutils
lrwxrwxrwx 1 root root         9 Nov  8 05:23 printf -> coreutils
lrwxrwxrwx 1 root root         7 Nov  8 05:23 ps -> busybox
lrwxrwxrwx 1 root root         9 Nov  8 05:23 ptx -> coreutils
lrwxrwxrwx 1 root root         9 Nov  8 05:23 pwd -> coreutils
lrwxrwxrwx 1 root root         7 Nov  8 05:23 rdate -> busybox
lrwxrwxrwx 1 root root         9 Nov  8 05:23 readlink -> coreutils
lrwxrwxrwx 1 root root         9 Nov  8 05:23 realpath -> coreutils
lrwxrwxrwx 1 root root         7 Nov  8 05:23 reboot -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 reset -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 resize -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 resume -> busybox
lrwxrwxrwx 1 root root         9 Nov  8 05:23 rm -> coreutils
lrwxrwxrwx 1 root root         9 Nov  8 05:23 rmdir -> coreutils
lrwxrwxrwx 1 root root         7 Nov  8 05:23 rmmod -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 route -> busybox
lrwxrwxrwx 1 root root         9 Nov  8 05:23 runcon -> coreutils
lrwxrwxrwx 1 root root         7 Nov  8 05:23 run-init -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 runlevel -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 run-parts -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 sed -> busybox
lrwxrwxrwx 1 root root         9 Nov  8 05:23 seq -> coreutils
lrwxrwxrwx 1 root root         7 Nov  8 05:23 setarch -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 setconsole -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 setfattr -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 setkeycodes -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 setlogcons -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 setpriv -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 setserial -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 sh -> busybox
lrwxrwxrwx 1 root root         9 Nov  8 05:23 sha1sum -> coreutils
lrwxrwxrwx 1 root root         9 Nov  8 05:23 sha224sum -> coreutils
lrwxrwxrwx 1 root root         9 Nov  8 05:23 sha256sum -> coreutils
lrwxrwxrwx 1 root root         9 Nov  8 05:23 sha384sum -> coreutils
lrwxrwxrwx 1 root root         7 Nov  8 05:23 sha3sum -> busybox
lrwxrwxrwx 1 root root         9 Nov  8 05:23 sha512sum -> coreutils
lrwxrwxrwx 1 root root         9 Nov  8 05:23 shred -> coreutils
lrwxrwxrwx 1 root root         9 Nov  8 05:23 shuf -> coreutils
lrwxrwxrwx 1 root root         9 Nov  8 05:23 sleep -> coreutils
lrwxrwxrwx 1 root root         9 Nov  8 05:23 sort -> coreutils
lrwxrwxrwx 1 root root         9 Nov  8 05:23 split -> coreutils
lrwxrwxrwx 1 root root         7 Nov  8 05:23 start-stop-daemon -> busybox
lrwxrwxrwx 1 root root         9 Nov  8 05:23 stat -> coreutils
lrwxrwxrwx 1 root root         7 Nov  8 05:23 strings -> busybox
lrwxrwxrwx 1 root root         9 Nov  8 05:23 stty -> coreutils
lrwxrwxrwx 1 root root         7 Nov  8 05:23 su -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 sulogin -> busybox
lrwxrwxrwx 1 root root         9 Nov  8 05:23 sum -> coreutils
lrwxrwxrwx 1 root root         7 Nov  8 05:23 svc -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 svok -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 switch_root -> busybox
lrwxrwxrwx 1 root root         9 Nov  8 05:23 sync -> coreutils
lrwxrwxrwx 1 root root         7 Nov  8 05:23 sysctl -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 syslogd -> busybox
lrwxrwxrwx 1 root root         9 Nov  8 05:23 tac -> coreutils
lrwxrwxrwx 1 root root         9 Nov  8 05:23 tail -> coreutils
lrwxrwxrwx 1 root root         7 Nov  8 05:23 tar -> busybox
lrwxrwxrwx 1 root root         9 Nov  8 05:23 tee -> coreutils
lrwxrwxrwx 1 root root         7 Nov  8 05:23 telnet -> busybox
lrwxrwxrwx 1 root root         9 Nov  8 05:23 test -> coreutils
lrwxrwxrwx 1 root root         7 Nov  8 05:23 tftp -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 time -> busybox
lrwxrwxrwx 1 root root         9 Nov  8 05:23 timeout -> coreutils
lrwxrwxrwx 1 root root         7 Nov  8 05:23 top -> busybox
lrwxrwxrwx 1 root root         9 Nov  8 05:23 touch -> coreutils
lrwxrwxrwx 1 root root         9 Nov  8 05:23 tr -> coreutils
lrwxrwxrwx 1 root root         7 Nov  8 05:23 traceroute -> busybox
lrwxrwxrwx 1 root root         9 Nov  8 05:23 true -> coreutils
lrwxrwxrwx 1 root root         9 Nov  8 05:23 truncate -> coreutils
lrwxrwxrwx 1 root root         7 Nov  8 05:23 ts -> busybox
lrwxrwxrwx 1 root root         9 Nov  8 05:23 tsort -> coreutils
lrwxrwxrwx 1 root root         9 Nov  8 05:23 tty -> coreutils
lrwxrwxrwx 1 root root         7 Nov  8 05:23 ubirename -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 udhcpc -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 uevent -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 umount -> busybox
lrwxrwxrwx 1 root root         9 Nov  8 05:23 uname -> coreutils
lrwxrwxrwx 1 root root         9 Nov  8 05:23 unexpand -> coreutils
lrwxrwxrwx 1 root root         9 Nov  8 05:23 uniq -> coreutils
lrwxrwxrwx 1 root root         7 Nov  8 05:23 unix2dos -> busybox
lrwxrwxrwx 1 root root         9 Nov  8 05:23 unlink -> coreutils
lrwxrwxrwx 1 root root         7 Nov  8 05:23 unlzma -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 unlzop -> busybox
lrwxrwxrwx 1 root root         4 Nov  8 05:23 unpigz -> pigz
lrwxrwxrwx 1 root root         7 Nov  8 05:23 unxz -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 unzip -> busybox
lrwxrwxrwx 1 root root         9 Nov  8 05:23 uptime -> coreutils
lrwxrwxrwx 1 root root         9 Nov  8 05:23 users -> coreutils
lrwxrwxrwx 1 root root         7 Nov  8 05:23 usleep -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 uudecode -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 uuencode -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 vconfig -> busybox
lrwxrwxrwx 1 root root         9 Nov  8 05:23 vdir -> coreutils
lrwxrwxrwx 1 root root         7 Nov  8 05:23 vi -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 vlock -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 w -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 watch -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 watchdog -> busybox
lrwxrwxrwx 1 root root         9 Nov  8 05:23 wc -> coreutils
lrwxrwxrwx 1 root root         7 Nov  8 05:23 wget -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 which -> busybox
lrwxrwxrwx 1 root root         9 Nov  8 05:23 who -> coreutils
lrwxrwxrwx 1 root root         9 Nov  8 05:23 whoami -> coreutils
lrwxrwxrwx 1 root root         7 Nov  8 05:23 xxd -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 xz -> busybox
lrwxrwxrwx 1 root root         7 Nov  8 05:23 xzcat -> busybox
lrwxrwxrwx 1 root root         9 Nov  8 05:23 yes -> coreutils
lrwxrwxrwx 1 root root         7 Nov  8 05:23 zcat -> busybox
```



## CloudRootfs

### 我怎样才能得到 CloudRootfs

1. 拉一个BaseImage`sealer pull kubernetes:v1.19.8-alpine`
2. 查看镜像层信息`sealer inspect kubernetes:v1.19.8-alpine`
3. 进入BaseImage层`ls /var/lib/sealer/data/overlay2/{layer-id}`

您会找到 CloudRootfs 层。

::: warning overlay2
在 docker 中或许能经常看见它，在 CloudRootfs 我又遇见了ta

docker作为一个容器平台，它有一套自己的存储系统。它支持的driver有overlay,overlay2, aufs等等。

```bash
root@cubmaster01:/var/lib/docker# ls
buildkit  containers  image  network  overlay2  plugins  runtimes  swarm  tmp  trust  volumes
```

 我们需要学会ta，因为这个也和 镜像的 构建 息息相关~

:::

::: details 💡简单的一个案例如下
启动docker，删除本地所有的镜像。进入/var/lib/docker/overlay目录，可以看到此时这个目录下面什么都没有，是空的。

*dockerfile：*

```
[root@iZbp1evo5cnwagauz3w188Z tmp]# ls; cat >> Dockerfile <<-EOF
FROM ubuntu
COPY aa /
COPY bb /
COPY cc /
EOF
aa  bb  cc
```

🚀 编译：

```dockerfile
docker build -t aabbcc .
```

![image-20221125191615259](http://sm.nsddd.top/smimage-20221125191615259.png)

上面的一系列操作制作了一个名字为aabbcc的image。此时可以在/var/lib/docker/overlay 下面观察到新的层已经生成了。这里每copy一个文件就会生成新的一层。

观察一下/var/lib/docker/overlay/目录。aa文件出现了三次，bb文件出现了两次，cc文件只出现了一次，这也与我们拷贝它们的顺序相吻合。

层级结构一目了然。

```bash
[root@iZbp1evo5cnwagauz3w188Z tmp]# ls cfd414e52a3b25dade86fb2333d5cd84bb0632e55872914e42c0510cf7c211ea/root/
aa  bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var
[root@iZbp1evo5cnwagauz3w188Z tmp]#  ls 5b42d020f1bc93d2643e67c6fe7d86f3a20efd80767bf505853dd743d8b51a31/root/
aa  bb  bin  boot  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var
[root@iZbp1evo5cnwagauz3w188Z tmp]#  ls 00e5e192b42ad8923eda7d43016c56864fdb0c22c239cb141140c9959d138400/root/
aa  bb  bin  boot  cc  dev  etc  home  lib  lib64  media  mnt  opt  proc  root  run  sbin  srv  sys  tmp  usr  var
```

这里aa实际上是通过硬链接的方式链到不同的层里的。下面，我们尝试使用aabbcc运行一个容器。从中我们可以观察到，多出了一个aa文件，这实际上就是容器真正运行的`rootfs(bfa602b98523bcc9d311e39729f1b4fd8a5046d5856b3d153886a67373a0f9f9/merged)`。

通过mount指令，我们可以观察到内核将镜像和upper挂载到了指定的rootfs中了。

总结一下，overlay对于每一层都会构筑一个完整的镜像，镜像和镜像之间通过硬链接共享文件。当启动一个容器时，内核会union mount这个容器所使用的镜像所对应的layer(lowerdir)和一个读写层(upperdir)，并且lowerdir只有一层。



**overlay2:**

用同样的`Dockerfile`构建一个叫`aabbcc`的`image`，观察`/var/lib/docker/overlay2`下面的文件，我们可以看到各个文件只有一个。

:::

### overlay && overlay2

::: warning 总结
overlay实际上通过硬链接在层和层之间共享文件，而 `overlay2` 的每一层都是完全独立的。如果容器启动的话，它会将多层`lowerdir` 挂载到它的`rootfs`。

这种设计就会带来一个问题，那就是linux系统会限制系统中硬链接的数量，如果用户下载了很多容器，那么`docker`就会在系统中到处创建硬链接，达到最大值后将无法创建新容器。

因此，我们应该使用`overlay2`作为`docker`的 graph driver 而不是overlay
:::





### 构建自己的 CloudRootfs

您可以根据需要编辑 CloudRootfs 中的任何文件，例如您想要定义自己的 docker daemon.json，只需编辑它并构建一个新的 CloudImage。

```shell
FROM scratch
COPY . .
sealer build -t user-defined-kubernetes:v1.19.8 .
```

然后您可以将此图像用作 BaseImage。



## 卸载 

### k0s

要卸载k0s，您需要执行以下步骤：

1. 进入k0s的安装目录，通常为/usr/local/k0s，执行以下命令来停止k0s服务：

```
Copy code
./k0s-stop.sh
```

2. 执行以下命令来删除k0s安装目录及其相关文件：

```
Copy code
rm -rf /usr/local/k0s
```

3. 执行以下命令来删除k0s所安装的系统服务：

```
Copy coderm /etc/systemd/system/k0s.service
systemctl daemon-reload
```

4. 执行以下命令来删除k0s相关的用户和组：

```
Copy codeuserdel -r k0s
groupdel k0s
```

执行上述步骤后，k0s就已经被卸载完成了。如果您还有其他问题，可以参考k0s的文档或者提交问题到k0s的官方论坛。



### k3s

要卸载k3s，您需要执行以下步骤：

1. 使用`k3s-killall.sh`脚本停止k3s服务。这个脚本可以在k3s安装目录下找到，通常是`/usr/local/bin`。当然你也可以找到删除脚本直接删除即可。
2. 删除k3s相关的所有文件和目录。这些文件包括安装目录下的所有文件，以及`/etc/rancher/k3s`目录。
3. 删除k3s相关的系统服务。要删除这些服务，您可以使用以下命令：

```bash
Copy codesystemctl disable k3s
systemctl stop k3s
rm -f /etc/systemd
/system/k3s.service
```

这些步骤应该可以帮助您完成k3s的卸载。



## END 链接

<ul><li><div><a href = '4.md' style='float:left'>⬆️上一节🔗  </a><a href = '6.md' style='float: right'>  ️下一节🔗</a></div></li></ul>

+ [Ⓜ️回到目录🏠](../README.md)

+ [**🫵参与贡献💞❤️‍🔥💖**](https://nsddd.top/archives/contributors))

+ ✴️版权声明 &copy; ：本书所有内容遵循[CC-BY-SA 3.0协议（署名-相同方式共享）&copy;](http://zh.wikipedia.org/wiki/Wikipedia:CC-by-sa-3.0协议文本) 
